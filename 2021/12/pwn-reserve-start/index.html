<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="冷风喧嚣" href="https://coldwinds5167.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="冷风喧嚣" href="https://coldwinds5167.github.io/atom.xml"><link rel="alternate" type="application/json" title="冷风喧嚣" href="https://coldwinds5167.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="pwn,reserve"><link rel="canonical" href="https://coldwinds5167.github.io/2021/12/pwn-reserve-start/"><title>二进制（pwn、reverse）学习方向 | Coldwinds = 冷风喧嚣 = 懒狗一只</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">二进制（pwn、reverse）学习方向</h1><div class="meta"><span class="item" title="创建时间：2021-12-11 23:45:55"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2021-12-11T23:45:55+08:00">2021-12-11</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>9.8k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>9 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Coldwinds</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclflwv2aj20zk0m84qp.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclfb3vzhj20zk0m8wny.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gicit31ffoj20zk0m8naf.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclh5u05ej20zk0m87df.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giciszlczyj20zk0m816d.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gicljitigmj20zk0m87fp.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://coldwinds5167.github.io/2021/12/pwn-reserve-start/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Coldwinds"><meta itemprop="description" content="懒狗一只, "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="冷风喧嚣"></span><div class="body md" itemprop="articleBody"><h1 id="0x00-安全素养"><a class="anchor" href="#0x00-安全素养">#</a> 0x00 安全素养</h1><h2 id="网络安全法"><a class="anchor" href="#网络安全法">#</a> 网络安全法</h2><p><strong>不要违法，不要违法，不要违法。</strong></p><p><strong>参考资料：</strong></p><p><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTQlQjglQUQlRTUlOEQlOEUlRTQlQkElQkElRTYlQjAlOTElRTUlODUlQjElRTUlOTIlOEMlRTUlOUIlQkQlRTclQkQlOTElRTclQkIlOUMlRTUlQUUlODklRTUlODUlQTglRTYlQjMlOTU=">https://baike.baidu.com/item/ 中华人民共和国网络安全法</span></p><h1 id="0x01-基础"><a class="anchor" href="#0x01-基础">#</a> 0x01 基础</h1><p>编程和逆向工程的能力是<strong>相当重要</strong>的。</p><h2 id="编程语言功底"><a class="anchor" href="#编程语言功底">#</a> 编程语言功底</h2><ul><li><p>精通 C 语言（指针、函数）、C++</p></li><li><p>汇编语言（熟悉常见指令及寄存器等，能够熟练阅读汇编代码）</p></li><li><p>熟练使用 python</p></li></ul><h2 id="逆向功底底层原理"><a class="anchor" href="#逆向功底底层原理">#</a> 逆向功底 &amp; 底层原理</h2><ul><li><p>IDA PRO 的使用（或者 Ghidra 等其它工具）</p></li><li><p>gdb 的基本使用（断点、单步、查看内存等）</p></li></ul><ul><li>《程序员的自我修养》<ul><li>程序的编译链接原理</li><li>内存管理</li><li>进程地址空间</li><li>函数调用惯例</li><li>…</li></ul></li></ul><ul><li>…</li></ul><h1 id="0x02-二进制安全"><a class="anchor" href="#0x02-二进制安全">#</a> 0x02 <strong>二进制安全</strong></h1><h2 id="ctf"><a class="anchor" href="#ctf">#</a> CTF</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jdGYtd2lraS5vcmcv">https://ctf-wiki.org/</span></p><p>先从 CTF 入手，学习各种漏洞类型及利用手法，不断刷题、阅读，大一大二专注在 CTF 比赛中，要求能够解决大部分常规难度的题目。</p><p>学习新的题目时，不要先看 wp，要先自己去找漏洞，找漏洞是最重要的，漏洞的利用上可以跟着 wp 一步一步调试。</p><p>这里有一些刷题平台：</p><ul><li><strong><span class="exturl" data-url="aHR0cHM6Ly9idXVvai5jbi8=">https://buuoj.cn/</span></strong></li><li><span class="exturl" data-url="aHR0cHM6Ly9jdGYuYnVna3UuY29tLw==">https://ctf.bugku.com/</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY3RmaHViLmNvbS8jL2luZGV4">https://www.ctfhub.com/#/index</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9hZHdvcmxkLnhjdGYub3JnLmNuLw==">https://adworld.xctf.org.cn/</span></li><li><span class="exturl" data-url="aHR0cHM6Ly9wd25hYmxlLnR3Lw==">https://pwnable.tw/</span></li></ul><h3 id="pwn"><a class="anchor" href="#pwn">#</a> PWN</h3><h4 id="配置环境"><a class="anchor" href="#配置环境">#</a> 配置环境</h4><p>CTF 中接触到的 PWN 题大多属于 LINUX PWN，给电脑装 LINUX 系统比较麻烦，一般情况下是装虚拟机。</p><p>如果想跳过配置环境这一步，可以直接使用 KALI LINUX，但还是建议自己装一次环境（日后可能会需要下载安装一些工具，需要会 LINUX 系统的操作）。</p><p>可以参考我的另一篇文章：</p><p></p><div class="links"><div class="item" title="Coldwinds" style="--block-color:#9d5b8b"><a href="https://coldwinds5167.github.io/2021/12/pwn-environment/" class="image" data-background-image="https://raw.githubusercontent.com/Coldwinds5167/Picture/main/img/avatar.jpg"></a><div class="info"><a href="https://coldwinds5167.github.io/2021/12/pwn-environment/" class="title">冷风喧嚣</a><p class="desc">pwn环境搭建</p></div></div></div><p></p><h4 id="基本工具"><a class="anchor" href="#基本工具">#</a> 基本工具</h4><h5 id="逆向辅助类"><a class="anchor" href="#逆向辅助类">#</a> 逆向辅助类</h5><ul><li><p><strong>IDA PRO</strong></p><blockquote><p>IDA PRO 是一款很好用的反汇编工具，其反编译插件在很多时候能够将代码还原到接近源码的水平，但是 IDA 的使用比较复杂，需要自己学习。</p></blockquote><blockquote><p>链接：<span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMVpOOEtkMlFicG5QNXFtMVFCZnhhSUE=">https://pan.baidu.com/s/1ZN8Kd2QbpnP5qm1QBfxaIA</span><br>提取码：j2my</p></blockquote></li><li><p><strong>GDB</strong></p><blockquote><p>GDB 是一款功能强大的程序调试工具，是动态调试必不可少的工具，可以很方便的查看堆中链表的状态，各个地址的内容。GDB 拥有多个插件（peda、pwndbg、gef 等）这些插件提供了一些额外的命令，在可视化和功能上都进行了扩展。</p><p>推荐安装一个插件即可，多个插件的切换与系统环境变量相关，自行百度。</p></blockquote></li></ul><h5 id="漏洞利用类"><a class="anchor" href="#漏洞利用类">#</a> 漏洞利用类</h5><p>这一类工具几乎都可以在<strong> GITHUB</strong> 上下载。</p><ul><li><p><strong>pwntools</strong></p><blockquote><p>pwntools 是一个 CTF 框架和漏洞利用开发库，涵盖了 pwn 题利用脚本所需要的各种工具。包括方便的 IO 交互函数，ROP、格式化字符串等利用的自动化工具，shellcode 生成器等等，是目前最好用也是仅有的大型 pwn 利用框架。能节省大量编写脚本的时间。</p></blockquote></li><li><p>ZIO</p><blockquote><p>ZIO 是一个专门为 CTF PWN 开发的 Python 库，基于 ZIO 可以方便实现对远程服务器上的服务程序进行数据读写操作，也支持对本地程序的数据读写操作。</p></blockquote></li><li><p>ROPgadget</p><blockquote><p>ROP 是一种高级的内存攻击技术，常用来绕过现代操作系统的各种通用防御。Ropgadget 用于找寻程序中用来组装 ROP 链的 gadget。</p></blockquote></li><li><p><strong>checksec</strong></p><blockquote><p>查询程序架构和保护机制的开启状况。</p></blockquote></li><li><p><strong>one_gadget</strong></p><blockquote><p>分析定位 libc 中获取 shell 的地址，在满足特定条件的情况下，仅拥有该地址就可以 get shell。而非手动输入 /bin/sh 和 system 的地址。</p></blockquote></li><li><p><strong>seccomp-tools</strong></p><blockquote><p>分析程序中的 seccomp 安全机制开启的具体情况。</p></blockquote></li><li><p>...</p></li></ul><h4 id="保护机制"><a class="anchor" href="#保护机制">#</a> 保护机制</h4><h5 id="系统选项"><a class="anchor" href="#系统选项">#</a> 系统选项</h5><p>ASLR：地址空间随机化 (系统选项)</p><blockquote><p>ASLR 有三个等级，对应系统文件中的三个值。</p><p>0：关闭 ASLR。</p><p>1：mmap base、stack、vdso page 将随机化，“.so” 文件会被加载到随机地址，程序的代码段加载地址将被随机化。</p><p>2：在 1 的基础上增加了 heap 随机化。</p><p>ASLR 保证每次程序加载的时候自身和所加载的库文件都会被映射到虚拟地址空间的不同地址处。</p></blockquote><h5 id="编译选项"><a class="anchor" href="#编译选项">#</a> 编译选项</h5><ul><li><p>NX：堆栈不可执行</p><blockquote><p>主要防止程序直接在非可执行的内存区（堆和栈）上运行 shellcode 代码。</p></blockquote></li><li><p>PIE：程序基地址随机化</p><blockquote><p>程序每个段加载出来的基地址都是随机化的。</p></blockquote></li><li><p>RELRO：重定位</p><blockquote><p>一般分为 partial relro 和 full relro 两种情况，前者重定位信息可写（如 GOT 表），后者不可写。</p></blockquote></li><li><p>STACK CANARY：栈溢出保护</p><blockquote><p>在栈的缓冲区和控制信息（如 EBP 等）间插入一个 canary word。这样，当缓冲区被溢出时，在返回地址被覆盖之前 canary word 会首先被覆盖。通过检查 canary word 的值是否被修改，就可以判断是否发生了溢出攻击，从而保护程序因为栈溢出而被攻击。</p></blockquote></li></ul><h4 id="常见漏洞"><a class="anchor" href="#常见漏洞">#</a> 常见漏洞</h4><h5 id="栈相关漏洞"><a class="anchor" href="#栈相关漏洞">#</a> 栈相关漏洞</h5><p>学习栈相关漏洞首先要对程序<strong>栈的结构</strong>，<strong>调用机制</strong>，以及函数参数传递规则（函数参数入栈出栈顺序）有一定了解。</p><ul><li><p><strong>栈溢出</strong></p><p>指栈上的缓冲区被填入了过多的数据，超出了边界，从而导致栈上原有的数据被覆盖，如果能让指定内容覆盖到某些位置，就能 get shell，通常覆盖栈的<strong>局部变量</strong>、<strong>bp</strong>（函数栈栈底指针）、<strong>ip</strong>（程序返回地址）。</p><blockquote><p>关于栈溢出有几个需要学习的点：</p><ul><li><p>当开启 NX 和 CANARY 后如何执行栈溢出。</p></li><li><p>覆盖 ip：ip 存放的是返回到父函数调用处的下一个位置，如果通过栈缓冲区用某一地址 a 覆盖了 ip，在该函数结束后，会跳转到 a 地址上，从而劫持控制流。</p></li><li><p>覆盖栈中存储的临时变量：在知道两个变量地址偏移时，可以通过一个变量覆盖另一个变良，从而改变另一个变量。</p></li><li><p>关注一些敏感函数：这些函数能够产生缓冲区溢出，从而实现栈溢出。</p><p>常见的漏洞函数：</p><ul><li>gets(buff)</li><li>scanf(&quot;%s&quot;,buff)</li><li>...</li></ul><p>潜在的漏洞函数：</p><ul><li>read</li><li>strcpy</li><li>memcpy</li><li>...</li></ul></li></ul></blockquote></li></ul><h5 id="栈相关漏洞的利用"><a class="anchor" href="#栈相关漏洞的利用">#</a> 栈相关漏洞的利用</h5><ul><li><p>栈的特殊利用</p><ul><li><p>libc 信息泄露：main 函数栈底存放了返回地址，如果能泄露改返回地址，就能计算出 libc 的基址，从而得到其他函数地址。</p></li><li><p>通过 libc 泄露栈地址：在已知 libc 地址的情况下，可以根据 libc 中的 Environ 偏移来计算栈的偏移，从而计算出栈的地址。</p></li><li><p>往栈上写 ROP</p></li><li><p>环境变量修改</p></li><li><p>多级指针</p></li></ul></li><li><p>栈喷射</p><p>在 ROP 时无法找到确定的栈地址，便预先在栈中布置大量重复的 ROP 数据块，只要在返回时位于其中一个数据块就能实现 ROP。</p><blockquote><p>并非必须是 ROP，shellcode、ROP 地址等数据也可以利用栈喷射。</p></blockquote></li><li><p>栈迁移</p><p>溢出的长度太短，尝试改变 sp 和 bp 寄存器的值，在新一段地址上建立栈并写入 rop 链</p></li><li><p>线程栈</p><blockquote><p>现阶段了解一下即可。</p></blockquote></li></ul><h5 id="堆相关漏洞堆漏洞是ctf比赛重点"><a class="anchor" href="#堆相关漏洞堆漏洞是ctf比赛重点">#</a> 堆相关漏洞（堆漏洞是 CTF 比赛重点）</h5><p>堆主要指用户动态申请的内存（如调用 malloc、alloc、alloca 等函数）。</p><p>学习堆相关漏洞需要了解：</p><blockquote><p><strong>堆基本数据结构 chunk</strong>（alloced chunk、free chunk、top chunk）。</p><p><strong>堆空闲块管理结构 bin</strong>（fast bin、unsorted bin、small bin、large bin）。</p><p>malloc、free 函数的基本规则，建议结合源码对照分析。</p><p><strong>tcache</strong> 机制（很重要）。</p></blockquote><ul><li><p>常规堆溢出</p><blockquote><p>与栈溢出类似，在堆上的缓冲区被填入了过多的数据，超出了边界，导致堆中原有的数据被覆盖。通常有以下两种情况：</p><ul><li>覆盖本堆块内部数据：通常发生在结构体内部，如结构体中数组溢出，就会覆盖后续变量。</li><li>覆盖后续堆块数据：不仅影响后续堆块的数据，还破坏了堆块的结构。</li></ul><p>第一种情况，参照栈溢出即可。</p><p>第二种情况，有其他利用方法。</p></blockquote></li><li><p><strong>Off By One</strong></p><blockquote><p>相比于常规的堆溢出，Off By One 只能溢出一字节，在 CTF 比赛中，Off By One 通常位于堆块末尾，溢出的一字节恰好能够覆盖下一堆块的 size 域的最低位，Off By One 本身比较难以利用，通常用来触发 Unlink。</p></blockquote></li><li><p><strong>Use After Free（UAF）</strong></p><blockquote><p>UAF 即释放后使用漏洞，当堆指针在释放后为被置 NULL，就会形成悬挂指针，在下一次访问该指针时，仍然能够访问到原指针所指向的堆内容。UAF 的利用需要具体问题具体分析，来确定其是否能泄露信息或修改信息。</p></blockquote></li><li><p><strong>Double Free</strong></p><blockquote><p>Double Free 主要指对指针存在多次释放的情况，算是 UAF 中比较特殊的一种，针对用于释放堆块的函数。对此释放能够使堆块发生重叠，前后申请的堆块可能会指向同一块内存。还可以构造特殊的堆结构，从而运用针对堆结构的利用方法。</p></blockquote></li><li><p>IO_FILE</p><blockquote><p>IO_FILE 本身并不是漏洞，而是程序执行 fopen 等函数时创建的结构体。在出现 House Of Orange 后，陆续出现了利用 IO_FILE 进行攻击的手法</p><ul><li>FSOP</li><li>Vtable 劫持</li><li>利用缓冲区指针达成任意读写</li><li>…</li></ul></blockquote></li></ul><h5 id="堆相关漏洞的利用"><a class="anchor" href="#堆相关漏洞的利用">#</a> 堆相关漏洞的利用</h5><ul><li><p>Unlink</p><blockquote><p>Unlink 是把 free 掉的堆块从所属的 bins 链中，卸下来的操作。它是在 free 掉一块 chunk (除 fastbin 的 chunk 外）之后，glibc 检查这块 chunk 相邻的上下两块 chunk 的 free 状态之后，做出的堆块合并引起的。</p><p>Unlink 攻击指的是先伪造堆块，在 free 操作时触发堆块合并，在绕过一系列检测机制后，就可以通过伪造的堆块修改其他堆块的指针，或者实现任意地址写。</p></blockquote></li><li><p>Fastbin Attack</p><blockquote><p>Fastbin Attack 主要针对 fastbin 的使用和释放机制，对 fastbin 的间接利用比较多。</p><p>直接利用 fastbin 的方法主要是针对 fastbin 的单链表结构，更改其后续指针，控制 fastbin 在下次所要分配的堆块。</p></blockquote></li><li><p>House Of Orange</p><blockquote><p>使用 Unsorted Bin Attack 修改 IO_list_all 来获取 shell。</p><p>学习 House Of Orange 需要理解两个概念 ——Unsorted Bin Attack 和 FSOP。</p></blockquote></li><li><p>Large bin attack</p><blockquote><p>覆盖 largebin 中 bk_nextsize 指针，在 largebin 插入 unsorted bin 时，可以做到往任意地址写一个堆地址的效果</p></blockquote></li><li><p>堆喷射</p><blockquote><p>堆喷射主要指在堆块中布置好大量重复性的数据，便于目的地址索引到堆上的数据，与栈喷射相似但更为麻烦，在真实漏洞中利用较多，而在 CTF 比赛中不常出现。</p></blockquote></li></ul><h5 id="格式化字符串漏洞"><a class="anchor" href="#格式化字符串漏洞">#</a> 格式化字符串漏洞</h5><p>格式化字符串漏洞主要是针对一些格式化函数（printf、sprintf、vsprintf 等）。这些格式化函数利用格式化字符串来指定串的格式。下面给出四个比较关键的格式符：</p><blockquote><ul><li><p>% x（% lx）：替换为参数的值（十六进制）。</p></li><li><p>% p：替换为参数的值（指针形式）。</p></li><li><p>% s：替换为参数所指向内存的字符串。</p></li><li><p>% n：将格式化串中该特殊字符之前的字符数量写入参数中（获取地址的参数）。</p></li></ul></blockquote><p>同时还要了解参数定位。</p><blockquote><p>例如：printf (&quot;% p,% x&quot;,&amp;a,&amp;b); 其中的 % p 和 % x 对应第 1、2 个参数。</p><p>也可以使用 &quot;% d$m&quot; 的形式来定位参数列表中第 d 个参数（从 1 开始）；其中 m 是前面所说的格式符（x、p、s、n 等）。</p></blockquote><h5 id="格式化字符串的利用"><a class="anchor" href="#格式化字符串的利用">#</a> 格式化字符串的利用</h5><p>格式化函数遇到格式符的关键字符后，会按照传参规则去寻找参数来进行替换或修改。如果实际参数数量小于所需参数数量，依然会将对应位置的数值当成参数进行转换，从而触发格式化字符串漏洞。</p><ul><li><p>任意地址读</p><blockquote><p>通过前面所说的参数定位 “% d$m”，在确定所需信息在栈中的位置（位于第几个参数），通过参数定位可以将该信息泄露出来。</p></blockquote></li><li><p>任意地址写</p><blockquote><p>主要是利用格式化字符串中的 % n 对参数进行写入，写入的值是格式化字符串中 % n 之前的字符数量。</p><p>% n 修改 4 字节、% hn 修改 2 字节、% hhn 修改 1 字节。</p><p>可以结合 % c 来修改成特定的值，例如 &quot;%100c&quot; 会替换为宽度为 100 的字符。</p></blockquote></li></ul><h5 id="整型漏洞"><a class="anchor" href="#整型漏洞">#</a> 整型漏洞</h5><p>整型漏洞主要指发生在整型数据上的漏洞，整型溢出指试图保存的数据超过整型数据的宽度时发生的溢出。</p><ul><li><p>宽度溢出</p><blockquote><p>整型数据在计算机中的存储一般按字节进行存储，不同的整型数据所需要的字节数也不同，“所需要的字节数” 就是该整型数据的宽度，如果数据所要表达的值大于这个宽度就会发生宽度溢出。</p><p>宽度溢出主要出现在：</p><ul><li><p>整型数据运算</p></li><li><p>整型数据赋值</p></li><li><p>...</p></li></ul></blockquote></li><li><p>符号转换</p><blockquote><p>符号转化通常用于：</p><ul><li>将无符号数和有符号数进行强制转换后数值相差过大，从而绕过条件判断。</li><li>有些函数对参数有特定要求，但使用时并没有严格按照参数的类型进行参数传递。</li></ul></blockquote></li><li><p>数组越界</p><blockquote><p>由于检查不严格，导致在对数组内存的索引时超出了数组的预设范围，从而访问到其他数据。</p><p>如果可以显示数组内容，就可以实现信息泄露；如果可以修改数组内容，就可以实现信息修改。</p></blockquote></li></ul><h5 id="逻辑漏洞"><a class="anchor" href="#逻辑漏洞">#</a> 逻辑漏洞</h5><p>逻辑漏洞主要指程序逻辑上出现的问题，当程序逻辑不严密或者逻辑太复杂，就会导致一些逻辑分支不能正常处理或处理错误。在 PWN 题中较少出现，主要是竞态条件漏洞。</p><ul><li><p>竞态条件漏洞</p><blockquote><p>竞态条件漏洞是指多任务（多进程、多线程等）对同一资源进行访问时，因访问资源的先后顺序不同产生冲突的情况，通过竞态条件漏洞可以实现越权访问、资源篡改等操作。</p></blockquote></li></ul><h5 id="其他平台漏洞"><a class="anchor" href="#其他平台漏洞">#</a> 其他平台漏洞</h5><ul><li>IOT 漏洞</li><li>虚拟机漏洞</li><li>内核漏洞</li><li>...</li></ul><h3 id="reverse"><a class="anchor" href="#reverse">#</a> REVERSE</h3><p>Reverse 即软件逆向工程，是对编译成型的二进制程序进行代码、逻辑和功能分析的过程。在 CTF 中主要考察软件静态分析和动态调试能力，常见的逆向目标为 Windows、Linux 平台下 x86、x64 二进制可执行程序。</p><h4 id="能力要求"><a class="anchor" href="#能力要求">#</a> 能力要求</h4><ul><li>熟悉如操作系统，汇编语言，加解密等相关知识。</li><li>具有丰富的多种高级语言的编程经验。</li><li>熟悉多种编译器的编译原理。</li><li>较强的程序理解和逆向分析能力。</li></ul><h4 id="逆向分析的主要方法"><a class="anchor" href="#逆向分析的主要方法">#</a> 逆向分析的主要方法</h4><ul><li><p>静态分析法</p><blockquote><p>静态分析法是在不执行代码文件的情况下，对代码进行静态分析的一种方法，主要观察代码文件的外部特性，包括文件类型分析和静态反汇编、反编译。通常使用反汇编工具查看内部代码，分析代码结构。</p></blockquote></li><li><p>动态分析法</p><blockquote><p>动态分析法是在程序文件的执行过程中对代码进行动态分析的一种方法，其通过调试来分析代码、获取内存的状态等，目的在于定位关键代码后，在程序运行的过程中，借由输出信息（寄存器，内存变化，程序输出）等来验证自己的推断或是理解程序功能。通常使用调试器来分析程序的内部结构和实现原理。</p></blockquote></li></ul><h4 id="汇编指令体系结构"><a class="anchor" href="#汇编指令体系结构">#</a> 汇编指令体系结构</h4><p>逆向分析的程序所使用的处理器架构通常为 Intel 架构，所以需要对 Intel x86 和 x64 指令体系有所了解，包括：</p><ul><li>x86 指令体系下：<ul><li>寄存器组</li><li>汇编指令集<ul><li>数据传送类指令</li><li>栈操作与函数调用</li><li>算数、逻辑运算指令</li><li>控制转移指令</li><li>特殊指令</li></ul></li><li>x86 应用程序二进制接口</li></ul></li><li>x64 指令体系下与 x86 指令体系相似，这里主要标注<strong>不同点</strong>：<ul><li>寄存器组</li><li>系统调用指令</li><li>x64 应用程序二进制接口</li></ul></li></ul><h4 id="基本工具-2"><a class="anchor" href="#基本工具-2">#</a> 基本工具</h4><h5 id="反汇编和反编译工具"><a class="anchor" href="#反汇编和反编译工具">#</a> 反汇编和反编译工具</h5><p>反汇编工具有很多，但最推荐的是<strong> IDA PRO</strong>，在反编译方面，IDA 自带的 Hex-Ray 反编译插件也是最好的。</p><blockquote><p>IDA 的使用比较复杂，需要自己学习。</p></blockquote><blockquote><p>链接：<span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMVpOOEtkMlFicG5QNXFtMVFCZnhhSUE=">https://pan.baidu.com/s/1ZN8Kd2QbpnP5qm1QBfxaIA</span><br>提取码：j2my</p></blockquote><h5 id="调试工具"><a class="anchor" href="#调试工具">#</a> 调试工具</h5><p>调试工具有以下两个重要功能：</p><ol><li><p>断点设置</p><blockquote><p>允许用户选在程序中任意位置的某行代码，一旦程序运行到这一行，将知识调试工具停止运行程序，并显示程序的当前状态。</p></blockquote></li><li><p>代码跟踪（单步调试）</p><blockquote><p>允许用户在程序运行时跟踪他的执行，程序每执行一条汇编代码后都会暂停，允许用户观察甚至改变程序的状态。</p></blockquote></li></ol><p>调试工具主要根据操作系统来选择</p><ul><li><p>Windows——<strong>Ollydbg</strong></p><blockquote><p>Ollydbg 是 Windows 下一款具有可视化界面的用户态调试工具，推荐从吾爱破解论坛上下载吾爱破解专用版 Ollydbg，这个版本有对抗反调试的功能。</p></blockquote></li><li><p>Linux——<strong>GDB</strong></p><blockquote><p>GDB 是一款功能强大的程序调试工具，是动态调试必不可少的工具，可以很方便的查看堆中链表的状态，各个地址的内容。GDB 拥有多个插件（peda、pwndbg、gef 等）这些插件提供了一些额外的命令，在可视化和功能上都进行了扩展。</p><p>推荐安装一个插件即可，多个插件的切换与系统环境变量相关，自行百度。</p></blockquote></li></ul><h4 id="trace类工具"><a class="anchor" href="#trace类工具">#</a> Trace 类工具</h4><p>Trace 类工具通过一定的方式监控并记录程序的运行，然后使分析者在记录的信息中得到程序的一些动态信息。</p><ul><li><p>Strace</p><blockquote><p>Strace 使 Linux 下一个用来跟踪系统调用的工具，可以监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。</p></blockquote></li><li><p><strong>Qira</strong></p><blockquote><p>Qira 是一个强大的 Trace 类工具，可以将程序整个执行流全部记录下来，然后给予用户<strong>回溯</strong>、查看命中断点的所有指令（即交叉引用）等。</p></blockquote><blockquote><p>Qira 的安装比较难，多多百度 / 谷歌。</p></blockquote></li></ul><h4 id="常规逆向分析流程"><a class="anchor" href="#常规逆向分析流程">#</a> 常规逆向分析流程</h4><h5 id="1-收集信息"><a class="anchor" href="#1-收集信息">#</a> 1、收集信息</h5><p>使用 strings/file/binwalk/IDA 等静态分析工具收集信息，并根据这些静态信息进行 google/github 搜索</p><h5 id="2-干扰分析技术"><a class="anchor" href="#2-干扰分析技术">#</a> 2、干扰分析技术</h5><p>程序为了保护代码，通常会使用一系列技术来干扰逆向分析，这里会介绍一些常见的干扰分析技术。</p><ul><li><p>花指令</p><blockquote><p>花指令是代码保护中一种简单的技巧，原理是在原始代码中插入一段无用的或者能够干扰反汇编引擎的代码。花指令主要影响静态分析，在 IDA 中表现为一些指令无法识别，导致某些函数未能识别，从而无法对这些函数进行反编译。</p></blockquote><blockquote><p>要破解花指令，可以在 IDA 中手动将花指令 patch 成 nop 空指令，从而去除花指令。如果程序中花指令较多，可以通过分析花指令的特定模式，编写 IDAPython 脚本对花指令进行自动化搜索和 patch。</p></blockquote></li><li><p>反调试</p><blockquote><p>反调试技术是指程序在运行时会检测其是否处于被调试状态，如果发现其正在被调试，就无法正常运行。</p></blockquote><blockquote><p>Windows 下通过 Ollydbg 的 StringOD 插件可以过滤掉大多数的反调试方法。</p><p>Liunx 下主要利用 ptrace 系统调用、proc 文件系统检测和父进程检测来检测自身是否正在被调试，针对这些反调试方法，常用的方法就是定位到反调试的代码，然后对程序进行 patch，在不影响程序正常功能的情况下，跳过对调试器的检测代码。</p></blockquote></li><li><p>加壳</p><blockquote><p>加壳是指在二进制的程序中植入一段代码。在运行的时候优先取得程序的控制权，这段代码会在执行的过程中对原始指令进行解密还原，之后再将控制权交还给原始代码，执行原来的代码。</p><p>被加过壳的程序，其真正的代码是加密存放在二进制文件中的，只有在执行时才从内存中解密还原出来，因此没法对加了壳的程序直接进行静态分析。</p></blockquote><blockquote><p>在 CTF 比赛中出现的带壳程序通常为已知的壳，大部分都可以通过使用专用工具或者脚本的脱壳。</p><p>可以使用 PEiD 工具查询该带壳程序用的什么壳，再用对应工具或脚本脱壳。</p></blockquote></li><li><p>控制流混淆</p><blockquote><p>对于控制流混淆的程序，没有办法直接进行静态分析，也无法进行反编译，而调试器调试也会陷入控制流的跳转混乱中。</p></blockquote><blockquote><p>对于控制流混淆的程序，通常通过 Trace 工具记录下程序运行的所有指令，然后再运行这些指令的基础上进行数据流分析。</p></blockquote></li><li><p>双进程保护（Debug Blocker）</p><blockquote><p>双进程保护是一种在调试模式下运行自身程序的方法。这种保护通常存在两个进程，由父进程调试子进程。实际功能的代码运行在子进程中，但是因为子进程已经处于调试状态，无法再使用其他调试器进行附加操作。同时父进程能够控制子进程，通过处理子进程的异常，可以控制子进程正常运行。</p><p>双进程保护技术的难点在于，真正的功能运行在子进程中，若要调试子进程，就需要断开其与父进程之间的链接，但是一旦断开，没有父进程处理子进程的异常，会导致子进程无法正常运行。</p></blockquote><blockquote><p>对于双进程保护的程序，其父进程通常功能单一，因此先针对父进程，了解其处理子进程异常的逻辑，然后调试子程序，使其脱离父进程之后仍能正常运行，最后在对子进程进行调试分析。</p></blockquote></li></ul><h5 id="3-关键代码定位"><a class="anchor" href="#3-关键代码定位">#</a> 3、关键代码定位</h5><p>在一个可执行程序中，汇编代码数量庞大，所以要能够定位出真正需要分析的关键代码，只有找到关键代码之后，才能对关键代码采用的算法进行分析，理清程序功能，最后针对程序功能，写出对应脚本，解出 flag。</p><p>这里给出 3 个常用的关键代码定位法</p><ul><li><p>API 断点法</p><blockquote><p>例如：在获取文本输入时，窗口类程序获取文本的方式主要是通过 GetWindowsText 和 GetDlgItemText 两个 API 来获取。在输出结果时，会弹出对话框，这时调用的 API 通常为 MessageBox。在这些 API 函数中下断点，在调试工具中断下来后，通过栈回溯即可定位到关键代码。</p></blockquote></li><li><p>字符串检索法</p><blockquote><ul><li><p>在 IDA 中</p><p>打开 Strings 子窗口，通过 Ctrl+F 输入想要查找的字符串。</p></li><li><p>在 Ollydbg 中</p><p>通过 Alt+E，可以查看可执行模块，找到主模块，点击右键，选择中文搜索引擎，根据需要搜索 ASCII 或者 UNICODE。</p></li></ul></blockquote></li><li><p>辅助工具定位法</p><blockquote><p>针对特定语言或编译器生成的程序，可以用一些辅助工具帮助快速定位案件处理程序的地址。</p><p>如：针对 MFC 程序的 xspy，针对 Delphi 程序的 Dede。</p></blockquote></li></ul><h5 id="4-常见加密算法识别"><a class="anchor" href="#4-常见加密算法识别">#</a> 4、常见加密算法识别</h5><p>在对数据进行变换时，通常会使用一些常用的加密算法，如果能够快速识别出对应的加密算法，就能更快的分析出整个完整的算法，下面给出 CTF 比赛中常用的几种加密算法。</p><ul><li><p><strong>base64</strong></p><blockquote><p>base64 将输入中的每 3 字节（24 比特）按每 6 比特分成一组，编程 4 个小于 64 的索引值，然后通过一个索引表得到 4 个可见字符。</p></blockquote><blockquote><p>索引表为一个 64 字节的字符串：</p></blockquote><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre>“ABCDEFGHIJKLMNOPQRSTUVMXYZabcdefghijklmnopqrstuvwxyz0123456789<span class="token operator">+</span><span class="token operator">/</span>”</pre></td></tr></table></figure><blockquote><p>如果在代码中发现引用了这个索引表，基本可以确定是 base64。此外，还有一些变种的 base64，主要是改变了索引表。</p></blockquote></li><li><p><strong>TEA</strong></p><blockquote><p>TEA 算法是一种常见的分组加密算法，密钥为 128 比特位，明文为 64 比特位，主要做了 32 轮变换，每轮变换都涉及移位和变换。</p></blockquote><blockquote><p>在 TEA 算法中有一个固定的常数 0x9e3779b9 或者 0x61x88647。</p><p>如果在加密函数中发现了这个常数，基本可以确定是 TEA。</p></blockquote></li><li><p><strong>AES</strong></p><blockquote><p>AES 是一种常见的分组加密算法，加密过程涉及 4 种操作：字节替代、行移位、列混淆、轮密钥加。其中字节替代过程是通过 S 盒完成一个字节到另一个字节的映射。（S 盒的结构自行百度）</p></blockquote><blockquote><p>如果发现程序中有 S 盒或者动态生成了 S 盒，基本可以确定是 AES。</p></blockquote></li><li><p><strong>RC4</strong></p><blockquote><p>RC4 算法属于流加密算法，包括初始化函数和加解密函数。其中初始化代码对某一字符数组进行了初始化赋值，且赋值分别递增，之后又对数组进行了 256 次交换操作。</p></blockquote><blockquote><p>通过识别初始化代码，可以判断是否为 RC4。</p></blockquote></li><li><p><strong>MD5</strong></p><blockquote><p>MD5 信息摘要算法，是一种广泛使用的密码散列函数，会产生一个 128 位（16 字节）的散列值。</p></blockquote><blockquote><p>MD5 加密算法中有个初始化函数 MD5Init ()，会初始化四个 MD5 链接变量的整型参数。分别为 0x67452301、0xefcdab89、0x98badcfe、0x10325476，当看到这四个常数，就可以怀疑是 MD5。</p></blockquote></li></ul><h5 id="5-求解flag"><a class="anchor" href="#5-求解flag">#</a> 5、求解 flag</h5><ul><li><p>直接从内存获取</p><blockquote><p>一些比较简单的题目可以直接查看内存来获取 flag，这种题目只需要在特定的地方下断点，然后查看内存即可获得 flag。</p></blockquote></li><li><p>对算法进行逆变换操作</p><blockquote><p>这类题目要根据程序的输出结果，再分析程序的加密算法，然后编写出对应的逆算法得到 flag。</p></blockquote></li><li><p>线性变换的求解</p><blockquote><p>如果加密算法是一个线性变换，output 的第 i 位只能由 input 的第 i 位决定，通过获取 input [i] 的所有可能输入对应的输出 output [i]，即可求出 input [i]，对于这种变换，可以进行单字符爆破。</p></blockquote></li><li><p>约束求解</p><blockquote><p>如果在 output=convert (input) 之后，需要 output 满足多个约束条件，这种情况下就属于约束求解。</p><p>通常会用到的约束求解器为 z3。</p></blockquote></li></ul><h5 id="小结"><a class="anchor" href="#小结">#</a> 小结</h5><ol><li>使用 strings/file/binwalk/IDA 等静态分析工具收集信息，并根据这些静态信息进行 google/github 搜索。</li><li>研究程序的保护方法，如代码混淆，保护壳及反调试等技术，并设法破除或绕过保护。</li><li>反汇编目标软件，快速定位到关键代码进行分析。</li><li>结合动态调试，验证自己的初期猜想，在分析的过程中理清程序功能。</li><li>针对程序功能，写出对应脚本，求解出 flag。</li></ol><h2 id="实战进阶"><a class="anchor" href="#实战进阶">#</a> 实战 &amp; 进阶</h2><p>一般情况下，大一、大二通过 CTF 比赛学习相应技术，大三开始接触实战。</p><p>根据自己的积累和兴趣，可选取一个方向去深入，例如文件媒体解析类、内核、浏览器内核、IOT、移动端等等。</p><p>下面是一些实战 &amp; 进阶 &amp; 提升的方式</p><ul><li><p>复现漏洞</p></li><li><p>学习漏洞挖掘技术（fuzz)</p></li><li><p>关注顶会议题，尝试寻找攻击面去实践漏洞挖掘</p><ul><li>blcak hat</li><li>poc</li></ul></li><li><p>安全研究漏洞分析</p></li><li><p>甲方</p><ul><li>对内漏洞挖掘</li><li>安全攻防</li></ul></li><li><p>病毒分析</p></li><li><p>纯逆向</p></li><li><p>移动安全、安全加固（移动端)</p></li><li><p>游戏安全</p></li></ul><div class="tags"><a href="/tags/pwn/" rel="tag"><i class="ic i-tag"></i> pwn</a> <a href="/tags/reserve/" rel="tag"><i class="ic i-tag"></i> reserve</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2021-12-11 23:57:50" itemprop="dateModified" datetime="2021-12-11T23:57:50+08:00">2021-12-11</time></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Coldwinds <i class="ic i-at"><em>@</em></i>冷风喧嚣</li><li class="link"><strong>本文链接：</strong> <a href="https://coldwinds5167.github.io/2021/12/pwn-reserve-start/" title="二进制（pwn、reverse）学习方向">https://coldwinds5167.github.io/2021/12/pwn-reserve-start/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2021/12/pwn-environment/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclize41wj20zk0m87gk.jpg" title="pwn环境搭建"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>pwn环境搭建</h3></a></div><div class="item right"></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0x00-%E5%AE%89%E5%85%A8%E7%B4%A0%E5%85%BB"><span class="toc-number">1.</span> <span class="toc-text">0x00 安全素养</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">网络安全法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x01-%E5%9F%BA%E7%A1%80"><span class="toc-number">2.</span> <span class="toc-text">0x01 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%8A%9F%E5%BA%95"><span class="toc-number">2.1.</span> <span class="toc-text">编程语言功底</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%86%E5%90%91%E5%8A%9F%E5%BA%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">2.2.</span> <span class="toc-text">逆向功底 &amp; 底层原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x02-%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8"><span class="toc-number">3.</span> <span class="toc-text">0x02 二进制安全</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ctf"><span class="toc-number">3.1.</span> <span class="toc-text">CTF</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pwn"><span class="toc-number">3.1.1.</span> <span class="toc-text">PWN</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">配置环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">基本工具</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%86%E5%90%91%E8%BE%85%E5%8A%A9%E7%B1%BB"><span class="toc-number">3.1.1.2.1.</span> <span class="toc-text">逆向辅助类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E7%B1%BB"><span class="toc-number">3.1.1.2.2.</span> <span class="toc-text">漏洞利用类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6"><span class="toc-number">3.1.1.3.</span> <span class="toc-text">保护机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E9%80%89%E9%A1%B9"><span class="toc-number">3.1.1.3.1.</span> <span class="toc-text">系统选项</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9"><span class="toc-number">3.1.1.3.2.</span> <span class="toc-text">编译选项</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E"><span class="toc-number">3.1.1.4.</span> <span class="toc-text">常见漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%88%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E"><span class="toc-number">3.1.1.4.1.</span> <span class="toc-text">栈相关漏洞</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%88%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%A9%E7%94%A8"><span class="toc-number">3.1.1.4.2.</span> <span class="toc-text">栈相关漏洞的利用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A0%86%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%A0%86%E6%BC%8F%E6%B4%9E%E6%98%AFctf%E6%AF%94%E8%B5%9B%E9%87%8D%E7%82%B9"><span class="toc-number">3.1.1.4.3.</span> <span class="toc-text">堆相关漏洞（堆漏洞是 CTF 比赛重点）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A0%86%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%A9%E7%94%A8"><span class="toc-number">3.1.1.4.4.</span> <span class="toc-text">堆相关漏洞的利用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E"><span class="toc-number">3.1.1.4.5.</span> <span class="toc-text">格式化字符串漏洞</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A9%E7%94%A8"><span class="toc-number">3.1.1.4.6.</span> <span class="toc-text">格式化字符串的利用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B%E6%BC%8F%E6%B4%9E"><span class="toc-number">3.1.1.4.7.</span> <span class="toc-text">整型漏洞</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E"><span class="toc-number">3.1.1.4.8.</span> <span class="toc-text">逻辑漏洞</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%B9%B3%E5%8F%B0%E6%BC%8F%E6%B4%9E"><span class="toc-number">3.1.1.4.9.</span> <span class="toc-text">其他平台漏洞</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reverse"><span class="toc-number">3.1.2.</span> <span class="toc-text">REVERSE</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%BD%E5%8A%9B%E8%A6%81%E6%B1%82"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">能力要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E7%9A%84%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">逆向分析的主要方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.2.3.</span> <span class="toc-text">汇编指令体系结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7-2"><span class="toc-number">3.1.2.4.</span> <span class="toc-text">基本工具</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8D%E6%B1%87%E7%BC%96%E5%92%8C%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7"><span class="toc-number">3.1.2.4.1.</span> <span class="toc-text">反汇编和反编译工具</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7"><span class="toc-number">3.1.2.4.2.</span> <span class="toc-text">调试工具</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#trace%E7%B1%BB%E5%B7%A5%E5%85%B7"><span class="toc-number">3.1.2.5.</span> <span class="toc-text">Trace 类工具</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%84%E9%80%86%E5%90%91%E5%88%86%E6%9E%90%E6%B5%81%E7%A8%8B"><span class="toc-number">3.1.2.6.</span> <span class="toc-text">常规逆向分析流程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%94%B6%E9%9B%86%E4%BF%A1%E6%81%AF"><span class="toc-number">3.1.2.6.1.</span> <span class="toc-text">1、收集信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%B9%B2%E6%89%B0%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF"><span class="toc-number">3.1.2.6.2.</span> <span class="toc-text">2、干扰分析技术</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81%E5%AE%9A%E4%BD%8D"><span class="toc-number">3.1.2.6.3.</span> <span class="toc-text">3、关键代码定位</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%B8%B8%E8%A7%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E8%AF%86%E5%88%AB"><span class="toc-number">3.1.2.6.4.</span> <span class="toc-text">4、常见加密算法识别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E6%B1%82%E8%A7%A3flag"><span class="toc-number">3.1.2.6.5.</span> <span class="toc-text">5、求解 flag</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">3.1.2.6.6.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E8%BF%9B%E9%98%B6"><span class="toc-number">3.2.</span> <span class="toc-text">实战 &amp; 进阶</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Coldwinds" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Coldwinds</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">4</span> <span class="name">文章</span></a></div><div class="item tags"><a href="/tags/"><span class="count">3</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NvbGR3aW5kczUxNjc=" title="https:&#x2F;&#x2F;github.com&#x2F;Coldwinds5167"><i class="ic i-github"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjgyNTU5MjA4NUBxcS5jb20=" title="mailto:825592085@qq.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a></li><li class="item"><a href="/links/" rel="section"><i class="ic i-magic"></i>links</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"></div><span><a href="/2021/12/pwn-environment/" title="pwn环境搭建">pwn环境搭建</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2021/12/Re-Entrancy/" title="重入攻击">重入攻击</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2021/12/Blockchain-profiles/" title="区块链简介">区块链简介</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2021/12/pwn-reserve-start/" title="二进制（pwn、reverse）学习方向">二进制（pwn、reverse）学习方向</a></span></li></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Coldwinds @ Coldwinds</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">19k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">17 分钟</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2021/12/pwn-reserve-start/",favicon:{show:"欢迎回来~",hide:"网页消失啦~"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>